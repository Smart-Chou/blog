<!DOCTYPE html>
<html data-html-server-rendered="true" lang="en" data-vue-tag="%7B%22lang%22:%7B%22ssr%22:%22en%22%7D%7D">
  <head>
    <title>cwim 背后的故事：Rust 与 Ownership - Spencer&#x27;s Blog</title><meta name="gridsome:hash" content="adc5dd754921ba01e034b10e05b52eb94e7d1500"><meta data-vue-tag="ssr" charset="utf-8"><meta data-vue-tag="ssr" name="generator" content="Gridsome v0.7.23"><meta data-vue-tag="ssr" data-key="viewport" name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover"><meta data-vue-tag="ssr" data-key="format-detection" name="format-detection" content="telephone=no"><meta data-vue-tag="ssr" name="description" content="Rust 是如何保证「内存安全」的"><link data-vue-tag="ssr" rel="icon" href="data:,"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="16x16" href="/assets/static/favicon.ce0531f.d1135162e600804de5a368c5252e558c.png"><link data-vue-tag="ssr" rel="icon" type="image/png" sizes="32x32" href="/assets/static/favicon.ac8d93a.d1135162e600804de5a368c5252e558c.png"><link rel="preload" href="/assets/css/0.styles.505fe61b.css" as="style"><link rel="preload" href="/assets/js/app.017f69db.js" as="script"><link rel="preload" href="/assets/js/page--src--templates--blog-post-vue.8c30e663.js" as="script"><link rel="prefetch" href="/assets/js/page--src--pages--404-vue.0121d1c3.js"><link rel="prefetch" href="/assets/js/page--src--pages--archives-vue.2aef679f.js"><link rel="prefetch" href="/assets/js/page--src--pages--friends-vue.eb0e6337.js"><link rel="prefetch" href="/assets/js/page--src--pages--index-vue.933a26a7.js"><link rel="prefetch" href="/assets/js/page--src--templates--tag-vue.11c8826a.js"><link rel="stylesheet" href="/assets/css/0.styles.505fe61b.css"><noscript data-vue-tag="ssr"><style>.g-image--loading{display:none;}</style></noscript>
  </head>
  <body >
    <script>
      // Add dark / light detection that runs before Vue.js load. Borrowed from overreacted.io
      ;(function() {
        window.__onThemeChange = function() {}
        function setTheme(newTheme) {
          window.__theme = newTheme
          preferredTheme = newTheme
          document.body.setAttribute('data-theme', newTheme)
          window.__onThemeChange(newTheme)
        }

        var preferredTheme
        try {
          preferredTheme = localStorage.getItem('theme')
        } catch (err) {}

        window.__setPreferredTheme = function(newTheme) {
          setTheme(newTheme)
          try {
            localStorage.setItem('theme', newTheme)
          } catch (err) {}
        }

        var darkQuery = window.matchMedia('(prefers-color-scheme: dark)')
        darkQuery.addListener(function(e) {
          window.__setPreferredTheme(e.matches ? 'dark' : 'light')
        })

        setTheme(preferredTheme || (darkQuery.matches ? 'dark' : 'light'))
      })()
    </script>

    <div id="app" data-server-rendered="true"><div id="nprogress-container"><header class="header"><div class="header__left"><div><a href="/" class="logo active"><span class="logo__text">
      ▲   Spencer's Blog
    </span></a></div></div><div class="header__right"><button role="button" aria-label="Toggle dark/light" class="toggle-theme"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg></button></div></header></div><main class="main"><div><div class="post-title"><h1 class="post-title__text">
      cwim 背后的故事：Rust 与 Ownership
      <!----></h1><div class="post-meta">
  Posted January 23. 2020.
  
    3472 words.
    <strong>16 min read.
      </strong></div></div><div class="post content-box"><div class="post__header"><img alt="Cover image" src="data:image/svg+xml,%3csvg fill='none' viewBox='0 0 1280 400' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-f8ebcfd3e52c8208849f238e864d7ea2'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='10'/%3e%3c/filter%3e%3c/defs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-f8ebcfd3e52c8208849f238e864d7ea2)' width='1280' height='400' xlink:href='data:image/png%3bbase64%2cUklGRgABAABXRUJQVlA4IPQAAABQBQCdASpAABQAPm0wlEYkIyIhKAwAgA2JZQDH5YvX4eSBpQgz7rV3GYQyGzG0jiHolYAA/vpOUtXaoy1%2bxnyV6uuL998TwIbh2G62XtQveW0BGj2IlqLHW5vt95EAfIGf8xXvpf9nVW4%2bV15E04YWUUjUbb9RV%2bRVrhOx1ihoiBu8fw7iOmnWLDexmgWJb0WqFLSyBhGjBuAhyPwfHrlou9jogWRbxEXq9NSc9srE5rE3kmhNJSstr/svlixo/eRY7NzwTbPhmYQLVYTQ/fSQfNnGlkqM1B4/xu9oAH25v%2btpE6q6Wa7RBw/DUrAgEx1QAAAA' /%3e%3c/svg%3e" width="1280" data-src="/assets/static/cli-app-in-rust.a209973.3e7fdea529882665eabb3f6b560413e1.png" data-srcset="/assets/static/cli-app-in-rust.a67b0b2.3e7fdea529882665eabb3f6b560413e1.png 480w, /assets/static/cli-app-in-rust.a209973.3e7fdea529882665eabb3f6b560413e1.png 1280w" data-sizes="(max-width: 1280px) 100vw, 1280px" class="g-image g-image--lazy g-image--loading"><noscript><img src="/assets/static/cli-app-in-rust.a209973.3e7fdea529882665eabb3f6b560413e1.png" class="g-image g-image--loaded" width="1280" alt="Cover image"></noscript></div><!----><div class="post__content"><p>前几天 Stack Overflow 博客上面有一篇文章<sup id="fnref-1"><a href="#fn-1" class="footnote-ref">1</a></sup>，里面提到了 Rust 已经连续四年位列 Stack Overflow 社区最爱编程语言榜首。的确，Rust 是一门神奇又美丽的语言。Rust 是一门标榜 safe 与 zero-cost abstraction 的语言<sup id="fnref-2"><a href="#fn-2" class="footnote-ref">2</a></sup>，意味着只要你编写的 Rust 代码符合官方标准 —— 能够通过编译 —— 那么你的项目几乎可以肯定地说是内存安全的。</p>
<h2 id="初衷"><a href="#%E5%88%9D%E8%A1%B7" aria-hidden="true"><span class="icon icon-link"></span></a>初衷</h2>
<p>偏向底层的 Rust 让我在之前一直没有机会尝试，毕竟我相信国内高校没有一所是敢直接抛弃 C、C++ 而使用 Rust 作为其主语言进行授课的。最近我重构了 <a href="https://dowww.spencerwoo.com" target="_blank" rel="nofollow noopener noreferrer">Dev on Windows with WSL</a>：一个近 2w 字的 WSL 开发配置文档。我前后用了大概半个月的时间，增加了许多内容，因此我在结束编写工作之后，试图找到一个类似 <code class="language-text">cloc</code>，能帮我统计一个目录下全部 Markdown 文件的命令行工具。很失望，没找到。</p>
<p>我决定自己尝试实现这个命令行工具，当然，我也相信 Python、Node.js、Ruby 等脚本语言一定适合做这些事情，毕竟 <code class="language-text">cloc</code> 本身就是使用 Perl 实现的。不过，Rust 作为一门高效的、静态的、可以直接编译到三个操作系统的底层语言，还是很有吸引力的。因此我才决定使用 Rust 开新坑。</p>
<figure><img src="https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215236.png" alt="使用 Rust 实现的 cwim - Count words in Markdown"><figcaption>使用 Rust 实现的 cwim - Count words in Markdown</figcaption></figure>
<p>另外：cwim 的第一个小版本我已经编译并发布 Release 版本，有兴趣的同学可以前往 GitHub 查看：<a href="https://github.com/spencerwooo/cwim" target="_blank" rel="nofollow noopener noreferrer">spencerwooo/cwim</a>.</p>
<h2 id="开始一个-rust-项目"><a href="#%E5%BC%80%E5%A7%8B%E4%B8%80%E4%B8%AA-rust-%E9%A1%B9%E7%9B%AE" aria-hidden="true"><span class="icon icon-link"></span></a>开始一个 Rust 项目</h2>
<p>Rust 最 beginner friendly 的地方我觉得在于其<a href="https://www.rust-lang.org/zh-CN/learn/get-started" target="_blank" rel="nofollow noopener noreferrer">官方入门文档</a>的简洁易懂。从安装、编译到包管理、打包项目 …… Rust 的官方文档讲解的都比任何其他语言的文档讲解的要易懂不少。我这里简单记录一下 Rust 环境的安装搭建的基本过程。</p>
<h3 id="安装-rust-环境"><a href="#%E5%AE%89%E8%A3%85-rust-%E7%8E%AF%E5%A2%83" aria-hidden="true"><span class="icon icon-link"></span></a>安装 Rust 环境</h3>
<p>Rust 语言虽然小众，但是其生态相当完善。Rust 借鉴了其他语言的多种环境配置工具，官方直接提供了一整套完善的闭环 Toolkit，基本能满足我们在使用 Rust 时的安装、构建、编译、发布的整套流程：</p>
<ul>
<li>Rustup：Rust 版本管理（类似 Python 的 <code class="language-text">pyenv</code>、Node.js 的 <code class="language-text">nvm</code> 等）</li>
<li>Cargo：Rust 构建工具与包管理（类似 Python 的 <code class="language-text">pip</code>、Node.js 的 <code class="language-text">yarn</code> 等）</li>
<li>crates.io：Rust 的 Package Registry</li>
</ul>
<p>首先，我们安装 Rustup：Rust 安装器与 Rust 版本控制器。使用 Arch Linux（以及 WSL 的 Arch Linux）的同学可以直接在 AUR 中安装 <code class="language-text">rustup</code>：</p>
<pre class="language-bash"><code class="language-bash">yay rustup</code></pre>
<p>如果使用 WSL 其他 Linux 发行版，我们也可以用下面的命令安装 <code class="language-text">rustup</code>：</p>
<pre class="language-bash"><code class="language-bash"><span class="token function">curl</span> <span class="token parameter variable">--proto</span> <span class="token string">'=https'</span> <span class="token parameter variable">--tlsv1.2</span> <span class="token parameter variable">-sSf</span> https://sh.rustup.rs <span class="token operator">|</span> <span class="token function">sh</span></code></pre>
<p>其他安装方法请参考：<a href="https://www.rust-lang.org/zh-CN/tools/install" target="_blank" rel="nofollow noopener noreferrer">Rust | 安装 Rust</a></p>
<p>安装了 <code class="language-text">rustup</code> 之后，我们就应该已经安装完成了 Cargo：Rust 的构建工具与包管理工具。Cargo 可以做很多事情：</p>
<pre class="language-bash"><code class="language-bash"><span class="token function">cargo</span> build     <span class="token comment"># 可以构建项目</span>
<span class="token function">cargo</span> run       <span class="token comment"># 可以运行项目</span>
<span class="token function">cargo</span> <span class="token builtin class-name">test</span>      <span class="token comment"># 可以测试项目</span>
<span class="token function">cargo</span> doc       <span class="token comment"># 可以为项目构建文档</span>
<span class="token function">cargo</span> publish   <span class="token comment"># 可以将库发布到 crates.io</span></code></pre>
<p>要检查是否安装了 Rust 和 Cargo，可以在终端中运行：</p>
<pre class="language-bash"><code class="language-bash"><span class="token function">cargo</span> <span class="token parameter variable">--version</span></code></pre>
<p>接下来我们就可以使用 Cargo 来创建一个 Rust 项目，并用它来安装我们必须的 Rust 库等内容。</p>
<h3 id="rust--vs-code"><a href="#rust--vs-code" aria-hidden="true"><span class="icon icon-link"></span></a>Rust / VS Code</h3>
<p>VS Code 是一个通用的文本 / 代码编辑器，能够通过插件支持多种语言环境下代码的编写任务。我们下载 Rust 官方提供的 VS Code 插件：<a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust" target="_blank" rel="nofollow noopener noreferrer">Visual Studio Code Marketplace | Rust (rls)</a></p>
<figure><img src="https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215236-1.png" alt="Visual Studio Code Marketplace | Rust (rls)"><figcaption>Visual Studio Code Marketplace | Rust (rls)</figcaption></figure>
<p>之后，我们用 Cargo 创建一个新的项目 <code class="language-text">hello-rust</code>：</p>
<pre class="language-bash"><code class="language-bash"><span class="token function">cargo</span> new hello-rust</code></pre>
<p>或者在已有文件夹 <code class="language-text">hello-rust</code> 下，生成新 Rust 项目：</p>
<pre class="language-bash"><code class="language-bash"><span class="token builtin class-name">cd</span> hello-rust
<span class="token function">cargo</span> init</code></pre>
<p>新的 Rust 项目目录下应该拥有以下内容：</p>
<pre class="language-bash"><code class="language-bash">hello-rust      <span class="token comment"># 根目录</span>
<span class="token operator">|</span>- Cargo.toml   <span class="token comment"># Rust 的清单文件，其中包含项目的元数据和依赖库</span>
<span class="token operator">|</span>- src
  <span class="token operator">|</span>- main.rs    <span class="token comment"># 主程序入口</span></code></pre>
<p>用 VS Code 打开这一目录，我们即可开始 Rust 项目的编写。</p>
<figure><img src="https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215236-2.png" alt="使用 VS Code 撰写 Rust 项目"><figcaption>使用 VS Code 撰写 Rust 项目</figcaption></figure>
<p>使用下面命令即可运行项目：</p>
<pre class="language-bash"><code class="language-bash"><span class="token function">cargo</span> run</code></pre>
<h2 id="rust-语言特性"><a href="#rust-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7" aria-hidden="true"><span class="icon icon-link"></span></a>Rust 语言特性</h2>
<p>在用 Rust 编写 <code class="language-text">cwim</code> 的时候，有两个令我印象深刻的地方：一个是 Rust 语言实际上非常清晰易懂，有 C、C++ 等强类型语言的严谨，也有脚本语言的易读；另一个就是 Rust 编译器非常严格，但给我们的问题提示也非常清晰，方便追溯问题所在，容易 debug。严苛的 Rust 编译器让我们必须考虑「内存分配」，也正因如此，使得 <strong>Rust 在并未实现「垃圾回收」的前提下，确保了任何 Rust 程序都生来具有「内存安全」特性。</strong></p>
<blockquote>
<p>🧲 <strong>Rust Playground</strong></p>
<p>下面涉及到的代码内容可以在 Rust 在线 Playground 中自己尝试。链接位于：<a href="https://play.rust-lang.org" target="_blank" rel="nofollow noopener noreferrer">Rust Playground</a></p>
</blockquote>
<h3 id="ownership"><a href="#ownership" aria-hidden="true"><span class="icon icon-link"></span></a>Ownership</h3>
<p>Rust 的 Ownership（所有权）是保证 Rust 程序「内存安全」的重点特性。什么是「内存安全」？保证「内存安全」就是指或语言本身，或使用语言的开发者，在其程序运行时管理系统的「内存分配」的过程中保证内存没有浪费、没有泄露。我们一般的程序都需要实施「静态」与「动态」两种形式的内存分配，其中前者指已知变量所需空间，直接在内存中划分一部分不变的区域给变量；后者为在程序运行过程中动态地给变量分配内存空间，使得变量能够在程序运行时变化地占用内存大小。</p>
<h3 id="数据存储方式"><a href="#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F" aria-hidden="true"><span class="icon icon-link"></span></a>数据存储方式</h3>
<p>Rust 是使用「栈」和「堆」这两种数据结构来对这两种内存分配形式进行划分的。为了更好的理解 Rust 的 Ownership 的工作机制，我们首先看看 Rust 是如何利用「栈」和「堆」进行内存分配。</p>
<figure><img src="https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215236-3.png" alt="使用「栈」和「堆」进行内存分配"><figcaption>使用「栈」和「堆」进行内存分配</figcaption></figure>
<p>首先，「栈」从实现上来说是一种效率非常高的数据结构，因为「栈」拥有「后进先出」的数据存储特点（LIFO），使得最后压入栈顶的元素会被最先从栈顶移出。这种数据结构的优势在于：当我们用「栈」来维护内存数据时，<strong>我们只需要维护「栈顶」元素的信息即可</strong>。同时，Rust 内存管理的「栈」在编译时即可知道其具体大小，静态分配内存空间即可<sup id="fnref-3"><a href="#fn-3" class="footnote-ref">3</a></sup>。</p>
<p>而 Rust 的「堆」则不一样，「堆」是一个动态分配内存空间的数据结构。当我们使用「堆」分配内存空间时，我们实际上是在「堆」上寻找对应的内存地址，将之标记，并返回与之相对映的指针。这一过程跟我们 C、C++ 中的 allocate memory 的原理是一致的。</p>
<h3 id="所有权如何保证内存安全"><a href="#%E6%89%80%E6%9C%89%E6%9D%83%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8" aria-hidden="true"><span class="icon icon-link"></span></a>所有权如何保证内存安全</h3>
<p>为什么 Rust 需要引入「所有权」的机制？因为 Rust 保证「内存安全」的方法是：追踪第二种「堆」结构中哪部分数据被哪部分代码使用，从而尽量减少「堆」中的重复数据，保证「堆」中不出现有未使用的数据等问题。</p>
<blockquote>
<p>Keeping track of what parts of code are using what data on the heap, minimizing the amount of duplicate data on the heap, and cleaning up unused data on the heap so you don’t run out of space are all problems that ownership addresses. —— <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html" target="_blank" rel="nofollow noopener noreferrer">The Rust Book</a></p>
</blockquote>
<p>Rust 正是使用基于「所有权」理念的一系列规定来保证 Rust 程序的「内存安全」。这其中的机制包括：</p>
<ul>
<li>Rust 中的每个「值」都有一个被叫做 owner 的变量（所有者）</li>
<li>同一时间只能有一个 owner</li>
<li>当 owner 离开我们程序段的 scope 之后，这一「值」就会被释放掉</li>
</ul>
<p>我们来看下面的几个例子，来具体看看 Rust 如何保证「内存安全」的。</p>
<p>我们以 Rust 中字符串（String Literal）为例子，Rust 中字符串有 <code class="language-text">&amp;str</code> 的静态字符串变量，以及 <code class="language-text">String</code> 的动态字符串变量。我们来看看 Rust 是如何分别利用「栈」来存储 <code class="language-text">&amp;str</code>、用「堆」来存储 <code class="language-text">String</code> 的。</p>
<p>首先来看一个 <code class="language-text">&amp;str</code> 的例子：</p>
<pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// &amp;str 用「栈」存储</span>
  <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token string">"Hello"</span><span class="token punctuation">;</span>    <span class="token comment">// 字符串 "Hello" 赋值给变量 s1</span>
  <span class="token keyword">let</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">;</span>         <span class="token comment">// 将变量 s1 复制并赋值给 s2</span>
  <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> s1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 这样做没有问题！</span>
<span class="token punctuation">}</span></code></pre>
<p>可以发现，当我们直接使用 <code class="language-text">&amp;str</code> 存储字符串时，Rust 是将前一个变量 <code class="language-text">s1</code> 的值<strong>直接复制</strong>给后一个变量 <code class="language-text">s2</code>，前一个变量 <code class="language-text">s1</code> 并没有变化。此时我们访问前一个变量 <code class="language-text">s1</code> 没有任何问题。</p>
<p>接下来，我们来看一个 <code class="language-text">String</code> 的例子：</p>
<pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// String 用「堆」存储</span>
  <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"Hello again"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// String 变量 "Hello again" 赋值给 s1</span>
  <span class="token keyword">let</span> s2 <span class="token operator">=</span> foo<span class="token punctuation">;</span>                         <span class="token comment">// 将 s1 变量中的内容「移动」到 s2 中</span>
  <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"{}, {}"</span><span class="token punctuation">,</span> s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// 出错了！s1 中内容被 moved，无法被 reference</span>
<span class="token punctuation">}</span></code></pre>
<p>此时，编译器会报出 <code class="language-text">error[E0382]: borrow of moved value: &#39;s1&#39;</code> 的错误。可以发现，当我们使用 String 存储字符串时，Rust 不会将变量的值「复制」，而是会将变量「移动」到目标变量中。这种情况下，Rust 会认为前一个变量 <code class="language-text">s1</code> 已经不再有效（no longer valid），因此，当我们在之后试图访问 <code class="language-text">s1</code> 时，Rust 就会报出这一错误。</p>
<figure><img src="https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215236-4.png" alt="error[E0382] 报错"><figcaption>error[E0382] 报错</figcaption></figure>
<p>为什么 Rust 在使用「堆」进行动态内存分配时，会 move 而不 copy 呢？一方面是因为 copy 的消耗是比 move 大得多的；另一方面，Rust 这一设计恰好帮助我们避免了 C 语言中非常可能遇到的一种内存泄露的问题：<strong>double free 异常</strong><sup id="fnref-4"><a href="#fn-4" class="footnote-ref">4</a></sup>。</p>
<p>Double free 异常是如何发生的？当我们使用 <code class="language-text">String</code> 类型来存储字符串时，我们实际上存储了以下三个 field 的值：<code class="language-text">ptr</code>、<code class="language-text">len</code>、<code class="language-text">capacity</code>。<code class="language-text">ptr</code> 指向存储字符串内容的内存空间。比如 <code class="language-text">let s1 = String::from(&quot;Hello&quot;);</code> 即声明了如下的存储方式：</p>
<figure><img src="https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215236-5.png" alt="String 的存储方式"><figcaption>String 的存储方式</figcaption></figure>
<p>我们如果使用 <code class="language-text">copy</code> 将 String <code class="language-text">s1</code> 复制给 <code class="language-text">s2</code>，我们实际上就将三个 field 的值 <code class="language-text">ptr</code>、<code class="language-text">len</code> 和 <code class="language-text">capacity</code> 全部复制，也就是我们的 <code class="language-text">ptr</code> 指针实际上指向上一块地址空间，如下图所示：</p>
<figure><img src="https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215236-6.png" alt="使用 copy 将 s1 复制给 s2"><figcaption>使用 copy 将 s1 复制给 s2</figcaption></figure>
<p>前面我们提到了，<em>对于一个「值」来说，当程序离开「值」的 owner 所在的 scope 之后，这一「值」就会被释放掉</em>，那么当我们离开 <code class="language-text">s1</code> 和 <code class="language-text">s2</code> 所在的 scope 之后，程序则会试图将这两个「值」的内存空间全部释放，而此时 <code class="language-text">s1</code> 和 <code class="language-text">s2</code> 指向同一块地址空间，<strong>这种情况下就会出现 double free 异常的情况</strong>。</p>
<blockquote>
<p>Freeing memory twice can lead to memory corruption, which can potentially lead to security vulnerabilities.</p>
</blockquote>
<p>而我们 Rust 就通过「所有权」规避了这一问题，如下图所示，Rust 在上述过程中，实际上是将 <code class="language-text">s1</code> 的值移动到了 <code class="language-text">s2</code> 上，在 <code class="language-text">s2</code> 的指针指向对应的内存空间时，Rust 会认为 <code class="language-text">s1</code> 此时已经无用了，从而直接 invalidate 掉 <code class="language-text">s1</code>，那么当我们程序离开当前 scope 后，valid 的「值」只有 <code class="language-text">s2</code>，Rust 就只会将 <code class="language-text">s2</code> 释放，从而避免出现 double free 异常的情况。</p>
<figure><img src="https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215236-7.png" alt="Rust 中 s1 move 给 s2 之后，s1 被认为 invalid"><figcaption>Rust 中 s1 move 给 s2 之后，s1 被认为 invalid</figcaption></figure>
<p>不过，如果我们此时一定要访问 <code class="language-text">s1</code> 的内容怎么办？Rust 有一个专门的方法，让 <code class="language-text">s2</code> 创建时，不 move 而是深度拷贝 <code class="language-text">s1</code> 的全部内容，如下图所示：</p>
<figure><img src="https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215236-8.png" alt="Rust 中将 s1 deep copy 给 s2"><figcaption>Rust 中将 s1 deep copy 给 s2</figcaption></figure>
<p>这里 Rust 所做的事情类似于其他语言中的 deep copy —— 花费更大的开销，将 <code class="language-text">s1</code> 字符串对应的「堆」复制一个，再分配内存空间存储复制出来的 <code class="language-text">s1</code> 并将之赋给 <code class="language-text">s2</code>。在 Rust 中我们可以用 <code class="language-text">&lt;VARIABLE&gt;.clone()</code> 来表示这一功能：</p>
<pre class="language-rust"><code class="language-rust"><span class="token keyword">fn</span> <span class="token function-definition function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token class-name">String</span><span class="token punctuation">::</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token macro property">println!</span><span class="token punctuation">(</span><span class="token string">"s1 = {}, s2 = {}"</span><span class="token punctuation">,</span> s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
<p>上面的代码就不会出现类似的错误了。Rust 语言<strong>对「动态」数据结构</strong>都有类似的功能安排：利用 Ownership 的设计思想，在没有垃圾回收的基础之上，避免内存错误。</p>
<h2 id="小结"><a href="#%E5%B0%8F%E7%BB%93" aria-hidden="true"><span class="icon icon-link"></span></a>小结</h2>
<p>Rust 的确是一门神奇的语言，不仅拥有 C、C++ 等系统级别语言的高效迅速，还利用 Ownership 的设计思想保证了内存安全。上面仅仅是 Rust 语言中一个小小的独特之处，由于这一特性所保证的功能我在其他语言中也有过类似的体验（比如 Python 的 deep copy 与 shallow copy<sup id="fnref-5"><a href="#fn-5" class="footnote-ref">5</a></sup>），因此拿来和大家分享。Rust 还有更多有趣的设计与内容等待大家发掘。感谢阅读。</p>
<div class="footnotes">
<hr>
<ol>
<li id="fn-1">
<p><a href="https://stackoverflow.blog/2020/01/20/what-is-rust-and-why-is-it-so-popular/" target="_blank" rel="nofollow noopener noreferrer">What is Rust and why is it so popular? - Stack Overflow Blog</a></p>
<a href="#fnref-1" class="footnote-backref">↩</a>
</li>
<li id="fn-2">
<p><a href="https://www.reddit.com/r/rust/comments/5lg3ih/what_do_rusts_buzzwords_like_safe_and_zerocost/" target="_blank" rel="nofollow noopener noreferrer">What do Rust's buzzwords like "safe" and "zero-cost abstraction" mean?</a></p>
<a href="#fnref-2" class="footnote-backref">↩</a>
</li>
<li id="fn-3">
<p><a href="https://medium.com/@thomascountz/ownership-in-rust-part-1-112036b1126b" target="_blank" rel="nofollow noopener noreferrer">Ownership in Rust, Part 1 - Medium</a></p>
<a href="#fnref-3" class="footnote-backref">↩</a>
</li>
<li id="fn-4">
<p><a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html" target="_blank" rel="nofollow noopener noreferrer">The Rust Programming Language - Understanding Ownership</a></p>
<a href="#fnref-4" class="footnote-backref">↩</a>
</li>
<li id="fn-5">
<p><a href="https://www.geeksforgeeks.org/copy-python-deep-copy-shallow-copy/" target="_blank" rel="nofollow noopener noreferrer">copy in Python (Deep Copy and Shallow Copy) - GeeksforGeeks</a></p>
<a href="#fnref-5" class="footnote-backref">↩</a>
</li>
</ol>
</div>
</div><div class="post__footer"><div class="post-tags"><a href="/tag/Tech/" class="post-tags__link"><span>#</span> Tech
  </a><a href="/tag/Rust/" class="post-tags__link"><span>#</span> Rust
  </a><a href="/tag/CLI/" class="post-tags__link"><span>#</span> CLI
  </a></div></div><div class="post__navigation"><a href="/2020/02/dont-use-anaconda/" class="navlink" style="float: left;">◀ 别用 Anaconda：如何搭建一个 decent 的机器学习开发环境？</a><a href="/2019/12/bitweb-auto-login/" class="navlink" style="float: right;">BIT-Web Automation：如何利用 iOS 快捷指令自动化登录 BIT-Web 校园网 ▶</a></div></div><div class="post-comments"><div id="disqus_thread"></div></div><!----><div class="author post-author"><img alt="Author image" src="data:image/svg+xml,%3csvg fill='none' viewBox='0 0 180 180' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-c3c0558b010e14207322c3bce7e52ad2'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='5'/%3e%3c/filter%3e%3c/defs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-c3c0558b010e14207322c3bce7e52ad2)' width='180' height='180' xlink:href='data:image/jpeg%3bbase64%2c/9j/2wBDAAYEBQYFBAYGBQYHBwYIChAKCgkJChQODwwQFxQYGBcUFhYaHSUfGhsjHBYWICwgIyYnKSopGR8tMC0oMCUoKSj/2wBDAQcHBwoIChMKChMoGhYaKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCj/wAARCABAAEADASIAAhEBAxEB/8QAHAAAAgIDAQEAAAAAAAAAAAAAAAUGCAEDBwQJ/8QANxAAAQMEAQIDAwkJAQAAAAAAAQIDBAAFBhEhEjEHE0EiUWEUFSQyUnGBkaEjJkJDYmR0gtHB/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhEDEQA/ALU0UVHsmvUqPKj2mxstSL1KSVpDu/LjtA6LzmuekHgJHKjwNDZAPJMlmKyp6S82y0nlS3FBKR95PFIF5zjCXC2L5AWod/LdCx%2badisRcPty3G5N7Cr1cE8%2bfOAWEn%2bhv6iB9w37ye9SNttDaAhtIQgcBKRoCgTwcrsE9xLcS829x1R0GxISFn/UndOq8lwtkC5N%2bXcIUaUj7L7SVj9RUcexqXZfpOHyVMdPKrXJcUqK6PUJ3ssn3FPs%2b9JoJdRSrHb2xe4SnmkOMPsrLMiM8NOMODuhQ/EEEcEEEbBprQBrgd7g3C8nIr4zfLtGfuFtmzYTMN/5OEfJl%2bWyOpPtLHSeopJ1tZ49a74a5xi1mdn%2bHmPPQVNfOdvSvyi6PYc2pSHWl%2bvSobG/QgHnWqCkB8R81PfK75v/ADnP%2b1hPiHmi1BKcpvqlHgATXOT%2bdO/EfwxyCxZTNZt%2bOXk25bhVH%2bjKc6QeejqRtKtdtg863x2qfeA/gRfLlkUG95bBct1oiOpeTHkDpdkqSdpHR3Snetk632HfYDo%2beWOdj2EXx1q95ALxHsUac04u6PnodSvT5A6teqeOw3xqqvHxEzIk/vVfOf75z/tX6zuxN5RbZEa3yY3zmw040pC17Stt1BStpwDkJUPXuClJG9aNDL34Y5pZ7muDLxm6l0K6UqZjqdQvnulaQQaBx4ZZnlsjxIsTbeQXVbk6fFZkdUlavOQFgdK9n2gASOfQ19Caph4TeEORY3fMfyrJGTbkt3WK0xDc0XXOtfSVKH8AAPY8n3Crn0BUOxN8WS/XLGZaujrdcuFtKuA6w4oqcQn4tuKUCPsqQamNJsox6JkMJtqSp1iSwvzYsthXS9GcHZaFeh9CDwQSCCDQOaKQYPcJlzx1p%2b4uMPPpddZ%2bUMpKEvpQ4pAcCT9XqCd62e/HFP6Dzw4MSEp5UOKwwp9ZcdLTYSXFnupWu5%2bJr0UVCpeRXu83Wfa8UtzTbUN4xpN2nq/ZNuAAlLbST1OEBQ7lKd%2bpoDLnk3bLsdsEY9TkeQm7zCn%2bSy1sNg/FbhGvghR9KmtJMWx2PYI8gpdelz5bnnTJsgguyHNa2dcAAcJSNBI4Ap3QFL8hmKt9huU1H1o0Z14felBP/lMK1yWGpUZ2PJbS6w6goWhY2FJI0QR7tUCzD4fzfitoi60WojSVfFXQNn8903rCEhCAlIASBoAegrNAHtUYw72bvlrYACRdeofjGYJ/WpPWmPFYjOSFsMobXIX5rqkjRWrQTs%2b86SB%2bFBuooooP/9k=' /%3e%3c/svg%3e" width="180" data-src="/assets/static/author.e6b6009.39e7de96836586e14662ec7a3092de84.jpg" data-srcset="/assets/static/author.e6b6009.39e7de96836586e14662ec7a3092de84.jpg 180w" data-sizes="(max-width: 180px) 100vw, 180px" class="author__image g-image g-image--lazy g-image--loading"><noscript><img src="/assets/static/author.e6b6009.39e7de96836586e14662ec7a3092de84.jpg" class="author__image g-image g-image--loaded" width="180" alt="Author image"></noscript><!----><p class="author__intro">
    阿巴阿巴 o((&gt;ω&lt; ))o
  </p><p class="author__links"><a href="//spencerwoo.com" target="_blank" rel="noopener"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="id-badge" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512" class="svg-inline--fa fa-id-badge fa-w-12"><path fill="currentColor" d="M336 0H48C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V48c0-26.5-21.5-48-48-48zM144 32h96c8.8 0 16 7.2 16 16s-7.2 16-16 16h-96c-8.8 0-16-7.2-16-16s7.2-16 16-16zm48 128c35.3 0 64 28.7 64 64s-28.7 64-64 64-64-28.7-64-64 28.7-64 64-64zm112 236.8c0 10.6-10 19.2-22.4 19.2H102.4C90 416 80 407.4 80 396.8v-19.2c0-31.8 30.1-57.6 67.2-57.6h5c12.3 5.1 25.7 8 39.8 8s27.6-2.9 39.8-8h5c37.1 0 67.2 25.8 67.2 57.6v19.2z"></path></svg></a><a href="/feed.xml" aria-current="page" target="_blank" class="active--exact active" style="color:#F5A623;"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="rss" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="svg-inline--fa fa-rss fa-w-14"><path fill="currentColor" d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328 0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765 0 183.105 0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686 0 38.981 0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"></path></svg></a><a href="/archives" style="color:var(--title-color);"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="archive" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="svg-inline--fa fa-archive fa-w-16"><path fill="currentColor" d="M32 448c0 17.7 14.3 32 32 32h384c17.7 0 32-14.3 32-32V160H32v288zm160-212c0-6.6 5.4-12 12-12h104c6.6 0 12 5.4 12 12v8c0 6.6-5.4 12-12 12H204c-6.6 0-12-5.4-12-12v-8zM480 32H32C14.3 32 0 46.3 0 64v48c0 8.8 7.2 16 16 16h480c8.8 0 16-7.2 16-16V64c0-17.7-14.3-32-32-32z"></path></svg></a><a href="/friends" style="color:#06a878;"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="comment-dots" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="svg-inline--fa fa-comment-dots fa-w-16"><path fill="currentColor" d="M256 32C114.6 32 0 125.1 0 240c0 49.6 21.4 95 57 130.7C44.5 421.1 2.7 466 2.2 466.5c-2.2 2.3-2.8 5.7-1.5 8.7S4.8 480 8 480c66.3 0 116-31.8 140.6-51.4 32.7 12.3 69 19.4 107.4 19.4 141.4 0 256-93.1 256-208S397.4 32 256 32zM128 272c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm128 0c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm128 0c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32z"></path></svg></a>/
    <a href="//twitter.com/realSpencerWoo" target="_blank" style="color:#1da1f2;"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="twitter" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="svg-inline--fa fa-twitter fa-w-16"><path fill="currentColor" d="M459.37 151.716c.325 4.548.325 9.097.325 13.645 0 138.72-105.583 298.558-298.558 298.558-59.452 0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055 0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421 0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391 0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04 0-57.828 46.782-104.934 104.934-104.934 30.213 0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"></path></svg></a><a href="//weibo.com/spencerwoo" target="_blank" style="color:#E00;"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="weibo" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="svg-inline--fa fa-weibo fa-w-16"><path fill="currentColor" d="M407 177.6c7.6-24-13.4-46.8-37.4-41.7-22 4.8-28.8-28.1-7.1-32.8 50.1-10.9 92.3 37.1 76.5 84.8-6.8 21.2-38.8 10.8-32-10.3zM214.8 446.7C108.5 446.7 0 395.3 0 310.4c0-44.3 28-95.4 76.3-143.7C176 67 279.5 65.8 249.9 161c-4 13.1 12.3 5.7 12.3 6 79.5-33.6 140.5-16.8 114 51.4-3.7 9.4 1.1 10.9 8.3 13.1 135.7 42.3 34.8 215.2-169.7 215.2zm143.7-146.3c-5.4-55.7-78.5-94-163.4-85.7-84.8 8.6-148.8 60.3-143.4 116s78.5 94 163.4 85.7c84.8-8.6 148.8-60.3 143.4-116zM347.9 35.1c-25.9 5.6-16.8 43.7 8.3 38.3 72.3-15.2 134.8 52.8 111.7 124-7.4 24.2 29.1 37 37.4 12 31.9-99.8-55.1-195.9-157.4-174.3zm-78.5 311c-17.1 38.8-66.8 60-109.1 46.3-40.8-13.1-58-53.4-40.3-89.7 17.7-35.4 63.1-55.4 103.4-45.1 42 10.8 63.1 50.2 46 88.5zm-86.3-30c-12.9-5.4-30 .3-38 12.9-8.3 12.9-4.3 28 8.6 34 13.1 6 30.8.3 39.1-12.9 8-13.1 3.7-28.3-9.7-34zm32.6-13.4c-5.1-1.7-11.4.6-14.3 5.4-2.9 5.1-1.4 10.6 3.7 12.9 5.1 2 11.7-.3 14.6-5.4 2.8-5.2 1.1-10.9-4-12.9z"></path></svg></a><a href="//t.me/realSpencerWoo" target="_blank" style="color:#179cde;"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="telegram" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512" class="svg-inline--fa fa-telegram fa-w-16"><path fill="currentColor" d="M248 8C111 8 0 119 0 256s111 248 248 248 248-111 248-248S385 8 248 8zm121.8 169.9l-40.7 191.8c-3 13.6-11.1 16.9-22.4 10.5l-62-45.7-29.9 28.8c-3.3 3.3-6.1 6.1-12.5 6.1l4.4-63.1 114.9-103.8c5-4.4-1.1-6.9-7.7-2.5l-142 89.4-61.2-19.1c-13.3-4.2-13.6-13.3 2.8-19.7l239.1-92.2c11.1-4 20.8 2.7 17.2 19.5z"></path></svg></a><a href="//github.com/spencerwooo" target="_blank" style="color:var(--title-color);"><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="github" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512" class="svg-inline--fa fa-github fa-w-16"><path fill="currentColor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"></path></svg></a></p></div></div></main><footer class="footer"><div class="footer__copyright">
      Copyright ©2017 - 2024.
    </div><div class="footer__links">
      Runs on <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="rocket" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="svg-inline--fa fa-rocket fa-w-16"><path fill="currentColor" d="M505.12019,19.09375c-1.18945-5.53125-6.65819-11-12.207-12.1875C460.716,0,435.507,0,410.40747,0,307.17523,0,245.26909,55.20312,199.05238,128H94.83772c-16.34763.01562-35.55658,11.875-42.88664,26.48438L2.51562,253.29688A28.4,28.4,0,0,0,0,264a24.00867,24.00867,0,0,0,24.00582,24H127.81618l-22.47457,22.46875c-11.36521,11.36133-12.99607,32.25781,0,45.25L156.24582,406.625c11.15623,11.1875,32.15619,13.15625,45.27726,0l22.47457-22.46875V488a24.00867,24.00867,0,0,0,24.00581,24,28.55934,28.55934,0,0,0,10.707-2.51562l98.72834-49.39063c14.62888-7.29687,26.50776-26.5,26.50776-42.85937V312.79688c72.59753-46.3125,128.03493-108.40626,128.03493-211.09376C512.07526,76.5,512.07526,51.29688,505.12019,19.09375ZM384.04033,168A40,40,0,1,1,424.05,128,40.02322,40.02322,0,0,1,384.04033,168Z"></path></svg><a href="//gridsome.org">Gridsome</a> and
      <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="heart" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="svg-inline--fa fa-heart fa-w-16"><path fill="currentColor" d="M462.3 62.6C407.5 15.9 326 24.3 275.7 76.2L256 96.5l-19.7-20.3C186.1 24.3 104.5 15.9 49.7 62.6c-62.8 53.6-66.1 149.8-9.9 207.9l193.5 199.8c12.5 12.9 32.8 12.9 45.3 0l193.5-199.8c56.3-58.1 53-154.3-9.8-207.9z"></path></svg>Love. Deployed on
      <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="caret-square-up" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="svg-inline--fa fa-caret-square-up fa-w-14"><path fill="currentColor" d="M0 432V80c0-26.51 21.49-48 48-48h352c26.51 0 48 21.49 48 48v352c0 26.51-21.49 48-48 48H48c-26.51 0-48-21.49-48-48zm355.515-140.485l-123.03-123.03c-4.686-4.686-12.284-4.686-16.971 0L92.485 291.515c-7.56 7.56-2.206 20.485 8.485 20.485h246.059c10.691 0 16.045-12.926 8.486-20.485z"></path></svg><a href="//vercel.com/spencerwoo/blog">Vercel</a>.
    </div><div class="footer__links"></div><div class="footer__links">
      Subscriber statistics powered by
      <svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="rss" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="svg-inline--fa fa-rss fa-w-14"><path fill="currentColor" d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328 0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765 0 183.105 0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686 0 38.981 0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"></path></svg><a href="//api.spencerwoo.com/substats">Substats</a>. DO SUBSCRIBE!
    </div><div id="rss-stats"><a href="https://blog.spencerwoo.com/feed.xml"><img src="https://img.shields.io/badge/Subscribe-RSS-ffa500?logo=rss" alt="rss"></a><a href="https://feedly.com/i/subscription/feed%2Fhttps%3A%2F%2Fblog.spencerwoo.com%2Ffeed.xml"><img src="https://img.shields.io/badge/dynamic/json?label=Feedly&query=%24.data.totalSubs&url=https%3A%2F%2Fapi.spencerwoo.com%2Fsubstats%2F%3Fsource%3Dfeedly%26queryKey%3Dhttps%3A%2F%2Fblog.spencerwoo.com%2Fposts%2Findex.xml&labelColor=2bb24c&logoColor=white&color=282c34&logo=feedly&longCache=true" alt="feedly"></a><a href="https://www.inoreader.com/feed/https%3A%2F%2Fblog.spencerwoo.com%2Ffeed.xml"><img src="https://img.shields.io/badge/dynamic/json?label=Inoreader&query=%24.data.totalSubs&url=https%3A%2F%2Fapi.spencerwoo.com%2Fsubstats%2F%3Fsource%3Dinoreader%26queryKey%3Dhttps%3A%2F%2Fblog.spencerwoo.com%2Fposts%2Findex.xml&color=282c34&logo=data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNzIiIGhlaWdodD0iNzIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTM2IDBjMTkuODgyIDAgMzYgMTYuMTE4IDM2IDM2UzU1Ljg4MiA3MiAzNiA3MiAwIDU1Ljg4MiAwIDM2IDE2LjExOCAwIDM2IDB6bS03Ljk5IDMwLjk4QzIwLjgyNSAzMC45OCAxNSAzNi44MDQgMTUgNDMuOTkgMTUgNTEuMTc1IDIwLjgyNSA1NyAyOC4wMSA1N2M3LjE4MyAwIDEzLjAwOS01LjgyNSAxMy4wMDktMTMuMDExIDAtNy4xODUtNS44MjYtMTMuMDA5LTEzLjAwOS0xMy4wMDl6bTMuNjcgNS41NjVhMy43MjcgMy43MjcgMCAxMS0uMDA1IDcuNDU0IDMuNzI3IDMuNzI3IDAgMDEuMDA0LTcuNDU0em0tMy42Ny0xNC43NTh2NC42ODdjOS42NTYgMCAxNy41MTYgNy44NTggMTcuNTE2IDE3LjUxNWg0LjY4OWMwLTEyLjI0Mi05Ljk2MS0yMi4yMDItMjIuMjA1LTIyLjIwMnptMC05Ljc4N3Y0LjY4N2M3LjI5MiAwIDE0LjE0OCAyLjg0IDE5LjMwNiA3Ljk5OCA1LjE1OCA1LjE1NyA3Ljk5NSAxMi4wMTQgNy45OTUgMTkuMzA0SDYwYzAtOC41NDQtMy4zMjgtMTYuNTc3LTkuMzctMjIuNjJDNDQuNTg1IDE1LjMyNiAzNi41NTQgMTIgMjguMDEgMTJ6IiBmaWxsPSIjRkZGIiBmaWxsLXJ1bGU9Im5vbnplcm8iLz48L3N2Zz4=&labelColor=007bc7&longCache=true" alt="inoreader"></a></div></footer></div> <script>window.__INITIAL_STATE__={"data":{"post":{"title":"cwim 背后的故事：Rust 与 Ownership","path":"\u002F2020\u002F01\u002Fcli-app-in-rust\u002F","date":"January 23. 2020","timeToRead":14,"cjkWordCount":3472,"cjkReadTime":16,"tags":[{"id":"Tech","title":"Tech","path":"\u002Ftag\u002FTech\u002F"},{"id":"Rust","title":"Rust","path":"\u002Ftag\u002FRust\u002F"},{"id":"CLI","title":"CLI","path":"\u002Ftag\u002FCLI\u002F"}],"description":"Rust 是如何保证「内存安全」的","published":true,"content":"\u003Cp\u003E前几天 Stack Overflow 博客上面有一篇文章\u003Csup id=\"fnref-1\"\u003E\u003Ca href=\"#fn-1\" class=\"footnote-ref\"\u003E1\u003C\u002Fa\u003E\u003C\u002Fsup\u003E，里面提到了 Rust 已经连续四年位列 Stack Overflow 社区最爱编程语言榜首。的确，Rust 是一门神奇又美丽的语言。Rust 是一门标榜 safe 与 zero-cost abstraction 的语言\u003Csup id=\"fnref-2\"\u003E\u003Ca href=\"#fn-2\" class=\"footnote-ref\"\u003E2\u003C\u002Fa\u003E\u003C\u002Fsup\u003E，意味着只要你编写的 Rust 代码符合官方标准 —— 能够通过编译 —— 那么你的项目几乎可以肯定地说是内存安全的。\u003C\u002Fp\u003E\n\u003Ch2 id=\"初衷\"\u003E\u003Ca href=\"#%E5%88%9D%E8%A1%B7\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E初衷\u003C\u002Fh2\u003E\n\u003Cp\u003E偏向底层的 Rust 让我在之前一直没有机会尝试，毕竟我相信国内高校没有一所是敢直接抛弃 C、C++ 而使用 Rust 作为其主语言进行授课的。最近我重构了 \u003Ca href=\"https:\u002F\u002Fdowww.spencerwoo.com\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003EDev on Windows with WSL\u003C\u002Fa\u003E：一个近 2w 字的 WSL 开发配置文档。我前后用了大概半个月的时间，增加了许多内容，因此我在结束编写工作之后，试图找到一个类似 \u003Ccode class=\"language-text\"\u003Ecloc\u003C\u002Fcode\u003E，能帮我统计一个目录下全部 Markdown 文件的命令行工具。很失望，没找到。\u003C\u002Fp\u003E\n\u003Cp\u003E我决定自己尝试实现这个命令行工具，当然，我也相信 Python、Node.js、Ruby 等脚本语言一定适合做这些事情，毕竟 \u003Ccode class=\"language-text\"\u003Ecloc\u003C\u002Fcode\u003E 本身就是使用 Perl 实现的。不过，Rust 作为一门高效的、静态的、可以直接编译到三个操作系统的底层语言，还是很有吸引力的。因此我才决定使用 Rust 开新坑。\u003C\u002Fp\u003E\n\u003Cfigure\u003E\u003Cimg src=\"https:\u002F\u002Fcdn.spencer.felinae98.cn\u002Fblog\u002F2020\u002F07\u002F20200722-215236.png\" alt=\"使用 Rust 实现的 cwim - Count words in Markdown\"\u003E\u003Cfigcaption\u003E使用 Rust 实现的 cwim - Count words in Markdown\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\n\u003Cp\u003E另外：cwim 的第一个小版本我已经编译并发布 Release 版本，有兴趣的同学可以前往 GitHub 查看：\u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fspencerwooo\u002Fcwim\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Espencerwooo\u002Fcwim\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\n\u003Ch2 id=\"开始一个-rust-项目\"\u003E\u003Ca href=\"#%E5%BC%80%E5%A7%8B%E4%B8%80%E4%B8%AA-rust-%E9%A1%B9%E7%9B%AE\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E开始一个 Rust 项目\u003C\u002Fh2\u003E\n\u003Cp\u003ERust 最 beginner friendly 的地方我觉得在于其\u003Ca href=\"https:\u002F\u002Fwww.rust-lang.org\u002Fzh-CN\u002Flearn\u002Fget-started\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003E官方入门文档\u003C\u002Fa\u003E的简洁易懂。从安装、编译到包管理、打包项目 …… Rust 的官方文档讲解的都比任何其他语言的文档讲解的要易懂不少。我这里简单记录一下 Rust 环境的安装搭建的基本过程。\u003C\u002Fp\u003E\n\u003Ch3 id=\"安装-rust-环境\"\u003E\u003Ca href=\"#%E5%AE%89%E8%A3%85-rust-%E7%8E%AF%E5%A2%83\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E安装 Rust 环境\u003C\u002Fh3\u003E\n\u003Cp\u003ERust 语言虽然小众，但是其生态相当完善。Rust 借鉴了其他语言的多种环境配置工具，官方直接提供了一整套完善的闭环 Toolkit，基本能满足我们在使用 Rust 时的安装、构建、编译、发布的整套流程：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003ERustup：Rust 版本管理（类似 Python 的 \u003Ccode class=\"language-text\"\u003Epyenv\u003C\u002Fcode\u003E、Node.js 的 \u003Ccode class=\"language-text\"\u003Envm\u003C\u002Fcode\u003E 等）\u003C\u002Fli\u003E\n\u003Cli\u003ECargo：Rust 构建工具与包管理（类似 Python 的 \u003Ccode class=\"language-text\"\u003Epip\u003C\u002Fcode\u003E、Node.js 的 \u003Ccode class=\"language-text\"\u003Eyarn\u003C\u002Fcode\u003E 等）\u003C\u002Fli\u003E\n\u003Cli\u003Ecrates.io：Rust 的 Package Registry\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E首先，我们安装 Rustup：Rust 安装器与 Rust 版本控制器。使用 Arch Linux（以及 WSL 的 Arch Linux）的同学可以直接在 AUR 中安装 \u003Ccode class=\"language-text\"\u003Erustup\u003C\u002Fcode\u003E：\u003C\u002Fp\u003E\n\u003Cpre class=\"language-bash\"\u003E\u003Ccode class=\"language-bash\"\u003Eyay rustup\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E如果使用 WSL 其他 Linux 发行版，我们也可以用下面的命令安装 \u003Ccode class=\"language-text\"\u003Erustup\u003C\u002Fcode\u003E：\u003C\u002Fp\u003E\n\u003Cpre class=\"language-bash\"\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"token function\"\u003Ecurl\u003C\u002Fspan\u003E \u003Cspan class=\"token parameter variable\"\u003E--proto\u003C\u002Fspan\u003E \u003Cspan class=\"token string\"\u003E'=https'\u003C\u002Fspan\u003E \u003Cspan class=\"token parameter variable\"\u003E--tlsv1.2\u003C\u002Fspan\u003E \u003Cspan class=\"token parameter variable\"\u003E-sSf\u003C\u002Fspan\u003E https:\u002F\u002Fsh.rustup.rs \u003Cspan class=\"token operator\"\u003E|\u003C\u002Fspan\u003E \u003Cspan class=\"token function\"\u003Esh\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E其他安装方法请参考：\u003Ca href=\"https:\u002F\u002Fwww.rust-lang.org\u002Fzh-CN\u002Ftools\u002Finstall\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003ERust | 安装 Rust\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E安装了 \u003Ccode class=\"language-text\"\u003Erustup\u003C\u002Fcode\u003E 之后，我们就应该已经安装完成了 Cargo：Rust 的构建工具与包管理工具。Cargo 可以做很多事情：\u003C\u002Fp\u003E\n\u003Cpre class=\"language-bash\"\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"token function\"\u003Ecargo\u003C\u002Fspan\u003E build     \u003Cspan class=\"token comment\"\u003E# 可以构建项目\u003C\u002Fspan\u003E\n\u003Cspan class=\"token function\"\u003Ecargo\u003C\u002Fspan\u003E run       \u003Cspan class=\"token comment\"\u003E# 可以运行项目\u003C\u002Fspan\u003E\n\u003Cspan class=\"token function\"\u003Ecargo\u003C\u002Fspan\u003E \u003Cspan class=\"token builtin class-name\"\u003Etest\u003C\u002Fspan\u003E      \u003Cspan class=\"token comment\"\u003E# 可以测试项目\u003C\u002Fspan\u003E\n\u003Cspan class=\"token function\"\u003Ecargo\u003C\u002Fspan\u003E doc       \u003Cspan class=\"token comment\"\u003E# 可以为项目构建文档\u003C\u002Fspan\u003E\n\u003Cspan class=\"token function\"\u003Ecargo\u003C\u002Fspan\u003E publish   \u003Cspan class=\"token comment\"\u003E# 可以将库发布到 crates.io\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E要检查是否安装了 Rust 和 Cargo，可以在终端中运行：\u003C\u002Fp\u003E\n\u003Cpre class=\"language-bash\"\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"token function\"\u003Ecargo\u003C\u002Fspan\u003E \u003Cspan class=\"token parameter variable\"\u003E--version\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E接下来我们就可以使用 Cargo 来创建一个 Rust 项目，并用它来安装我们必须的 Rust 库等内容。\u003C\u002Fp\u003E\n\u003Ch3 id=\"rust--vs-code\"\u003E\u003Ca href=\"#rust--vs-code\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ERust \u002F VS Code\u003C\u002Fh3\u003E\n\u003Cp\u003EVS Code 是一个通用的文本 \u002F 代码编辑器，能够通过插件支持多种语言环境下代码的编写任务。我们下载 Rust 官方提供的 VS Code 插件：\u003Ca href=\"https:\u002F\u002Fmarketplace.visualstudio.com\u002Fitems?itemName=rust-lang.rust\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003EVisual Studio Code Marketplace | Rust (rls)\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cfigure\u003E\u003Cimg src=\"https:\u002F\u002Fcdn.spencer.felinae98.cn\u002Fblog\u002F2020\u002F07\u002F20200722-215236-1.png\" alt=\"Visual Studio Code Marketplace | Rust (rls)\"\u003E\u003Cfigcaption\u003EVisual Studio Code Marketplace | Rust (rls)\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\n\u003Cp\u003E之后，我们用 Cargo 创建一个新的项目 \u003Ccode class=\"language-text\"\u003Ehello-rust\u003C\u002Fcode\u003E：\u003C\u002Fp\u003E\n\u003Cpre class=\"language-bash\"\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"token function\"\u003Ecargo\u003C\u002Fspan\u003E new hello-rust\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E或者在已有文件夹 \u003Ccode class=\"language-text\"\u003Ehello-rust\u003C\u002Fcode\u003E 下，生成新 Rust 项目：\u003C\u002Fp\u003E\n\u003Cpre class=\"language-bash\"\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"token builtin class-name\"\u003Ecd\u003C\u002Fspan\u003E hello-rust\n\u003Cspan class=\"token function\"\u003Ecargo\u003C\u002Fspan\u003E init\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E新的 Rust 项目目录下应该拥有以下内容：\u003C\u002Fp\u003E\n\u003Cpre class=\"language-bash\"\u003E\u003Ccode class=\"language-bash\"\u003Ehello-rust      \u003Cspan class=\"token comment\"\u003E# 根目录\u003C\u002Fspan\u003E\n\u003Cspan class=\"token operator\"\u003E|\u003C\u002Fspan\u003E- Cargo.toml   \u003Cspan class=\"token comment\"\u003E# Rust 的清单文件，其中包含项目的元数据和依赖库\u003C\u002Fspan\u003E\n\u003Cspan class=\"token operator\"\u003E|\u003C\u002Fspan\u003E- src\n  \u003Cspan class=\"token operator\"\u003E|\u003C\u002Fspan\u003E- main.rs    \u003Cspan class=\"token comment\"\u003E# 主程序入口\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E用 VS Code 打开这一目录，我们即可开始 Rust 项目的编写。\u003C\u002Fp\u003E\n\u003Cfigure\u003E\u003Cimg src=\"https:\u002F\u002Fcdn.spencer.felinae98.cn\u002Fblog\u002F2020\u002F07\u002F20200722-215236-2.png\" alt=\"使用 VS Code 撰写 Rust 项目\"\u003E\u003Cfigcaption\u003E使用 VS Code 撰写 Rust 项目\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\n\u003Cp\u003E使用下面命令即可运行项目：\u003C\u002Fp\u003E\n\u003Cpre class=\"language-bash\"\u003E\u003Ccode class=\"language-bash\"\u003E\u003Cspan class=\"token function\"\u003Ecargo\u003C\u002Fspan\u003E run\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2 id=\"rust-语言特性\"\u003E\u003Ca href=\"#rust-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003ERust 语言特性\u003C\u002Fh2\u003E\n\u003Cp\u003E在用 Rust 编写 \u003Ccode class=\"language-text\"\u003Ecwim\u003C\u002Fcode\u003E 的时候，有两个令我印象深刻的地方：一个是 Rust 语言实际上非常清晰易懂，有 C、C++ 等强类型语言的严谨，也有脚本语言的易读；另一个就是 Rust 编译器非常严格，但给我们的问题提示也非常清晰，方便追溯问题所在，容易 debug。严苛的 Rust 编译器让我们必须考虑「内存分配」，也正因如此，使得 \u003Cstrong\u003ERust 在并未实现「垃圾回收」的前提下，确保了任何 Rust 程序都生来具有「内存安全」特性。\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003E🧲 \u003Cstrong\u003ERust Playground\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E下面涉及到的代码内容可以在 Rust 在线 Playground 中自己尝试。链接位于：\u003Ca href=\"https:\u002F\u002Fplay.rust-lang.org\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003ERust Playground\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Ch3 id=\"ownership\"\u003E\u003Ca href=\"#ownership\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003EOwnership\u003C\u002Fh3\u003E\n\u003Cp\u003ERust 的 Ownership（所有权）是保证 Rust 程序「内存安全」的重点特性。什么是「内存安全」？保证「内存安全」就是指或语言本身，或使用语言的开发者，在其程序运行时管理系统的「内存分配」的过程中保证内存没有浪费、没有泄露。我们一般的程序都需要实施「静态」与「动态」两种形式的内存分配，其中前者指已知变量所需空间，直接在内存中划分一部分不变的区域给变量；后者为在程序运行过程中动态地给变量分配内存空间，使得变量能够在程序运行时变化地占用内存大小。\u003C\u002Fp\u003E\n\u003Ch3 id=\"数据存储方式\"\u003E\u003Ca href=\"#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E数据存储方式\u003C\u002Fh3\u003E\n\u003Cp\u003ERust 是使用「栈」和「堆」这两种数据结构来对这两种内存分配形式进行划分的。为了更好的理解 Rust 的 Ownership 的工作机制，我们首先看看 Rust 是如何利用「栈」和「堆」进行内存分配。\u003C\u002Fp\u003E\n\u003Cfigure\u003E\u003Cimg src=\"https:\u002F\u002Fcdn.spencer.felinae98.cn\u002Fblog\u002F2020\u002F07\u002F20200722-215236-3.png\" alt=\"使用「栈」和「堆」进行内存分配\"\u003E\u003Cfigcaption\u003E使用「栈」和「堆」进行内存分配\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\n\u003Cp\u003E首先，「栈」从实现上来说是一种效率非常高的数据结构，因为「栈」拥有「后进先出」的数据存储特点（LIFO），使得最后压入栈顶的元素会被最先从栈顶移出。这种数据结构的优势在于：当我们用「栈」来维护内存数据时，\u003Cstrong\u003E我们只需要维护「栈顶」元素的信息即可\u003C\u002Fstrong\u003E。同时，Rust 内存管理的「栈」在编译时即可知道其具体大小，静态分配内存空间即可\u003Csup id=\"fnref-3\"\u003E\u003Ca href=\"#fn-3\" class=\"footnote-ref\"\u003E3\u003C\u002Fa\u003E\u003C\u002Fsup\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003E而 Rust 的「堆」则不一样，「堆」是一个动态分配内存空间的数据结构。当我们使用「堆」分配内存空间时，我们实际上是在「堆」上寻找对应的内存地址，将之标记，并返回与之相对映的指针。这一过程跟我们 C、C++ 中的 allocate memory 的原理是一致的。\u003C\u002Fp\u003E\n\u003Ch3 id=\"所有权如何保证内存安全\"\u003E\u003Ca href=\"#%E6%89%80%E6%9C%89%E6%9D%83%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E所有权如何保证内存安全\u003C\u002Fh3\u003E\n\u003Cp\u003E为什么 Rust 需要引入「所有权」的机制？因为 Rust 保证「内存安全」的方法是：追踪第二种「堆」结构中哪部分数据被哪部分代码使用，从而尽量减少「堆」中的重复数据，保证「堆」中不出现有未使用的数据等问题。\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003EKeeping track of what parts of code are using what data on the heap, minimizing the amount of duplicate data on the heap, and cleaning up unused data on the heap so you don’t run out of space are all problems that ownership addresses. —— \u003Ca href=\"https:\u002F\u002Fdoc.rust-lang.org\u002Fbook\u002Fch04-01-what-is-ownership.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003EThe Rust Book\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003ERust 正是使用基于「所有权」理念的一系列规定来保证 Rust 程序的「内存安全」。这其中的机制包括：\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003ERust 中的每个「值」都有一个被叫做 owner 的变量（所有者）\u003C\u002Fli\u003E\n\u003Cli\u003E同一时间只能有一个 owner\u003C\u002Fli\u003E\n\u003Cli\u003E当 owner 离开我们程序段的 scope 之后，这一「值」就会被释放掉\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E我们来看下面的几个例子，来具体看看 Rust 如何保证「内存安全」的。\u003C\u002Fp\u003E\n\u003Cp\u003E我们以 Rust 中字符串（String Literal）为例子，Rust 中字符串有 \u003Ccode class=\"language-text\"\u003E&amp;str\u003C\u002Fcode\u003E 的静态字符串变量，以及 \u003Ccode class=\"language-text\"\u003EString\u003C\u002Fcode\u003E 的动态字符串变量。我们来看看 Rust 是如何分别利用「栈」来存储 \u003Ccode class=\"language-text\"\u003E&amp;str\u003C\u002Fcode\u003E、用「堆」来存储 \u003Ccode class=\"language-text\"\u003EString\u003C\u002Fcode\u003E 的。\u003C\u002Fp\u003E\n\u003Cp\u003E首先来看一个 \u003Ccode class=\"language-text\"\u003E&amp;str\u003C\u002Fcode\u003E 的例子：\u003C\u002Fp\u003E\n\u003Cpre class=\"language-rust\"\u003E\u003Ccode class=\"language-rust\"\u003E\u003Cspan class=\"token keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"token function-definition function\"\u003Emain\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E \u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token comment\"\u003E\u002F\u002F &amp;str 用「栈」存储\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token keyword\"\u003Elet\u003C\u002Fspan\u003E s1 \u003Cspan class=\"token operator\"\u003E=\u003C\u002Fspan\u003E \u003Cspan class=\"token string\"\u003E\"Hello\"\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E;\u003C\u002Fspan\u003E    \u003Cspan class=\"token comment\"\u003E\u002F\u002F 字符串 \"Hello\" 赋值给变量 s1\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token keyword\"\u003Elet\u003C\u002Fspan\u003E s2 \u003Cspan class=\"token operator\"\u003E=\u003C\u002Fspan\u003E s1\u003Cspan class=\"token punctuation\"\u003E;\u003C\u002Fspan\u003E         \u003Cspan class=\"token comment\"\u003E\u002F\u002F 将变量 s1 复制并赋值给 s2\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token macro property\"\u003Eprintln!\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token string\"\u003E\"{}\"\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E,\u003C\u002Fspan\u003E s1\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E;\u003C\u002Fspan\u003E  \u003Cspan class=\"token comment\"\u003E\u002F\u002F 这样做没有问题！\u003C\u002Fspan\u003E\n\u003Cspan class=\"token punctuation\"\u003E}\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E可以发现，当我们直接使用 \u003Ccode class=\"language-text\"\u003E&amp;str\u003C\u002Fcode\u003E 存储字符串时，Rust 是将前一个变量 \u003Ccode class=\"language-text\"\u003Es1\u003C\u002Fcode\u003E 的值\u003Cstrong\u003E直接复制\u003C\u002Fstrong\u003E给后一个变量 \u003Ccode class=\"language-text\"\u003Es2\u003C\u002Fcode\u003E，前一个变量 \u003Ccode class=\"language-text\"\u003Es1\u003C\u002Fcode\u003E 并没有变化。此时我们访问前一个变量 \u003Ccode class=\"language-text\"\u003Es1\u003C\u002Fcode\u003E 没有任何问题。\u003C\u002Fp\u003E\n\u003Cp\u003E接下来，我们来看一个 \u003Ccode class=\"language-text\"\u003EString\u003C\u002Fcode\u003E 的例子：\u003C\u002Fp\u003E\n\u003Cpre class=\"language-rust\"\u003E\u003Ccode class=\"language-rust\"\u003E\u003Cspan class=\"token keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"token function-definition function\"\u003Emain\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E \u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token comment\"\u003E\u002F\u002F String 用「堆」存储\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token keyword\"\u003Elet\u003C\u002Fspan\u003E s1 \u003Cspan class=\"token operator\"\u003E=\u003C\u002Fspan\u003E \u003Cspan class=\"token class-name\"\u003EString\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E::\u003C\u002Fspan\u003E\u003Cspan class=\"token function\"\u003Efrom\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token string\"\u003E\"Hello again\"\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E;\u003C\u002Fspan\u003E \u003Cspan class=\"token comment\"\u003E\u002F\u002F String 变量 \"Hello again\" 赋值给 s1\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token keyword\"\u003Elet\u003C\u002Fspan\u003E s2 \u003Cspan class=\"token operator\"\u003E=\u003C\u002Fspan\u003E foo\u003Cspan class=\"token punctuation\"\u003E;\u003C\u002Fspan\u003E                         \u003Cspan class=\"token comment\"\u003E\u002F\u002F 将 s1 变量中的内容「移动」到 s2 中\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token macro property\"\u003Eprintln!\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token string\"\u003E\"{}, {}\"\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E,\u003C\u002Fspan\u003E s1\u003Cspan class=\"token punctuation\"\u003E,\u003C\u002Fspan\u003E s2\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E;\u003C\u002Fspan\u003E           \u003Cspan class=\"token comment\"\u003E\u002F\u002F 出错了！s1 中内容被 moved，无法被 reference\u003C\u002Fspan\u003E\n\u003Cspan class=\"token punctuation\"\u003E}\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E此时，编译器会报出 \u003Ccode class=\"language-text\"\u003Eerror[E0382]: borrow of moved value: &#39;s1&#39;\u003C\u002Fcode\u003E 的错误。可以发现，当我们使用 String 存储字符串时，Rust 不会将变量的值「复制」，而是会将变量「移动」到目标变量中。这种情况下，Rust 会认为前一个变量 \u003Ccode class=\"language-text\"\u003Es1\u003C\u002Fcode\u003E 已经不再有效（no longer valid），因此，当我们在之后试图访问 \u003Ccode class=\"language-text\"\u003Es1\u003C\u002Fcode\u003E 时，Rust 就会报出这一错误。\u003C\u002Fp\u003E\n\u003Cfigure\u003E\u003Cimg src=\"https:\u002F\u002Fcdn.spencer.felinae98.cn\u002Fblog\u002F2020\u002F07\u002F20200722-215236-4.png\" alt=\"error[E0382] 报错\"\u003E\u003Cfigcaption\u003Eerror[E0382] 报错\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\n\u003Cp\u003E为什么 Rust 在使用「堆」进行动态内存分配时，会 move 而不 copy 呢？一方面是因为 copy 的消耗是比 move 大得多的；另一方面，Rust 这一设计恰好帮助我们避免了 C 语言中非常可能遇到的一种内存泄露的问题：\u003Cstrong\u003Edouble free 异常\u003C\u002Fstrong\u003E\u003Csup id=\"fnref-4\"\u003E\u003Ca href=\"#fn-4\" class=\"footnote-ref\"\u003E4\u003C\u002Fa\u003E\u003C\u002Fsup\u003E。\u003C\u002Fp\u003E\n\u003Cp\u003EDouble free 异常是如何发生的？当我们使用 \u003Ccode class=\"language-text\"\u003EString\u003C\u002Fcode\u003E 类型来存储字符串时，我们实际上存储了以下三个 field 的值：\u003Ccode class=\"language-text\"\u003Eptr\u003C\u002Fcode\u003E、\u003Ccode class=\"language-text\"\u003Elen\u003C\u002Fcode\u003E、\u003Ccode class=\"language-text\"\u003Ecapacity\u003C\u002Fcode\u003E。\u003Ccode class=\"language-text\"\u003Eptr\u003C\u002Fcode\u003E 指向存储字符串内容的内存空间。比如 \u003Ccode class=\"language-text\"\u003Elet s1 = String::from(&quot;Hello&quot;);\u003C\u002Fcode\u003E 即声明了如下的存储方式：\u003C\u002Fp\u003E\n\u003Cfigure\u003E\u003Cimg src=\"https:\u002F\u002Fcdn.spencer.felinae98.cn\u002Fblog\u002F2020\u002F07\u002F20200722-215236-5.png\" alt=\"String 的存储方式\"\u003E\u003Cfigcaption\u003EString 的存储方式\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\n\u003Cp\u003E我们如果使用 \u003Ccode class=\"language-text\"\u003Ecopy\u003C\u002Fcode\u003E 将 String \u003Ccode class=\"language-text\"\u003Es1\u003C\u002Fcode\u003E 复制给 \u003Ccode class=\"language-text\"\u003Es2\u003C\u002Fcode\u003E，我们实际上就将三个 field 的值 \u003Ccode class=\"language-text\"\u003Eptr\u003C\u002Fcode\u003E、\u003Ccode class=\"language-text\"\u003Elen\u003C\u002Fcode\u003E 和 \u003Ccode class=\"language-text\"\u003Ecapacity\u003C\u002Fcode\u003E 全部复制，也就是我们的 \u003Ccode class=\"language-text\"\u003Eptr\u003C\u002Fcode\u003E 指针实际上指向上一块地址空间，如下图所示：\u003C\u002Fp\u003E\n\u003Cfigure\u003E\u003Cimg src=\"https:\u002F\u002Fcdn.spencer.felinae98.cn\u002Fblog\u002F2020\u002F07\u002F20200722-215236-6.png\" alt=\"使用 copy 将 s1 复制给 s2\"\u003E\u003Cfigcaption\u003E使用 copy 将 s1 复制给 s2\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\n\u003Cp\u003E前面我们提到了，\u003Cem\u003E对于一个「值」来说，当程序离开「值」的 owner 所在的 scope 之后，这一「值」就会被释放掉\u003C\u002Fem\u003E，那么当我们离开 \u003Ccode class=\"language-text\"\u003Es1\u003C\u002Fcode\u003E 和 \u003Ccode class=\"language-text\"\u003Es2\u003C\u002Fcode\u003E 所在的 scope 之后，程序则会试图将这两个「值」的内存空间全部释放，而此时 \u003Ccode class=\"language-text\"\u003Es1\u003C\u002Fcode\u003E 和 \u003Ccode class=\"language-text\"\u003Es2\u003C\u002Fcode\u003E 指向同一块地址空间，\u003Cstrong\u003E这种情况下就会出现 double free 异常的情况\u003C\u002Fstrong\u003E。\u003C\u002Fp\u003E\n\u003Cblockquote\u003E\n\u003Cp\u003EFreeing memory twice can lead to memory corruption, which can potentially lead to security vulnerabilities.\u003C\u002Fp\u003E\n\u003C\u002Fblockquote\u003E\n\u003Cp\u003E而我们 Rust 就通过「所有权」规避了这一问题，如下图所示，Rust 在上述过程中，实际上是将 \u003Ccode class=\"language-text\"\u003Es1\u003C\u002Fcode\u003E 的值移动到了 \u003Ccode class=\"language-text\"\u003Es2\u003C\u002Fcode\u003E 上，在 \u003Ccode class=\"language-text\"\u003Es2\u003C\u002Fcode\u003E 的指针指向对应的内存空间时，Rust 会认为 \u003Ccode class=\"language-text\"\u003Es1\u003C\u002Fcode\u003E 此时已经无用了，从而直接 invalidate 掉 \u003Ccode class=\"language-text\"\u003Es1\u003C\u002Fcode\u003E，那么当我们程序离开当前 scope 后，valid 的「值」只有 \u003Ccode class=\"language-text\"\u003Es2\u003C\u002Fcode\u003E，Rust 就只会将 \u003Ccode class=\"language-text\"\u003Es2\u003C\u002Fcode\u003E 释放，从而避免出现 double free 异常的情况。\u003C\u002Fp\u003E\n\u003Cfigure\u003E\u003Cimg src=\"https:\u002F\u002Fcdn.spencer.felinae98.cn\u002Fblog\u002F2020\u002F07\u002F20200722-215236-7.png\" alt=\"Rust 中 s1 move 给 s2 之后，s1 被认为 invalid\"\u003E\u003Cfigcaption\u003ERust 中 s1 move 给 s2 之后，s1 被认为 invalid\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\n\u003Cp\u003E不过，如果我们此时一定要访问 \u003Ccode class=\"language-text\"\u003Es1\u003C\u002Fcode\u003E 的内容怎么办？Rust 有一个专门的方法，让 \u003Ccode class=\"language-text\"\u003Es2\u003C\u002Fcode\u003E 创建时，不 move 而是深度拷贝 \u003Ccode class=\"language-text\"\u003Es1\u003C\u002Fcode\u003E 的全部内容，如下图所示：\u003C\u002Fp\u003E\n\u003Cfigure\u003E\u003Cimg src=\"https:\u002F\u002Fcdn.spencer.felinae98.cn\u002Fblog\u002F2020\u002F07\u002F20200722-215236-8.png\" alt=\"Rust 中将 s1 deep copy 给 s2\"\u003E\u003Cfigcaption\u003ERust 中将 s1 deep copy 给 s2\u003C\u002Ffigcaption\u003E\u003C\u002Ffigure\u003E\n\u003Cp\u003E这里 Rust 所做的事情类似于其他语言中的 deep copy —— 花费更大的开销，将 \u003Ccode class=\"language-text\"\u003Es1\u003C\u002Fcode\u003E 字符串对应的「堆」复制一个，再分配内存空间存储复制出来的 \u003Ccode class=\"language-text\"\u003Es1\u003C\u002Fcode\u003E 并将之赋给 \u003Ccode class=\"language-text\"\u003Es2\u003C\u002Fcode\u003E。在 Rust 中我们可以用 \u003Ccode class=\"language-text\"\u003E&lt;VARIABLE&gt;.clone()\u003C\u002Fcode\u003E 来表示这一功能：\u003C\u002Fp\u003E\n\u003Cpre class=\"language-rust\"\u003E\u003Ccode class=\"language-rust\"\u003E\u003Cspan class=\"token keyword\"\u003Efn\u003C\u002Fspan\u003E \u003Cspan class=\"token function-definition function\"\u003Emain\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E \u003Cspan class=\"token punctuation\"\u003E{\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token keyword\"\u003Elet\u003C\u002Fspan\u003E s1 \u003Cspan class=\"token operator\"\u003E=\u003C\u002Fspan\u003E \u003Cspan class=\"token class-name\"\u003EString\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E::\u003C\u002Fspan\u003E\u003Cspan class=\"token function\"\u003Efrom\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token string\"\u003E\"hello\"\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E;\u003C\u002Fspan\u003E\n  \u003Cspan class=\"token keyword\"\u003Elet\u003C\u002Fspan\u003E s2 \u003Cspan class=\"token operator\"\u003E=\u003C\u002Fspan\u003E s1\u003Cspan class=\"token punctuation\"\u003E.\u003C\u002Fspan\u003E\u003Cspan class=\"token function\"\u003Eclone\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E;\u003C\u002Fspan\u003E\n\n  \u003Cspan class=\"token macro property\"\u003Eprintln!\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E(\u003C\u002Fspan\u003E\u003Cspan class=\"token string\"\u003E\"s1 = {}, s2 = {}\"\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E,\u003C\u002Fspan\u003E s1\u003Cspan class=\"token punctuation\"\u003E,\u003C\u002Fspan\u003E s2\u003Cspan class=\"token punctuation\"\u003E)\u003C\u002Fspan\u003E\u003Cspan class=\"token punctuation\"\u003E;\u003C\u002Fspan\u003E\n\u003Cspan class=\"token punctuation\"\u003E}\u003C\u002Fspan\u003E\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003E上面的代码就不会出现类似的错误了。Rust 语言\u003Cstrong\u003E对「动态」数据结构\u003C\u002Fstrong\u003E都有类似的功能安排：利用 Ownership 的设计思想，在没有垃圾回收的基础之上，避免内存错误。\u003C\u002Fp\u003E\n\u003Ch2 id=\"小结\"\u003E\u003Ca href=\"#%E5%B0%8F%E7%BB%93\" aria-hidden=\"true\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E小结\u003C\u002Fh2\u003E\n\u003Cp\u003ERust 的确是一门神奇的语言，不仅拥有 C、C++ 等系统级别语言的高效迅速，还利用 Ownership 的设计思想保证了内存安全。上面仅仅是 Rust 语言中一个小小的独特之处，由于这一特性所保证的功能我在其他语言中也有过类似的体验（比如 Python 的 deep copy 与 shallow copy\u003Csup id=\"fnref-5\"\u003E\u003Ca href=\"#fn-5\" class=\"footnote-ref\"\u003E5\u003C\u002Fa\u003E\u003C\u002Fsup\u003E），因此拿来和大家分享。Rust 还有更多有趣的设计与内容等待大家发掘。感谢阅读。\u003C\u002Fp\u003E\n\u003Cdiv class=\"footnotes\"\u003E\n\u003Chr\u003E\n\u003Col\u003E\n\u003Cli id=\"fn-1\"\u003E\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fstackoverflow.blog\u002F2020\u002F01\u002F20\u002Fwhat-is-rust-and-why-is-it-so-popular\u002F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003EWhat is Rust and why is it so popular? - Stack Overflow Blog\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Ca href=\"#fnref-1\" class=\"footnote-backref\"\u003E↩\u003C\u002Fa\u003E\n\u003C\u002Fli\u003E\n\u003Cli id=\"fn-2\"\u003E\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fwww.reddit.com\u002Fr\u002Frust\u002Fcomments\u002F5lg3ih\u002Fwhat_do_rusts_buzzwords_like_safe_and_zerocost\u002F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003EWhat do Rust's buzzwords like \"safe\" and \"zero-cost abstraction\" mean?\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Ca href=\"#fnref-2\" class=\"footnote-backref\"\u003E↩\u003C\u002Fa\u003E\n\u003C\u002Fli\u003E\n\u003Cli id=\"fn-3\"\u003E\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fmedium.com\u002F@thomascountz\u002Fownership-in-rust-part-1-112036b1126b\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003EOwnership in Rust, Part 1 - Medium\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Ca href=\"#fnref-3\" class=\"footnote-backref\"\u003E↩\u003C\u002Fa\u003E\n\u003C\u002Fli\u003E\n\u003Cli id=\"fn-4\"\u003E\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fdoc.rust-lang.org\u002Fbook\u002Fch04-01-what-is-ownership.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003EThe Rust Programming Language - Understanding Ownership\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Ca href=\"#fnref-4\" class=\"footnote-backref\"\u003E↩\u003C\u002Fa\u003E\n\u003C\u002Fli\u003E\n\u003Cli id=\"fn-5\"\u003E\n\u003Cp\u003E\u003Ca href=\"https:\u002F\u002Fwww.geeksforgeeks.org\u002Fcopy-python-deep-copy-shallow-copy\u002F\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"\u003Ecopy in Python (Deep Copy and Shallow Copy) - GeeksforGeeks\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Ca href=\"#fnref-5\" class=\"footnote-backref\"\u003E↩\u003C\u002Fa\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Fol\u003E\n\u003C\u002Fdiv\u003E\n","cover_image":{"type":"image","mimeType":"image\u002Fpng","src":"\u002Fassets\u002Fstatic\u002Fcli-app-in-rust.a209973.3e7fdea529882665eabb3f6b560413e1.png","size":{"width":1280,"height":400},"sizes":"(max-width: 1280px) 100vw, 1280px","srcset":["\u002Fassets\u002Fstatic\u002Fcli-app-in-rust.a67b0b2.3e7fdea529882665eabb3f6b560413e1.png 480w","\u002Fassets\u002Fstatic\u002Fcli-app-in-rust.a209973.3e7fdea529882665eabb3f6b560413e1.png 1280w"],"dataUri":"data:image\u002Fsvg+xml,%3csvg fill='none' viewBox='0 0 1280 400' xmlns='http:\u002F\u002Fwww.w3.org\u002F2000\u002Fsvg' xmlns:xlink='http:\u002F\u002Fwww.w3.org\u002F1999\u002Fxlink'%3e%3cdefs%3e%3cfilter id='__svg-blur-f8ebcfd3e52c8208849f238e864d7ea2'%3e%3cfeGaussianBlur in='SourceGraphic' stdDeviation='10'\u002F%3e%3c\u002Ffilter%3e%3c\u002Fdefs%3e%3cimage x='0' y='0' filter='url(%23__svg-blur-f8ebcfd3e52c8208849f238e864d7ea2)' width='1280' height='400' xlink:href='data:image\u002Fpng%3bbase64%2cUklGRgABAABXRUJQVlA4IPQAAABQBQCdASpAABQAPm0wlEYkIyIhKAwAgA2JZQDH5YvX4eSBpQgz7rV3GYQyGzG0jiHolYAA\u002FvpOUtXaoy1%2bxnyV6uuL998TwIbh2G62XtQveW0BGj2IlqLHW5vt95EAfIGf8xXvpf9nVW4%2bV15E04YWUUjUbb9RV%2bRVrhOx1ihoiBu8fw7iOmnWLDexmgWJb0WqFLSyBhGjBuAhyPwfHrlou9jogWRbxEXq9NSc9srE5rE3kmhNJSstr\u002Fsvlixo\u002FeRY7NzwTbPhmYQLVYTQ\u002FfSQfNnGlkqM1B4\u002Fxu9oAH25v%2btpE6q6Wa7RBw\u002FDUrAgEx1QAAAA' \u002F%3e%3c\u002Fsvg%3e"}},"previous":{"title":"别用 Anaconda：如何搭建一个 decent 的机器学习开发环境？","path":"\u002F2020\u002F02\u002Fdont-use-anaconda\u002F"},"next":{"title":"BIT-Web Automation：如何利用 iOS 快捷指令自动化登录 BIT-Web 校园网","path":"\u002F2019\u002F12\u002Fbitweb-auto-login\u002F"}},"context":{"previousElement":"019f5e132f75ba89b72a3541de102594","nextElement":"e45db455693053dde73a2b656a72c0c1","id":"3257345a71828a405ad4b86d931de69b"}};(function(){var s;(s=document.currentScript||document.scripts[document.scripts.length-1]).parentNode.removeChild(s);}());</script><script src="/assets/js/app.017f69db.js" defer></script><script src="/assets/js/page--src--templates--blog-post-vue.8c30e663.js" defer></script>
  </body>
</html>
