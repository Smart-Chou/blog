{"hash":"adc5dd754921ba01e034b10e05b52eb94e7d1500","data":{"tag":{"title":"Shell","belongsTo":{"edges":[{"node":{"title":"Quit using nvm：快删掉这个占据 Zsh 启动时间一半的怪物！","path":"/2020/07/remove-nvm-to-speed-up-zsh/","date":"July 28. 2020","timeToRead":10,"cjkWordCount":2480,"cjkReadTime":11,"description":"没想到啊 nvm，竟然是你这个浓眉大眼的让我 Zsh 开一次足足等 2 秒！","content":"<blockquote>\n<p>✍ Sept 5. 2020 的更新：</p>\n</blockquote>\n<p>今天尝试了一下 <a href=\"https://github.com/zdharma/zinit\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">zinit</a>，这个作者跟 Powerlevel10k 的想法非常类似，都是对 Zsh 的插件进行懒加载，导致其 Turbo mode 加载 Zsh 速度快的飞起！</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/09/200905_212629.png\" alt=\"使用 zinit 加载插件，启动时间仅需 0.6s，但实际上打开瞬间 Zsh 就已经可以交互了\"><figcaption>使用 zinit 加载插件，启动时间仅需 0.6s，但实际上打开瞬间 Zsh 就已经可以交互了</figcaption></figure>\n<p>另外，看到 <code class=\"language-text\">zplug</code> 的 GitHub 上一次提交时间还是今年 2 月份，而且 issue 区已经出现寻找 Maintainer 的请求了，而 <code class=\"language-text\">zinit</code> 最近更新得非常频繁，因此这里推荐大家使用 <code class=\"language-text\">zinit</code> 作为 Zsh 的插件管理器。</p>\n<hr>\n<blockquote>\n<p>🍳 July 28. 2020 的原文章：</p>\n</blockquote>\n<p>我实在是受不了了。我这 10 代 i7 的顶配 ThinkPad 在 WSL 2 里面打开一个 Shell，竟然每次都需要在心里面默念 2 个数才能敲进去字。淦啊 (╬▔皿▔)╯</p>\n<h2 id=\"我管理-zsh-配置的方法\"><a href=\"#%E6%88%91%E7%AE%A1%E7%90%86-zsh-%E9%85%8D%E7%BD%AE%E7%9A%84%E6%96%B9%E6%B3%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>我管理 Zsh 配置的方法</h2>\n<p>对了，得先跟大家说说，我还在用 Zsh，但是我丢掉了 Oh My Zsh 这个好像大家都在用的 Zsh 框架，转而使用更加灵活的 <a href=\"https://github.com/zplug/zplug\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">zplug</a> 来管理我的 Zsh 配置。如果你用 Vim 和 <code class=\"language-text\">vim-plug</code>，那么 <code class=\"language-text\">zplug</code> 用起来的感觉将非常熟悉：<code class=\"language-text\">zplug</code> 跟 <code class=\"language-text\">vim-plug</code> 的设计风格就非常相似。当然，<code class=\"language-text\">zplug</code> 最吸引我的一点还是「高度的可自定义」。不像 Oh My Zsh 把 Zsh 所有配置都为我们设定好了，<code class=\"language-text\">zplug</code> 支持用「插件」的方式安装、配置 Zsh 的各项功能，甚至可以像安装插件一样安装 Oh My Zsh 的部分功能。</p>\n<p>比如，Oh My Zsh 的 Git 插件和预设 alias 们就很好用啊，那我直接就能用 <code class=\"language-text\">zplug</code> 装上：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">zplug <span class=\"token string\">\"plugins/git\"</span>, from:oh-my-zsh\nzplug <span class=\"token string\">\"plugins/common-aliases\"</span>, from:oh-my-zsh</code></pre>\n<p>自动补全 <code class=\"language-text\">zsh-completions</code> 和类似 Fish shell 的自动命令建议 <code class=\"language-text\">zsh-auto-suggestions</code> 也非常有用啊，那我也立刻拿 <code class=\"language-text\">zplug</code> 装上：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">zplug <span class=\"token string\">\"zsh-users/zsh-completions\"</span>\nzplug <span class=\"token string\">\"zsh-users/zsh-autosuggestions\"</span></code></pre>\n<p>可以看到，<code class=\"language-text\">zplug</code> 胜在灵活，自定义程度高，所以我才舍 Oh My Zsh 而取 <code class=\"language-text\">zplug</code>。另外，<code class=\"language-text\">zplug</code> 还支持 parallel update，这点也非常讨我欢心：</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200727-221325.gif\" alt=\"zplug update 支持多个插件同时并行更新\"><figcaption>zplug update 支持多个插件同时并行更新</figcaption></figure>\n<p>好了，这篇文章不光是吹 <code class=\"language-text\">zplug</code> 多好，而是为了找到到底哪个混蛋在耽误我 Zsh 的启动速度。</p>\n<h2 id=\"对-zsh-启动时间进行测量\"><a href=\"#%E5%AF%B9-zsh-%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%B4%E8%BF%9B%E8%A1%8C%E6%B5%8B%E9%87%8F\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>对 Zsh 启动时间进行测量</h2>\n<p>为了定量的衡量 Zsh 的启动过程，我们先建立一个 baseline：测量在当前没有任何插件调整情况下 Zsh 的「冷启动」时间。</p>\n<p>我使用了下面的命令来测量 Zsh 启动时间：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">time</span> <span class=\"token function\">zsh</span> <span class=\"token parameter variable\">-i</span> <span class=\"token parameter variable\">-c</span> <span class=\"token builtin class-name\">exit</span></code></pre>\n<p>未经调整的 Zsh 启动时间数据如下：</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200727-221927.png\" alt=\"初始 Zsh 启动时间\"><figcaption>初始 Zsh 启动时间</figcaption></figure>\n<p>最后一行可以看到，总时间用了 1.93s，多次启动得到的数据类似，1.93s 也符合上面我人肉感知的「心中默念两个数」的时间。</p>\n<p>要知道，为了让 Zsh 更快的显示，我可是直接用上了 Powerlevel10k 这个地表最快，连作者都疯狂优化的 Zsh prompt 主题框架。用 Powerlevel10k 渲染的 Zsh prompt 显示速度可以说是优化到了极致，<a href=\"https://github.com/romkatv/powerlevel10k#uncompromising-performance\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><strong>提供 uncompromising performance</strong></a>。但是接近 2s 的冷启动时间还是令人难受，而这显然不是 Powerlevel10k 的锅。</p>\n<h2 id=\"深入评估-zsh-冷启动过程中的时间使用\"><a href=\"#%E6%B7%B1%E5%85%A5%E8%AF%84%E4%BC%B0-zsh-%E5%86%B7%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%97%B6%E9%97%B4%E4%BD%BF%E7%94%A8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>深入评估 Zsh 冷启动过程中的时间使用</h2>\n<p>经过一番搜索，我发现 Zsh 内部就有一个能够 benchmark 并 profile Zsh 自己启动过程时间使用的工具：<code class=\"language-text\">zprof</code>。如果你学过软件工程，你应该知道评价软件质量的一个重要工具：Profiler，用于衡量软件各个部分各个模块具体执行时间的评测工具。</p>\n<blockquote>\n<p>A <em>profile</em> is a set of statistics that describes how often and for how long various parts of the program executed. <sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup></p>\n</blockquote>\n<p>常见的语言环境都有原生的 Profiler，比如 Python 内置的 <code class=\"language-text\">cProfile</code>、Node.js 内置的功能 <code class=\"language-text\">node --prof</code>……部分 IDE 比如 Visual Studio 也有类似的工具，这些 Profiler 在优化软件的执行速度上起到了举足轻重的作用。</p>\n<p>我们用 <code class=\"language-text\">zprof</code> 来对 Zsh 进行 Profile 评估：</p>\n<ul>\n<li>在 <code class=\"language-text\">.zshrc</code> 的最开头新增一行并写入 <code class=\"language-text\">zmodload zsh/zprof</code>；</li>\n<li>在 <code class=\"language-text\">.zshrc</code> 文件末尾添加一行再写入 <code class=\"language-text\">zprof</code>；</li>\n<li>保存 <code class=\"language-text\">.zshrc</code> 再重启我们的 Zsh Shell（关闭再打开终端）；</li>\n</ul>\n<p>添加了 <code class=\"language-text\">zprof</code> 必要命令后，重新打开 Zsh 时 <code class=\"language-text\">zprof</code> 会开始自动对 Zsh 启动过程中各个过程所用时间进行测算，最终得到类似这样的报告：</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200727-224130.png\" alt=\"zprof 测量 Zsh 冷启动过程各个功能模块执行所用时间报告\"><figcaption>zprof 测量 Zsh 冷启动过程各个功能模块执行所用时间报告</figcaption></figure>\n<p>看前几行的 <code class=\"language-text\">nvm_die_on_prefix</code>、<code class=\"language-text\">nvm</code>、<code class=\"language-text\">nvm_auto</code> 和 <code class=\"language-text\">nvm_ensure_version_installed</code>，它们依次占用了 17.82%、16.34%、15.18% 和 4.80% 的启动时间，<code class=\"language-text\">nvm</code> 相关的模块一共占据了我 Zsh 启动时间的一半以上。原来是你，<code class=\"language-text\">nvm</code>！(ノ｀Д)ノ</p>\n<h2 id=\"删掉-nvm\"><a href=\"#%E5%88%A0%E6%8E%89-nvm\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>删掉 <code class=\"language-text\">nvm</code>？</h2>\n<p>显然，删掉 <code class=\"language-text\">nvm</code> 看起来应该是我们最显而易见、一劳永逸的解决方案，根据上面的数据，删掉 <code class=\"language-text\">nvm</code> 或者不让 <code class=\"language-text\">nvm</code> 在 Zsh 启动时加载大概率能节省一半的启动时间。后者被称为「懒加载」，也就是我们常说的 lazy loading。不过我 Node.js 环境用的还是挺多的，同时 <code class=\"language-text\">nvm</code> 也是出了名的慢，而 <code class=\"language-text\">nvm</code> 市面上的替代品还是挺多的，所以咱们先删掉再说。</p>\n<p><code class=\"language-text\">nvm</code> 实际上仅是一个帮我们管理 Node.js 版本的 Bash 脚本，<code class=\"language-text\">.zshrc</code> 中 <code class=\"language-text\">nvm</code> 相关的加载不多，只有这些：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">NVM_DIR</span><span class=\"token operator\">=</span><span class=\"token string\">\"<span class=\"token environment constant\">$HOME</span>/.nvm\"</span>\n<span class=\"token punctuation\">[</span> <span class=\"token parameter variable\">-s</span> <span class=\"token string\">\"<span class=\"token variable\">$NVM_DIR</span>/nvm.sh\"</span> <span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">\\</span>. <span class=\"token string\">\"<span class=\"token variable\">$NVM_DIR</span>/nvm.sh\"</span> <span class=\"token comment\"># This loads nvm</span>\n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span> <span class=\"token parameter variable\">-r</span> <span class=\"token variable\">$NVM_DIR</span>/bash_completion <span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">\\</span>. <span class=\"token variable\">$NVM_DIR</span>/bash_completion</code></pre>\n<p>将我 <code class=\"language-text\">.zshrc</code> 中加载 <code class=\"language-text\">nvm</code> 的这部分删掉后，重新对 Zsh 的冷启动时间进行测量，得到这样的结果：</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200727-221837.png\" alt=\"删除 nvm 优化后 Zsh 启动时间\"><figcaption>删除 nvm 优化后 Zsh 启动时间</figcaption></figure>\n<p>哟，直接降到 1s 以内了，跟我们设想预期完全一致。拜拜了您嘞 <code class=\"language-text\">nvm</code>！</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">rm</span> <span class=\"token parameter variable\">-rf</span> ~/.nvm</code></pre>\n<h2 id=\"那我后面用什么来管理安装-nodejs\"><a href=\"#%E9%82%A3%E6%88%91%E5%90%8E%E9%9D%A2%E7%94%A8%E4%BB%80%E4%B9%88%E6%9D%A5%E7%AE%A1%E7%90%86%E5%AE%89%E8%A3%85-nodejs\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>那我后面用什么来管理安装 Node.js？</h2>\n<p>好了，删掉了 <code class=\"language-text\">nvm</code>，我们后面用什么呢？这里我推荐一个设计更精良，安装更合理的 Node.js version manager：<a href=\"https://github.com/tj/n\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">n - Interactively Manage Your Node.js Versions</a>。基本的使用方法跟 <code class=\"language-text\">nvm</code> 其实非常相似，但是 <code class=\"language-text\">n</code> 不用往我们 <code class=\"language-text\">.zshrc</code> 里面加一些奇奇怪怪的执行命令，最多只需要一个 <code class=\"language-text\">N_PREFIX</code> 的环境变量来定义 <code class=\"language-text\">n</code> 安装目录。轻量简便，推荐使用！</p>\n<p>推荐大家用 <a href=\"https://github.com/mklement0/n-install\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">n-install</a> 来在 Linux 和 macOS 上安装 <code class=\"language-text\">n</code>：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">curl</span> <span class=\"token parameter variable\">-L</span> https://git.io/n-install <span class=\"token operator\">|</span> <span class=\"token function\">bash</span></code></pre>\n<p><code class=\"language-text\">n-install</code> 可以自动帮我们在 <code class=\"language-text\">$HOME</code> 文件夹下创建 <code class=\"language-text\">n</code> 所使用的安装目录，并将环境变量替我们设定完整，应该是目前为止最方便的 <code class=\"language-text\">n</code> 安装方法。</p>\n<div class=\"admonition admonition-important\"><div class=\"admonition-heading\"><h5><div class=\"admonition-icon\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"14\" height=\"16\" viewBox=\"0 0 14 16\"><path fill-rule=\"evenodd\" d=\"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z\"></path></svg></div>🎍 阅读更多</h5></div><div class=\"admonition-content\"><p>有关 <code class=\"language-text\">n-install</code> 的更多使用细节（包括安装、更新、卸载……）请参考 <code class=\"language-text\">n-install</code> 官方仓库：<a href=\"https://github.com/mklement0/n-install\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">mklement0/n-install</a>。</p></div></div>\n<p>安装成功 <code class=\"language-text\">n</code> 之后，我们就可以像往常一样，安装使用多个版本的 Node.js 啦。</p>\n<h2 id=\"使用-wsl-同学的注意事项\"><a href=\"#%E4%BD%BF%E7%94%A8-wsl-%E5%90%8C%E5%AD%A6%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>使用 WSL 同学的注意事项</h2>\n<p>在上面用 <code class=\"language-text\">n-install</code> 安装 <code class=\"language-text\">n</code> 的时候，在 WSL 里面执行时，我发现了一个很憨批的问题。<code class=\"language-text\">n-install</code> 会检测当前系统 <code class=\"language-text\">$PATH</code> 中是否已经有 <code class=\"language-text\">n</code>、Node.js 或者其他相关的二进制文件，如果发现就会报错：</p>\n<pre class=\"language-text\"><code class=\"language-text\">Aborting, because n and/or Node.js-related binaries are already in the $PATH.</code></pre>\n<p>而 WSL 默认情况下会将 Windows 的 <code class=\"language-text\">$PATH</code> 一并 append 到自己的 <code class=\"language-text\">$PATH</code> 里面，当然这样做无可厚非，毕竟这样可以让我们直接在 WSL 里面调用比如 <code class=\"language-text\">clip.exe</code>、<code class=\"language-text\">explorer.exe</code> 等 Windows 可执行文件。但是，由于我 Windows 里面也安装了 Node.js、yarn 等等，导致 <code class=\"language-text\">n-install</code> 检测到 WSL 的 <code class=\"language-text\">$PATH</code> 包含这些内容，拒绝安装。（在 WSL 中我们可以用 <code class=\"language-text\">echo $PATH</code> 来查看当前 <code class=\"language-text\">$PATH</code> 中包含哪些路径，大概率包含许多 <code class=\"language-text\">/mnt/c/xxx</code> 的路径，这些就是 Windows 的可执行文件路径。）</p>\n<p>这一情况就要我们自己来修改 WSL 的 <code class=\"language-text\">$PATH</code> 了。为了后续工作的顺利开展，我直接利用 <code class=\"language-text\">/etc/wsl.conf</code> 来设定 WSL 的 <code class=\"language-text\">$PATH</code> 中默认不包含 Windows <code class=\"language-text\">$PATH</code>：</p>\n<pre class=\"language-text\"><code class=\"language-text\">[interop]\nappendWindowsPath = false</code></pre>\n<p>重启 WSL 环境（在 Windows 中用命令 <code class=\"language-text\">wsl --shutdown</code>），再次 <code class=\"language-text\">echo $PATH</code>，我们就会得到非常干净的纯 WSL 的 <code class=\"language-text\">$PATH</code>。这样我们即可用 <code class=\"language-text\">n-install</code> 顺利安装 <code class=\"language-text\">n</code> 了。</p>\n<p>不过，这样设定后，我们就无法继续在 WSL 中直接运行 Windows 的可执行文件了。别慌！我们手动将 Windows 中所需要的几个可执行文件添加到 WSL 的 <code class=\"language-text\">$PATH</code> 里面即可。常见的几个 Windows 系统可执行文件的目录位于：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">工具名称</th>\n<th align=\"left\">可执行文件</th>\n<th align=\"left\">WSL 路径</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">Windows 剪贴板</td>\n<td align=\"left\"><code class=\"language-text\">clip.exe</code></td>\n<td align=\"left\"><code class=\"language-text\">/mnt/c/WINDOWS/system32</code></td>\n</tr>\n<tr>\n<td align=\"left\">Windows 资源管理器</td>\n<td align=\"left\"><code class=\"language-text\">explorer.exe</code></td>\n<td align=\"left\"><code class=\"language-text\">/mnt/c/WINDOWS</code></td>\n</tr>\n<tr>\n<td align=\"left\">VS Code 的 <code class=\"language-text\">code</code> 命令</td>\n<td align=\"left\"><code class=\"language-text\">code.exe</code></td>\n<td align=\"left\"><code class=\"language-text\">/mnt/c/Users/&lt;YOUR WINDOWS USERNAME&gt;/AppData/Local/Programs/Microsoft VS Code/bin</code></td>\n</tr>\n</tbody>\n</table>\n<p>我们依次将我们所需要的这些路径在 <code class=\"language-text\">.zshrc</code> 中重新添加到 WSL 的 <code class=\"language-text\">$PATH</code> 即可：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># Manually add Windows explorer and clipboard executables etc. to Linux $PATH</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\"><span class=\"token environment constant\">PATH</span></span><span class=\"token operator\">=</span><span class=\"token string\">\"<span class=\"token environment constant\">$PATH</span>:/mnt/c/WINDOWS:/mnt/c/WINDOWS/system32\"</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\"><span class=\"token environment constant\">PATH</span></span><span class=\"token operator\">=</span><span class=\"token string\">\"<span class=\"token environment constant\">$PATH</span>:/mnt/c/Users/Spencer/AppData/Local/Programs/Microsoft VS Code/bin\"</span></code></pre>\n<h2 id=\"小结\"><a href=\"#%E5%B0%8F%E7%BB%93\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>小结</h2>\n<p>文章到这里就介绍完毕啦，<strong>这里我只是为大家提供给 Zsh 启动过程进行时间测量和 profile benchmark 的标准方法</strong>，如果各位也想加速自己 Zsh 的启动过程，那么可能除了删掉 <code class=\"language-text\">nvm</code> 换用 <code class=\"language-text\">n</code>，还需要结合自己的实际情况，删除、懒加载部分插件或工具。个人认为优化到 1s 以内就是比较合理的、可以接受的冷启动时间啦。就酱，感谢阅读。(<em>/ω＼</em>)</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">\n<p><a href=\"https://docs.python.org/3/library/profile.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://docs.python.org/3/library/profile.html</a></p>\n<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a>\n</li>\n</ol>\n</div>\n"}}]}}},"context":{}}