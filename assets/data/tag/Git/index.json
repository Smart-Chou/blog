{"hash":"adc5dd754921ba01e034b10e05b52eb94e7d1500","data":{"tag":{"title":"Git","belongsTo":{"edges":[{"node":{"title":"震惊！竟然有人在 GitHub 上冒充我的身份！","path":"/2020/08/wait-this-is-not-my-commit/","date":"August 30. 2020","timeToRead":13,"cjkWordCount":3160,"cjkReadTime":14,"description":"所以 GPG Key 是必备，不要心存侥幸啦！快让 GitHub 给你的 commit 标上 verified 小勾勾。","content":"<h2 id=\"起因\"><a href=\"#%E8%B5%B7%E5%9B%A0\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>起因</h2>\n<p>这件事情还要从我校为毕业生收拾行李开始讲起。今年六月末北京疫情复发，这一波直接让我们北京高校毕业生无法返校，个人行李物品必须由学校老师代为整理快递回家。这件事情让同级的同学们非常不满，于是微博知乎节奏飞起。当然这件事情是北京统一的行为，其中不光有我校学生自己不满，其他北京的学校听说有些处理的比我校更要糟糕，所以这件事情我们暂且不做评价。但从事情开始，就有「好事」的同学除了在知乎等平台上进行回答评论、表达意见，还直接在 GitHub 上面直接整理记录时间线。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/08/200830_153718.png\" alt=\"一个目录，暂时不放具体仓库与地址\"><figcaption>一个目录，暂时不放具体仓库与地址</figcaption></figure>\n<h2 id=\"我被牵扯进去了\"><a href=\"#%E6%88%91%E8%A2%AB%E7%89%B5%E6%89%AF%E8%BF%9B%E5%8E%BB%E4%BA%86\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>我被牵扯进去了？</h2>\n<p>为什么这个仓库引起了我的注意呢？首先，对于收拾行李这件事情来说，我所在学院做的其实不错，我自己是我院一位备受尊敬的副教授老师为我收拾的，整理的非常好，所以我个人自始至终并没有对这件事情有什么太大意见，没有参与知乎讨论，也没有进行所谓的争论抗议。这些都是两个月之前发生的事情，但是，两个月之后的今天，有认识我的同学告诉我这个仓库的存在，<strong>并私下询问我为什么也给这个仓库进行了贡献。</strong></p>\n<p><strong>是的，一个我直到昨天都还完全不知道存在的仓库，有人看到了「一条 commit 是由我的邮箱签入的」，并「链接到我的 GitHub 账户」。</strong></p>\n<p>我当时：</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/08/200830_154650.png\" alt=\"……\"><figcaption>……</figcaption></figure>\n<p>好奇心让我点开了同学发给我的链接，向下划到 Contributors，果然，我的头像就在那里。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/08/200830_154938.png\" alt=\"淦，老子昨天才知道你这仓库的，宁真厉害\"><figcaption>淦，老子昨天才知道你这仓库的，宁真厉害</figcaption></figure>\n<p>好嘛，除了我的头像，还有个我非常眼熟的头像 —— 下面这位老爷子：</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/08/200830_155124.png\" alt=\"这人我看着有点眼熟……\"><figcaption>这人我看着有点眼熟……</figcaption></figure>\n<p>我去，这不是 Python 他爹吗？！！敢情 Python 之父也关心我们小破学校毕业生收拾行李的事情了？</p>\n<h2 id=\"我惊了\"><a href=\"#%E6%88%91%E6%83%8A%E4%BA%86\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>我惊了</h2>\n<p>仔细看了一下贡献者列表，其中不乏开源世界的知名人物，也包括一些我校在 GitHub 上有账号的同学们。好了，这处处透露着诡异的仓库，<strong>看起来除了这位仓库主人自己的 commit 以外，其余所有的 commit 的身份信息都是伪造的。</strong></p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/08/200830_160029.png\" alt=\"细节修改你个大头鬼啊，这里「我的」commit 周围都被篡改为我身边认识的大佬同学了\"><figcaption>细节修改你个大头鬼啊，这里「我的」commit 周围都被篡改为我身边认识的大佬同学了</figcaption></figure>\n<p>这件事情昨天确实让我非常震惊：Git 的 commit 记录竟然还可以伪造。我确实之前从来没有在意过这类安全问题，以为签入 Git 记录的内容都有完善的身份验证，<strong>而事实证明我太天真了。</strong></p>\n<p>这位我完全不认识的同学，我不知道你是何种初衷，把这个「搞事情」的仓库的 commit 记录在我们都不知情的情况下篡改为我们的身份，<strong>但是你这种行为让我感到非常恶心</strong>。如果你自己都不敢于承担自己「搞事情」所带来的风险，一定要「强行」拉着一群不知情的同学，来装作好多人都对此有所看法、跃跃欲试、一起贡献的样子，<strong>那你还搞个 🐔 8️⃣ 啊！</strong></p>\n<p>那…现在怎么办？我自己给 GitHub Support 已经发去了邮件，不知道这种事情 GitHub 会不会帮我解决，但是从我自己的角度来说，除了尽可能通知我认识的同学他们在 GitHub 上也被人冒充了外，也只能分析一下为什么这种漏洞会存在，以及接下来该如何解决这种问题了。</p>\n<h2 id=\"漏洞分析\"><a href=\"#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>漏洞分析</h2>\n<h3 id=\"git-的设计缺陷\"><a href=\"#git-%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%BC%BA%E9%99%B7\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Git 的设计缺陷</h3>\n<p>事实上，Git 本身是具有这样的设计缺陷的。<strong>Git commit 信息的 author 是一个可以零成本造假的字符串。</strong>首先，我们来看看一个 commit 里面包含哪些信息。我们可以用 <code class=\"language-text\">git log</code>（或 Oh My Zsh 的 alias 命令：<code class=\"language-text\">glog</code> 来打印一个更为清楚的 commit 历史）来查看本地 Git 仓库的 commit 记录，并找到一个特定 commit 的 hash，比如我当前仓库的 HEAD commit hash 为 <code class=\"language-text\">d3f97ef</code>。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/08/200830_163010.png\" alt=\"Git 仓库的 commit 记录\"><figcaption>Git 仓库的 commit 记录</figcaption></figure>\n<p>我使用一个上周的 commit hash <code class=\"language-text\">df6eb5f</code>，我们可以用 <code class=\"language-text\">git cat-file -p df6eb5f</code> 来查看这一 commit 的具体信息：</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/08/200830_163212.png\" alt=\"Commit hash 为 df6eb5f 的 commit 具体信息\"><figcaption>Commit hash 为 df6eb5f 的 commit 具体信息</figcaption></figure>\n<p>可以发现，每个 commit 都拥有 commit 的 author 和 commit 的 committer，分别是 commit 的第一作者和执行 commit 具体操作的人。如何确认这两人的具体身份呢？Git 仅记录了 commit author 和 committer 二人的名称、邮箱和时间戳，而其中的名称和邮箱正是我们配置 Git 时设定的 <code class=\"language-text\">user.name</code> 和 <code class=\"language-text\">user.email</code>，而 GitHub 也正是通过这两个内容确定 commit 的具体作者和 GitHub 身份的。</p>\n<p>好的，既然我们知道了 Git 和 GitHub 是如何确认身份的，那么我们如何修改 commit author 和 committer 呢？事实上，这两个内容仅是字符串存储的，<code class=\"language-text\">user.name</code> 和 <code class=\"language-text\">user.email</code> 都是可以任意篡改的，因此我们完全可以直接修改自己 git config 中存储的 <code class=\"language-text\">user.name</code> 和 <code class=\"language-text\">user.email</code> 来让本次 commit 的作者变为另一个人。原生 Git 完全没有任何第二层防护！</p>\n<p>甚至，我们可以将整个仓库的 Git commit 历史通过 <code class=\"language-text\">filer-branch</code> 批量修改为其他的人：</p>\n<pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token function\">git</span> commit <span class=\"token parameter variable\">-am</span> <span class=\"token string\">\"Destroy production\"</span>\n<span class=\"token function\">git</span> filter-branch --env-filter <span class=\"token punctuation\">\\</span>\n  <span class=\"token string\">'if [ \"$GIT_AUTHOR_EMAIL\" = \"iamthe@evilguy.com\" ]; then\n     GIT_AUTHOR_EMAIL=\"unsuspecting@victim.com\";\n     GIT_AUTHOR_NAME=\"Unsuspecting Victim\";\n     GIT_COMMITTER_EMAIL=$GIT_AUTHOR_EMAIL;\n     GIT_COMMITTER_NAME=\"$GIT_AUTHOR_NAME\"; fi'</span> -- <span class=\"token parameter variable\">--all</span>\n<span class=\"token function\">git</span> push <span class=\"token parameter variable\">-f</span></code></pre>\n<p>大概就是这样，Git 的 commit 是可以任意修改的，你可以将某个坏 commit 嫁祸给别人，甚至将某个坏仓库的 commit 批量嫁祸给毫不知情的人，但我希望大家永远都不要做这样的事情！</p>\n<h3 id=\"如何防范这种行为\"><a href=\"#%E5%A6%82%E4%BD%95%E9%98%B2%E8%8C%83%E8%BF%99%E7%A7%8D%E8%A1%8C%E4%B8%BA\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>如何防范这种行为？</h3>\n<p>这可怎么办，我们该如何在互联网上证明自己是自己？该如何证明这不是自己？对于 Git 来说，其实我们还是有办法的 —— GPG 签名。GPG 全称为 GNU Privacy Guard，GPG 通过非对称加密来帮助我们从密码学的角度证明「我是我」，也从而证明「这不一定真的是我」。</p>\n<p>使用一个只有我们自己手中拥有的 GPG 私钥对我们的 commit 进行签名，可以让 GitHub 确认我们本次 commit 是真实且是本人操作的。这样，别有用心的他人就无法以我们的身份创建「被签名」的 commit。在 GitHub 上使用的 GPG 密钥和我们的 SSH 密钥并不一样，后者 SSH key 唯一存在的原因是为了向 GitHub 证明身份，用于向我们拥有权限的仓库中进行 commit，而前者 GPG key 则是为了「证明我拥有本次 commit 的著作权」，也只有用 GPG 私钥签名的 commit 在 GitHub 上才会显示如下图的 Verified 绿色钦定小标标。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/08/200830_165356.png\" alt=\"使用 GPG 签名的 commit 会在 GitHub 上显示 Verified 标志\"><figcaption>使用 GPG 签名的 commit 会在 GitHub 上显示 Verified 标志</figcaption></figure>\n<h2 id=\"使用-gpg-key-来证明-commit-著作权\"><a href=\"#%E4%BD%BF%E7%94%A8-gpg-key-%E6%9D%A5%E8%AF%81%E6%98%8E-commit-%E8%91%97%E4%BD%9C%E6%9D%83\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>使用 GPG key 来证明 commit 著作权</h2>\n<div class=\"admonition admonition-note\"><div class=\"admonition-heading\"><h5><div class=\"admonition-icon\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"14\" height=\"16\" viewBox=\"0 0 14 16\"><path fill-rule=\"evenodd\" d=\"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z\"></path></svg></div>💙 GitHub 官方文档</h5></div><div class=\"admonition-content\"><p>GitHub 官方文档拥有更为详细的 GPG 密钥构建和添加方法：<a href=\"https://docs.github.com/en/github/authenticating-to-github/managing-commit-signature-verification\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Managing commit signature verification</a>.</p></div></div>\n<h3 id=\"下载安装-gpg\"><a href=\"#%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85-gpg\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>下载安装 GPG</h3>\n<p>首先，我们需要下载安装 GPG 命令行工具，在 Windows 上可以通过 <code class=\"language-text\">scoop install gpg</code> 来安装，大部分 Linux 发行版也应该直接拥有 GPG 工具。</p>\n<pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token comment\"># Windows 用户下载安装 GPG</span>\n$ scoop <span class=\"token function\">install</span> gpg</code></pre>\n<p>使用 <code class=\"language-text\">gpg --version</code> 查看 GPG 安装情况和版本信息，并记住 GPG 存储根目录：即输出内容中的 Home 目录。</p>\n<pre class=\"language-shell\"><code class=\"language-shell\"><span class=\"token comment\"># 测试 GPG（Windows 或 Linux）</span>\n$ gpg <span class=\"token parameter variable\">--version</span>\n\ngpg <span class=\"token punctuation\">(</span>GnuPG<span class=\"token punctuation\">)</span> <span class=\"token number\">2.2</span>.19\nlibgcrypt <span class=\"token number\">1.8</span>.5\nCopyright <span class=\"token punctuation\">(</span>C<span class=\"token punctuation\">)</span> <span class=\"token number\">2019</span> Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version <span class=\"token number\">3</span> or later <span class=\"token operator\">&lt;</span>https://gnu.org/licenses/gpl.html<span class=\"token operator\">></span>\nThis is <span class=\"token function\">free</span> software: you are <span class=\"token function\">free</span> to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\nHome: /home/spencer/.gnupg\nSupported algorithms:\nPubkey: RSA, ELG, DSA, ECDH, ECDSA, EDDSA\nCipher: IDEA, 3DES, CAST5, BLOWFISH, AES, AES192, AES256, TWOFISH,\n        CAMELLIA128, CAMELLIA192, CAMELLIA256\nHash: SHA1, RIPEMD160, SHA256, SHA384, SHA512, SHA224\nCompression: Uncompressed, ZIP, ZLIB, BZIP2</code></pre>\n<h3 id=\"为自己生成一对-gpg-密钥\"><a href=\"#%E4%B8%BA%E8%87%AA%E5%B7%B1%E7%94%9F%E6%88%90%E4%B8%80%E5%AF%B9-gpg-%E5%AF%86%E9%92%A5\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>为自己生成一对 GPG 密钥</h3>\n<p>之后，我们就可以用下面的命令来为自己生成一个 GPG 公钥和私钥：</p>\n<pre class=\"language-shell\"><code class=\"language-shell\">$ gpg --full-generate-key</code></pre>\n<ul>\n<li>在密钥种类处：选择默认 RSA and DSA 即可；</li>\n<li>在密钥长度选项处：按照 GitHub 的要求选择 4096 bits；</li>\n<li>在密钥过期时间处：按照自己的需要选择，默认为永不过期；</li>\n<li>在我们的用户 ID 和 GPG key 签名邮箱处：填写我们的常用用户名，并<strong>填入 GitHub 上面认证过的邮箱</strong>；</li>\n<li>最后，为密钥设置一个安全的密码，并一定记住这一密码。</li>\n</ul>\n<p>这样，我们就生成了我们的第一对 GPG 密钥！我们可以用这样的命令查看当前我们拥有的所有 GPG key：</p>\n<pre class=\"language-shell\"><code class=\"language-shell\">$ gpg --list-secret-keys --keyid-format LONG\n\n/home/spencer/.gnupg/pubring.kbx\n--------------------------------\nsec   rsa4096/24CD550268849CA0 <span class=\"token number\">2020</span>-08-29 <span class=\"token punctuation\">[</span>SC<span class=\"token punctuation\">]</span>\n      9433E1B6807DE7C15E20DC3B24CD550268849CA0\nuid                 <span class=\"token punctuation\">[</span>ultimate<span class=\"token punctuation\">]</span> Spencer Woo <span class=\"token punctuation\">(</span>My GPG key<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span>my@email.com<span class=\"token operator\">></span>\nssb   rsa4096/EB754D2B2409E9FE <span class=\"token number\">2020</span>-08-29 <span class=\"token punctuation\">[</span>E<span class=\"token punctuation\">]</span></code></pre>\n<p>其中，<code class=\"language-text\">sec</code> 一行的 <code class=\"language-text\">rsa4096/24CD550268849CA0</code> 就是我们的 GPG 私钥，其中的 <code class=\"language-text\">24CD550268849CA0</code> 即为我们的 GPG 私钥 ID。</p>\n<h3 id=\"告诉-git-自己的-gpg-密钥-id\"><a href=\"#%E5%91%8A%E8%AF%89-git-%E8%87%AA%E5%B7%B1%E7%9A%84-gpg-%E5%AF%86%E9%92%A5-id\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>告诉 Git 自己的 GPG 密钥 ID</h3>\n<p>生成了 GPG 密钥，并拿到了我们的 GPG 私钥 ID 后，我们即可让 Git 用这一 GPG key 为我们的 commit 进行签名：</p>\n<pre class=\"language-shell\"><code class=\"language-shell\">$ <span class=\"token function\">git</span> config <span class=\"token parameter variable\">--global</span> user.signingkey 24CD550268849CA0\n$ <span class=\"token function\">git</span> config <span class=\"token parameter variable\">--global</span> commit.gpgsign <span class=\"token boolean\">true</span></code></pre>\n<p>这样设置后，如果没有问题，之后的 commit 中 Git 就会自动为我们用这一 GPG 私钥进行签名。我们可以用这一命令确认签名的存在：</p>\n<pre class=\"language-shell\"><code class=\"language-shell\">$ <span class=\"token function\">git</span> log --show-signature\n\ncommit c407d4efc980cbee981da50d714a751999b19ddf <span class=\"token punctuation\">(</span>HEAD -<span class=\"token operator\">></span> master<span class=\"token punctuation\">)</span>\ngpg: Signature made Sun Aug <span class=\"token number\">30</span> <span class=\"token number\">17</span>:16:18 <span class=\"token number\">2020</span> CST\ngpg:                using RSA key 9433E1B6807DE7C15E20DC3B24CD550268849CA0\ngpg: Good signature from <span class=\"token string\">\"Spencer Woo (My GPG key) &lt;my@email.com>\"</span> <span class=\"token punctuation\">[</span>ultimate<span class=\"token punctuation\">]</span>\nAuthor: spencerwooo <span class=\"token operator\">&lt;</span>my@email.com<span class=\"token operator\">></span>\nDate:   Sun Aug <span class=\"token number\">30</span> <span class=\"token number\">17</span>:16:18 <span class=\"token number\">2020</span> +0800\n\n    Signed by GPG</code></pre>\n<p>另外，此时我们再次用之前查看 commit 详细信息的命令查看本次 commit，我们会发现 GPG 签名已经直接保存于这一 commit 之中了：</p>\n<pre class=\"language-shell\"><code class=\"language-shell\">$ <span class=\"token function\">git</span> cat-file <span class=\"token parameter variable\">-p</span> c407d4e</code></pre>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/08/200830_172152.png\" alt=\"已经签名过的 commit 包含有我们使用的 PGP signature\"><figcaption>已经签名过的 commit 包含有我们使用的 PGP signature</figcaption></figure>\n<p>另外，这里如果出现类似的问题，可能是 Git 使用的 GPG 命令行工具跟我们生成密钥使用的不一致。我们可以首先用 <code class=\"language-text\">which gpg</code> 来找到我们所使用的 GPG 工具的具体地址，比如 <code class=\"language-text\">/usr/bin/gpg</code>，之后告诉 Git 使用这一 GPG binary 即可：</p>\n<pre class=\"language-shell\"><code class=\"language-shell\">$ <span class=\"token function\">git</span> config <span class=\"token parameter variable\">--global</span> gpg.program /usr/bin/gpg</code></pre>\n<div class=\"admonition admonition-important\"><div class=\"admonition-heading\"><h5><div class=\"admonition-icon\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"14\" height=\"16\" viewBox=\"0 0 14 16\"><path fill-rule=\"evenodd\" d=\"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z\"></path></svg></div>🥦 GPG 可执行文件路径</h5></div><div class=\"admonition-content\"><p>Windows 上的同学，也可以使用 <code class=\"language-text\">which</code> 命令！只需要用 scoop 安装：<code class=\"language-text\">scoop install which</code>，即可方便的用类似 Linux 上的语法找到相应的可执行文件具体路径。</p></div></div>\n<h3 id=\"告诉-github-自己的-gpg-公钥\"><a href=\"#%E5%91%8A%E8%AF%89-github-%E8%87%AA%E5%B7%B1%E7%9A%84-gpg-%E5%85%AC%E9%92%A5\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>告诉 GitHub 自己的 GPG 公钥</h3>\n<p>最后，我们需要告诉 GitHub 我们使用的 GPG 公钥。对于刚刚我们拿到的私钥 ID：<code class=\"language-text\">24CD550268849CA0</code>，我们使用下面的命令即可导出我们的 GPG 公钥：</p>\n<pre class=\"language-shell\"><code class=\"language-shell\">$ gpg <span class=\"token parameter variable\">--armor</span> <span class=\"token parameter variable\">--export</span> 24CD550268849CA0</code></pre>\n<p>将输出粘贴进入 GitHub 的 <a href=\"https://github.com/settings/keys\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Settings » SSH and GPG keys » New GPG key</a>，并保存。之后，我们就可以开始在 GitHub 上享受 Verified 被钦定的感觉！</p>\n<h2 id=\"小结\"><a href=\"#%E5%B0%8F%E7%BB%93\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>小结</h2>\n<p>使用 GPG 不仅可以证明我们的每次 commit 的所有权，还可以用类似的密码学方法证明 GitHub 账号的所有权、域名的所有权、Twitter 账号的所有权等等。我们将我们的 GPG 公钥托管在某个 GPG 服务器上面，别人就可以利用这一公钥来验证某个被签名的内容是否确实是我们所操作。<a href=\"https://keybase.io/inv/784d1a88fa\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Keybase.io</a> 是一个 trusted database for public keys，推荐大家使用 <a href=\"https://keybase.io/inv/784d1a88fa\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Keybase.io</a> 托管自己的 GPG 公钥。</p>\n<p>无论如何，大家都可以用这一命令拉取并导入我（Spencer Woo）的 GPG 公钥签名：</p>\n<pre class=\"language-shell\"><code class=\"language-shell\">$ <span class=\"token function\">curl</span> https://keybase.io/spencerwoo/pgp_keys.asc <span class=\"token operator\">|</span> gpg <span class=\"token parameter variable\">--import</span></code></pre>\n<ul>\n<li>我的 Keybase 地址：<a href=\"https://keybase.io/spencerwoo\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">keybase.io/spencerwoo</a></li>\n<li>我的 Keybase 公钥：ASCtXMcCY0UpKPF6NpoLlwJT3xXsD5nzunxF2ei4gBRBkgo</li>\n</ul>\n<p>感谢大家的阅读，希望大家都不会遭遇被冒充的情况！</p>\n"}},{"node":{"title":"Working Copy + iA Writer：第二次尝试从我的 iPad 上面更新博客","path":"/2019/11/update-from-ipad-iawriter/","date":"November 14. 2019","timeToRead":4,"cjkWordCount":898,"cjkReadTime":4,"description":"我又开始玩我的 iPad 了","content":"<p>之前，我就曾经介绍过我是如何利用 iPad 对部署在 GitHub 上面的静态博客进行更新的。这篇文章即使到现在也有一定的借鉴意义，文章归档于：<a href=\"https://archive.spencerwoo.com/posts/2019/06/09/from-my-ipad.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">使用 Working Copy 在 iPad 上面更新博客 | 一次随缘的更新</a>。</p>\n<p>现在，我重新部署了我的静态博客，利用 Hugo 进行构建。宣称全球最快的静态网站渲染引擎 —— Hugo 着实让我博客的编译和部署过程快人一步。借助于方便的 Netlify，只要配置好 CI 的编译命令和环境变量，我们就只需要专注于博客本身的撰写，而不必对博客其他属性进行过多的担心。这样的部署方法，让 iPad 都可以直接发表博文。</p>\n<h2 id=\"前言\"><a href=\"#%E5%89%8D%E8%A8%80\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>前言</h2>\n<p>为什么我又换回了静态博客？Listed 确实不错，但是我在给与之配套的笔记应用 Standard Notes 充值一年会员之后，发现 Standard Notes 真的不行。不论是应用本身的响应还是界面的设计，Standard Notes 都和 Bear 等一众笔记应用相距甚远。Listed 博客需要会员才能自定义域名，并且 Listed 本身也没有评论系统，只有一个类似留言板的 Guestbook，难过。</p>\n<p>另外，我还专门问了问开发者为什么 Listed 不支持评论：</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220619.png\" alt=\"和 Listed/Standard Notes 作者的交流\"><figcaption>和 Listed/Standard Notes 作者的交流</figcaption></figure>\n<p>// 我猜是开发者被垃圾评论骂怕了 😂</p>\n<p>就这样，Hugo 就变成了目前我的博客部署引擎首选。</p>\n<h2 id=\"设备和工具\"><a href=\"#%E8%AE%BE%E5%A4%87%E5%92%8C%E5%B7%A5%E5%85%B7\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>设备和工具</h2>\n<p>更新博客我试用了下面的设备：</p>\n<ul>\n<li>iPad Air (3rd Gen)</li>\n<li>Logitech K380：键盘</li>\n<li>Logitech M558：鼠标</li>\n</ul>\n<p>在 iPad 上面，我尝试使用 iA Writer 来编辑 Markdown 文档，利用 Working Copy 来更新 GitHub 仓库。由于 Working Copy 支持 <strong>Edit in place</strong>，因此我们在 iA Writer 中可以导入 Working Copy 的某个文件夹（比如博文文件夹 <code class=\"language-text\">posts</code>），从而直接编辑其中的 Markdown 文件。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220619-1.png\" alt=\"在 iA Writer 中直接编辑 Working Copy 文件\"><figcaption>在 iA Writer 中直接编辑 Working Copy 文件</figcaption></figure>\n<h2 id=\"更新流程\"><a href=\"#%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>更新流程</h2>\n<ul>\n<li>利用 Working Copy 将博客源文件克隆至 iPad 上面</li>\n</ul>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220619-2.png\" alt=\"Working Copy 上面克隆仓库\"><figcaption>Working Copy 上面克隆仓库</figcaption></figure>\n<ul>\n<li>利用 iA Writer 打开 Working Copy 中的博客 <code class=\"language-text\">posts</code> 文件夹</li>\n<li>在 iA Writer 中创建新文章、编辑旧博客文章</li>\n<li>在 iA Writer 中通过快捷键 <code class=\"language-text\">Command + R</code> 直接预览文章</li>\n</ul>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220619-3.png\" alt=\"iA Writer 编辑文章\"><figcaption>iA Writer 编辑文章</figcaption></figure>\n<ul>\n<li>在 Working Copy 中通过 Git 直接将博客同步至 GitHub</li>\n</ul>\n<p>iPad 胜在方便，不需要过多的配置即可直接撰写文章。爱了，❤️。</p>\n<h2 id=\"另外\"><a href=\"#%E5%8F%A6%E5%A4%96\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>另外</h2>\n<p>除了上面的方法，Forestry.io 也是一个可以的选择。Forestry.io 是一个极度完善的静态博客 CMS 统一管理平台，支持 Hugo、VuePress、Gatsby 等诸多博客引擎。利用 Forestry 在线网页版本的后台管理，我们甚至可以直接的撰写文章内容，并在 Forestry 服务器上面渲染文章并预览。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220619-4.png\" alt=\"Forestry 的文章编辑界面\"><figcaption>Forestry 的文章编辑界面</figcaption></figure>\n<p>Forestry 虽然好用，但是 Forestry 在 iPad 上面的编辑体验并不太好，因为相对小的屏幕，Forestry 的文章编辑界面相当狭窄，令人遗憾。</p>\n<p>总之，Working Copy 是 iPad 的最佳搭档，而 iA Writer 是 iPad 上面最纯粹的 Markdown 编辑器。这二者结合，确实能让我随时随地发布博客。爱了！❤️</p>\n"}},{"node":{"title":"Batch Git Pull：分享一个维护多个 Git 仓库的小脚本","path":"/2019/11/batch-git-pull/","date":"November 13. 2019","timeToRead":4,"cjkWordCount":927,"cjkReadTime":5,"description":"如何一次更新多个 Git 仓库","content":"<p>不废话，放脚本：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">find</span> <span class=\"token builtin class-name\">.</span> <span class=\"token parameter variable\">-maxdepth</span> <span class=\"token number\">3</span> <span class=\"token parameter variable\">-name</span> .git <span class=\"token parameter variable\">-type</span> d <span class=\"token operator\">|</span> <span class=\"token function\">rev</span> <span class=\"token operator\">|</span> <span class=\"token function\">cut</span> <span class=\"token parameter variable\">-c</span> <span class=\"token number\">6</span>- <span class=\"token operator\">|</span> <span class=\"token function\">rev</span> <span class=\"token operator\">|</span> <span class=\"token function\">xargs</span> <span class=\"token parameter variable\">-I</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token function\">git</span> <span class=\"token parameter variable\">-C</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> pull</code></pre>\n<p>更为方便的，直接将这部分加入你的 <code class=\"language-text\">.zshrc</code> 或者 <code class=\"language-text\">.bash_profile</code>：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">alias</span> <span class=\"token assign-left variable\">gpall</span><span class=\"token operator\">=</span><span class=\"token string\">\"find . -maxdepth 3 -name .git -type d | rev | cut -c 6- | rev | xargs -I {} git -C {} pull\"</span></code></pre>\n<p>之后，直接执行 <code class=\"language-text\">gpall</code> 即可。</p>\n<p>好了，我们进入正题。</p>\n<h2 id=\"维护多个-git-仓库的需求\"><a href=\"#%E7%BB%B4%E6%8A%A4%E5%A4%9A%E4%B8%AA-git-%E4%BB%93%E5%BA%93%E7%9A%84%E9%9C%80%E6%B1%82\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>维护多个 Git 仓库的需求</h2>\n<p>维护多个 Git 仓库不容易。我在我存放 GitHub 仓库的目录下运行了一下 <code class=\"language-text\">tree</code>：</p>\n<pre class=\"language-text\"><code class=\"language-text\">.\n├── AIP_BackEnd\n├── Evaluation_BackEnd\n| ... ...\n├── SchoolProjects\n│   ├── Distance-Vector-Algorithm\n│   ├── cartoonize-images\n| ... ...\n│   ├── zanpress-blog\n│   └── zanpress-diagram\n| ... ...\n└── wechat-format\n\n103 directories</code></pre>\n<p>103 个目录……我自己 <code class=\"language-text\">Documents/GitHub</code> 文件夹下就有这么多 Git 仓库，一个一个去更新真的很费事情。如何批量更新 GitHub 本地仓库呢？其实就是一个遍历目录，对匹配到的 Git 仓库在其当前分支下执行 <code class=\"language-text\">git pull</code> 的需求嘛，很简单。</p>\n<h2 id=\"解决方法\"><a href=\"#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>解决方法</h2>\n<p>在 Medium 上面，我找到了一个相当优雅的脚本。前面这个脚本已经分享给各位了，我们重新看一下：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">find</span> <span class=\"token builtin class-name\">.</span> <span class=\"token parameter variable\">-maxdepth</span> <span class=\"token number\">3</span> <span class=\"token parameter variable\">-name</span> .git <span class=\"token parameter variable\">-type</span> d <span class=\"token operator\">|</span> <span class=\"token function\">rev</span> <span class=\"token operator\">|</span> <span class=\"token function\">cut</span> <span class=\"token parameter variable\">-c</span> <span class=\"token number\">6</span>- <span class=\"token operator\">|</span> <span class=\"token function\">rev</span> <span class=\"token operator\">|</span> <span class=\"token function\">xargs</span> <span class=\"token parameter variable\">-I</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token function\">git</span> <span class=\"token parameter variable\">-C</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> pull</code></pre>\n<p>可以发现，这一长串命令，事实上就是前面的命令执行结果通过「管道」输出至后面的命令作为输入，也就是命令中 <code class=\"language-text\">|</code> 的功能。我们一段一段看一下这个命令具体都干了什么。</p>\n<h3 id=\"用-find-搜索目录下全部-git-文件夹\"><a href=\"#%E7%94%A8-find-%E6%90%9C%E7%B4%A2%E7%9B%AE%E5%BD%95%E4%B8%8B%E5%85%A8%E9%83%A8-git-%E6%96%87%E4%BB%B6%E5%A4%B9\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>用 <code class=\"language-text\">find</code> 搜索目录下全部 <code class=\"language-text\">.git/</code> 文件夹</h3>\n<p>每个 Git 文件夹里面一定有 <code class=\"language-text\">.git</code> 的目录，我们只需要找到 <code class=\"language-text\">.git</code> 文件夹既可以找到 Git 目录。</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">find</span> <span class=\"token builtin class-name\">.</span> <span class=\"token parameter variable\">-maxdepth</span> <span class=\"token number\">3</span> <span class=\"token parameter variable\">-name</span> .git <span class=\"token parameter variable\">-type</span> d</code></pre>\n<p>这里，我们就使用了 <code class=\"language-text\">find</code> 的命令，详见：<a href=\"https://www.gnu.org/software/findutils/manual/html_mono/find.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">GNU - Finding Files</a>。我们将命令分解来看：</p>\n<ul>\n<li><code class=\"language-text\">.</code> 表示匹配命令执行路径下的全部文件与文件夹</li>\n<li><code class=\"language-text\">-maxdepth 3</code> 表示向下搜索最多三层级目录</li>\n<li><code class=\"language-text\">-name .git</code> 就是搜索名称为 <code class=\"language-text\">.git</code> 的内容</li>\n<li><code class=\"language-text\">-type d</code> 则指明了我们搜索的范畴：Directories（目录）</li>\n</ul>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-214839.png\" alt=\"搜索 .git 文件夹\"><figcaption>搜索 .git 文件夹</figcaption></figure>\n<p>一目了然，我们下面就这样对每个命令进行分解和解释。</p>\n<h3 id=\"裁剪出我们要的-git-文件夹所在路径\"><a href=\"#%E8%A3%81%E5%89%AA%E5%87%BA%E6%88%91%E4%BB%AC%E8%A6%81%E7%9A%84-git-%E6%96%87%E4%BB%B6%E5%A4%B9%E6%89%80%E5%9C%A8%E8%B7%AF%E5%BE%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>裁剪出我们要的 <code class=\"language-text\">.git</code> 文件夹所在路径</h3>\n<p>上面我们解析出来的路径，每个路径后面都包含一个 <code class=\"language-text\">.git</code>，我们需要统一将这个 <code class=\"language-text\">.git</code> 从字符串中删掉，这样才能一起对给定目录执行 <code class=\"language-text\">git pull</code>。第二步我们进行目录的裁剪。</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">..</span>. <span class=\"token operator\">|</span> <span class=\"token function\">rev</span> <span class=\"token operator\">|</span> <span class=\"token function\">cut</span> <span class=\"token parameter variable\">-c</span> <span class=\"token number\">6</span>- <span class=\"token operator\">|</span> <span class=\"token function\">rev</span> <span class=\"token operator\">|</span> <span class=\"token punctuation\">..</span>.</code></pre>\n<p>可以发现，这里我们有三部分命令。我们依次对命令进行解析：</p>\n<ol>\n<li><code class=\"language-text\">rev</code>：首先对搜索到的目录（字符串）进行反转</li>\n<li><code class=\"language-text\">cut -c 6-</code>：我们利用 <code class=\"language-text\">cut</code> 工具将路径进行裁剪，<code class=\"language-text\">-c</code> 表示删减的是字符（Characters），<code class=\"language-text\">6-</code> 表示我们删去路径的前 6 个字符（即：<code class=\"language-text\">.git</code>）</li>\n<li><code class=\"language-text\">rev</code>：将处理好的字符串反转回来</li>\n</ol>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-214839-1.png\" alt=\"裁剪路径\"><figcaption>裁剪路径</figcaption></figure>\n<h3 id=\"利用-xargs-执行带参数的-git-pull\"><a href=\"#%E5%88%A9%E7%94%A8-xargs-%E6%89%A7%E8%A1%8C%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84-git-pull\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>利用 <code class=\"language-text\">xargs</code> 执行带参数的 <code class=\"language-text\">git pull</code></h3>\n<p>上一步，我们已经提取出来所有包含 <code class=\"language-text\">.git</code> 的文件夹，现在我们需要批量的执行 <code class=\"language-text\">git pull</code> 来统一拉取仓库。</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">xargs</span> <span class=\"token parameter variable\">-I</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token function\">git</span> <span class=\"token parameter variable\">-C</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> pull</code></pre>\n<p>由于 <code class=\"language-text\">git</code> 并不支持传入目录等参数，因此我们需要借助于 <code class=\"language-text\">xargs</code> 来给 <code class=\"language-text\">git</code> 传入拉取路径。上面的命令简明易懂，就相当于 <code class=\"language-text\">xargs</code> 告诉 <code class=\"language-text\">git</code> 拉取以上目录下的全部 Git 仓库。我们来看一看效果：</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-214839-2.gif\" alt=\"脚本效果\"><figcaption>脚本效果</figcaption></figure>\n<p>b(￣▽￣)d 👍 成功~</p>\n<h2 id=\"-references\"><a href=\"#-references\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>📚 References</h2>\n<ul>\n<li><a href=\"https://medium.com/@codenameyau/updating-multiple-repos-with-one-command-9768c8cdfe46\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Updating Multiple Repos With One Command</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2019/08/xargs-tutorial.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">xargs 命令教程</a></li>\n</ul>\n"}}]}}},"context":{}}