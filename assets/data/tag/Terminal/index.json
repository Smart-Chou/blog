{"hash":"1a485f6dceb298c3ce36b831edab4aa62783906c","data":{"tag":{"title":"Terminal","belongsTo":{"edges":[{"node":{"title":"Yadm：我是如何同步并管理我的 Dotfiles 的？","path":"/2020/07/how-i-manage-my-dotfiles/","date":"July 24. 2020","timeToRead":13,"cjkWordCount":3019,"cjkReadTime":14,"description":"Yet Another Dotfiles Manager，基于 Git 的 Dotfiles 管理器。","content":"<p>没想到啊，<a href=\"https://github.com/spencerwooo/dotfiles\" title=\"我的 dotfiles 仓库\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">我的 dotfiles 仓库</a>竟然是目前我 GitHub 上面星星数量最多的单仓库。</p>\n<p>Dotfiles 顾名思义，就是我们在使用软件的时候，软件为了存储我们个人偏好设置而建立的一个以 <code class=\"language-text\">.</code> 开头的文件。</p>\n<blockquote>\n<p>User-specific application configuration is traditionally stored in so called <strong><em>dotfiles.</em></strong> <sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup></p>\n</blockquote>\n<p>比如，编辑器 Vim 有 <code class=\"language-text\">.vimrc</code>，常用的 Zsh、Bash 等 Shell 分别有 <code class=\"language-text\">.zshrc</code>、<code class=\"language-text\">.bashrc</code> 等等。另外，广义的 dotfiles 也包括 <code class=\"language-text\">JSON</code>、<code class=\"language-text\">TOML</code> 等常规配置文件（当然也包含 Neovim 的 <code class=\"language-text\">init.vim</code> 等等）。总之，这么多的 dotfiles 都是我们第一次配置安装好系统、软件之后存在于我们电脑上面的个性化配置文件。但是这些 dotfiles 往往都只存在于我们电脑上独一份，一旦重置系统、更新换代，新电脑上就有需要重新配置一遍所有的 dotfiles 才能还原我们原本的设置。手动配置这些内容一想就非常繁琐，为了最快让新电脑能够用上我们熟悉的工具和配置，也为了对我们自己的配置进行版本控制，我们需要用工具来管理我们的 dotfiles。</p>\n<h2 id=\"用-git-的思想来管理-dotfiles\"><a href=\"#%E7%94%A8-git-%E7%9A%84%E6%80%9D%E6%83%B3%E6%9D%A5%E7%AE%A1%E7%90%86-dotfiles\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>用 Git 的思想来管理 dotfiles</h2>\n<p>如果说要管理 dotfiles，我的第一反应就是用 Git 来管理，<strong>毕竟专业的版本控制工具，用来管理纯文本文件的修改和同步再合适不过了。</strong>现在前面提到的那个星星数量最多的 repo 就是我最初用 Git 来将我的 dotfiles 集合到一个 GitHub 仓库里面时所做的尝试。那个仓库现在来看其实比较混乱，由于是一个标准的 Git 仓库，所有的文件都在当前文件夹下，因此为了三个系统的 dotfiles 都同步于一个仓库里，我建立了三个不同的文件夹：macOS、Windows 和 Linux。同时我也得手动将我本地的实际修改复制粘贴到这一 dotfiles 仓库之中。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200724-173035.png\" alt=\"我之前利用 Git 手动同步的 Dotfiles 仓库\"><figcaption>我之前利用 Git 手动同步的 Dotfiles 仓库</figcaption></figure>\n<p>那么这样管理的弊端显而易见：这一仓库仅仅算是「一个配置参考」，<strong>而非实际意义上的 portable dotfiles repository。</strong>多机同步靠粘贴，版本控制靠脑袋，有时候我的工具或者配置更换了，只能徒手把原来的配置移动到 <code class=\"language-text\">/archive</code> 文件夹下……这样管理一点也不优雅！如果我们可以直接在每个 dotfile 所在的原本位置就将其签入 Git 系统进行版本控制和远程同步就好了。🎈</p>\n<h2 id=\"yet-another-dotfiles-manager\"><a href=\"#yet-another-dotfiles-manager\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Yet Another Dotfiles Manager</h2>\n<p><code class=\"language-text\">yadm</code> —— Yet Another Dotfiles Manager，恰好就是为管理 dotfiles 而生的一个工具。利用 <code class=\"language-text\">yadm</code>，我们可以在每个 dotfile 的原始位置，用超出原生 Git 所支持的功能，来任意的管理、同步我们的 dotfiles。</p>\n<ul>\n<li><code class=\"language-text\">yadm</code> 的官方 GitHub 地址位于：<a href=\"https://github.com/TheLocehiliosan/yadm\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">TheLocehiliosan/yadm</a></li>\n<li><code class=\"language-text\">yadm</code> 的官方介绍于文档位于：<a href=\"https://yadm.io/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Yet Another Dotfiles Manager</a></li>\n</ul>\n<p>首先，实际上 <code class=\"language-text\">yadm</code> 的底层依旧是 Git，也就是说，我们在用 <code class=\"language-text\">yadm</code> 管理 dotfiles 的时候，实际上依旧是用 Git 来进行版本控制、远程同步等等操作的。但是，<code class=\"language-text\">yadm</code> 在 Git 的基础之上，进行了合理的功能拓展：<code class=\"language-text\">yadm</code> 能够让我们不必被一个 Git 仓库文件夹所限制，不必将 <code class=\"language-text\">$HOME</code> 目录下的全部非相关文件放入 <code class=\"language-text\">.gitignore</code>，能够直接管理同步 dotfile 文件。</p>\n<p>总之，如果我们使用 <code class=\"language-text\">yadm</code> 而不是直接用 Git 来管理 dotfiles 的话：</p>\n<ul>\n<li>我们不必关心当前目录是否是 Git 目录（非 Git 初始化的目录原版 Git 是拒绝工作的：<code class=\"language-text\">fatal: not a git repository</code>）；</li>\n<li>我们不必将原 dotfile 的位置进行移动，也不必将原 dotfile 通过软链接 symlink 到其他位置来统一管理；</li>\n<li>但我们依旧可以直接使用 Git 的全部功力，包括 Git 分支、merge、rebase、使用 submodules 等等；</li>\n</ul>\n<p>不过，<code class=\"language-text\">yadm</code> 是一个 *NIX 工具，如果你使用 macOS 或者 Linux，那么没问题，你可以直接用 <code class=\"language-text\">yadm</code> 管理 dotfiles；但是如果你用 Windows，那么很遗憾，<code class=\"language-text\">yadm</code> 只能在 WSL 里面进行安装。（不过没事！还是有解决办法的！）</p>\n<h2 id=\"用-yadm-管理同步并自动部署-dotfiles\"><a href=\"#%E7%94%A8-yadm-%E7%AE%A1%E7%90%86%E5%90%8C%E6%AD%A5%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2-dotfiles\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>用 yadm 管理、同步并自动部署 dotfiles</h2>\n<p>到这里，我们终于正式开始用 <code class=\"language-text\">yadm</code> 管理同步 dotfiles 了。首先，如果你还没有安装，那么根据你使用的操作系统，先<a href=\"https://yadm.io/docs/install\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">按照官方安装文档</a>安装 <code class=\"language-text\">yadm</code>。接下来，我按照「我已经有大量 dotfiles，但是还没有统一进行系统管理」的情况，来简单介绍 <code class=\"language-text\">yadm</code> 的使用和功能。</p>\n<h3 id=\"用-github-仓库同步-dotfiles-文件\"><a href=\"#%E7%94%A8-github-%E4%BB%93%E5%BA%93%E5%90%8C%E6%AD%A5-dotfiles-%E6%96%87%E4%BB%B6\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>用 GitHub 仓库同步 dotfiles 文件</h3>\n<p>第一步，在 GitHub 上创建一个<strong>空的私有仓库</strong>（建议除非特别自信，还是用私有仓库比较保险），用作我们整个系统 dotfiles 的同步仓库。</p>\n<div class=\"admonition admonition-caution\"><div class=\"admonition-heading\"><h5><div class=\"admonition-icon\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z\"></path></svg></div>🍌 注意</h5></div><div class=\"admonition-content\"><p>建议这里如果是从头开始，<strong>直接创建完全空白，不带 README 或 LICENSE 的仓库为宜。</strong></p></div></div>\n<p>之后，在我们的根目录（即 <code class=\"language-text\">~/</code>、<code class=\"language-text\">$HOME</code>）下，直接初始化 <code class=\"language-text\">yadm</code> 仓库并添加我们需要管理的 dotfile 文件：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># 初始化 yadm 仓库（在哪里都一样噢！）</span>\nyadm init\n\n<span class=\"token comment\"># 用 yadm 添加 dotfile 文件至仓库</span>\nyadm <span class=\"token function\">add</span> <span class=\"token operator\">&lt;</span>某个 dotfile 文件<span class=\"token operator\">></span>\n\n<span class=\"token comment\"># 继续添加……</span>\n\n<span class=\"token comment\"># 最后，将添加好的 dotfile 签入 Git</span>\nyadm commit <span class=\"token parameter variable\">-m</span> <span class=\"token string\">\"&lt;写个 commit 信息>\"</span></code></pre>\n<p>这样，本地的 <code class=\"language-text\">yadm</code> 仓库就已经用 Git 存储好了我们 dotfile 文件的全部信息，以及最重要的：相对于 <code class=\"language-text\">$HOME</code> 的文件路径（实际上就是绝对路径）。接下来，我们将本地仓库跟刚刚 GitHub 上面创建好的远程仓库进行关联，并将本地更新推送至远程：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">yadm remote <span class=\"token function\">add</span> origin <span class=\"token operator\">&lt;</span>刚刚建立的 GitHub 远程仓库地址<span class=\"token operator\">></span>\nyadm push <span class=\"token parameter variable\">-u</span> origin master</code></pre>\n<p>至此，我们就像平日里用 Git 一样将我们分散在系统各个地方的 dotfiles 统一签入了 <code class=\"language-text\">yadm</code> 管理的「专属 dotfiles 仓库」里面。我们也可以直接将 <code class=\"language-text\">yadm</code> 理解成一个在任意目录下都可以直接使用的 dotfiles 专属 Git 版本控制工具。用 <code class=\"language-text\">yadm list</code> 可以看到我们使用 <code class=\"language-text\">yadm</code> 管理的全部 dotfiles 列表，当然，<code class=\"language-text\">yadm status</code> 跟 <code class=\"language-text\">git status</code> 一样可以查看每个 dotfile 文件的修改情况。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200724-202658.png\" alt=\"命令：yadm list 和 yadm status\"><figcaption>命令：yadm list 和 yadm status</figcaption></figure>\n<h3 id=\"借助-yadm-的-bootstrap-功能自动配置环境\"><a href=\"#%E5%80%9F%E5%8A%A9-yadm-%E7%9A%84-bootstrap-%E5%8A%9F%E8%83%BD%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>借助 yadm 的 bootstrap 功能自动配置环境</h3>\n<p>很多情况下，光用 <code class=\"language-text\">yadm</code> 将 dotfiles 同步到本地是不够的，拿到新电脑我们还得安装许多工具。这时候，我们即可借助 <code class=\"language-text\">yadm</code> 的 bootstrap 功能，自动将任务脚本的执行 hook 在 <code class=\"language-text\">yadm</code> 克隆之后，完成环境的全自动部署。不过，<code class=\"language-text\">yadm</code> 的 bootstrap 脚本是需要我们自己撰写的，默认位于 <code class=\"language-text\">$HOME/.config/yadm/bootstrap</code>，这里不论是 Bash 脚本、Python 脚本还是什么别的，只要是可执行文件就可以。</p>\n<p>这里我给我自己简单写了一个 Bash 脚本，自动安装 Zsh、<a href=\"https://github.com/zplug/zplug\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">zplug</a> 和 Neovim 三个软件 / 插件。具体代码如下：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/sh</span>\n\n<span class=\"token assign-left variable\">system_type</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">uname</span> <span class=\"token parameter variable\">-s</span><span class=\"token variable\">)</span></span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token string\">\"<span class=\"token variable\">$system_type</span>\"</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"Linux\"</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n  <span class=\"token comment\"># install zsh, zplug, neovim</span>\n  <span class=\"token keyword\">if</span> <span class=\"token operator\">!</span> <span class=\"token builtin class-name\">command</span> <span class=\"token parameter variable\">-v</span> <span class=\"token function\">zsh</span> <span class=\"token operator\">></span> /dev/null <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span><span class=\"token file-descriptor important\">&amp;1</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Installing zsh...\"</span>\n    <span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> <span class=\"token function\">install</span> <span class=\"token function\">zsh</span>\n  <span class=\"token keyword\">elif</span> <span class=\"token punctuation\">[</span> <span class=\"token operator\">!</span> <span class=\"token parameter variable\">-f</span> <span class=\"token variable\">${<span class=\"token environment constant\">HOME</span>}</span>/.zplug/init.zsh <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Installing zplug...\"</span>\n    <span class=\"token function\">curl</span> <span class=\"token parameter variable\">-sL</span> --proto-redir -all,https https://cdn.jsdelivr.net/gh/zplug/installer/installer.zsh <span class=\"token operator\">|</span> <span class=\"token function\">zsh</span>\n  <span class=\"token keyword\">elif</span> <span class=\"token operator\">!</span> <span class=\"token builtin class-name\">command</span> <span class=\"token parameter variable\">-v</span> nvim <span class=\"token operator\">></span> /dev/null <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span><span class=\"token file-descriptor important\">&amp;1</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Installing neovim...\"</span>\n    <span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> <span class=\"token function\">install</span> neovim\n    <span class=\"token comment\"># sudo apt install python-neovim</span>\n    <span class=\"token comment\"># sudo apt install python3-neovim</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Installing neovim plugins with vim-plug...\"</span>\n    nvim <span class=\"token string\">\"+PlugUpdate\"</span> <span class=\"token string\">\"+PlugClean!\"</span> <span class=\"token string\">\"+PlugUpdate\"</span> <span class=\"token string\">\"+qall\"</span>\n  <span class=\"token keyword\">else</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"All packages are installed.\"</span>\n  <span class=\"token keyword\">fi</span>\n<span class=\"token keyword\">fi</span></code></pre>\n<p>这里必须注意的是：</p>\n<ul>\n<li>我们所编写的自动 bootstrap 脚本最好是「幂等」的，简单来讲就是有对软件当前存在状态的检测，以免发生重复安装、覆盖原始配置的问题；</li>\n<li>我们最好先对当前操作系统进行检测，比如 macOS 和 Linux 实际上环境有很大不同，需要区别处理；</li>\n</ul>\n<p>我们可以用 <code class=\"language-text\">yadm bootstrap</code> 命令来手动执行与测试这一脚本。当然，我们编写的 bootstrap 可执行文件，同样可以用 <code class=\"language-text\">yadm</code> 签入并进行同步，和普通 dotfile 文件一样处理即可。</p>\n<p>更多有关 <code class=\"language-text\">yadm</code> 的 bootstrap 功能请参考：<a href=\"https://yadm.io/docs/bootstrap\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">yadm Docs - Bootstrap</a>.</p>\n<h3 id=\"其他功能\"><a href=\"#%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>其他功能</h3>\n<p>除了上面简单的 dotfiles 同步与版本管理、bootstrap 自动环境部署等功能外，<code class=\"language-text\">yadm</code> 还可以：</p>\n<ul>\n<li>对敏感文件（比如 SSH 密钥、SSH <code class=\"language-text\">config</code> 文件……）进行加密、解密，提供私有仓库以外的额外一层保护：<a href=\"https://yadm.io/docs/encryption\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">yadm Docs - Encryption</a>；</li>\n<li>针对不同的操作系统、不同的环境以及不同的电脑维护不同种类的同一软件 / 插件的 dotfile 文件：<a href=\"https://yadm.io/docs/alternates\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">yadm Docs - Alternate Files</a>、<a href=\"https://yadm.io/docs/templates\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">yadm Docs - Templates</a>；</li>\n</ul>\n<p>这两个功能我还有待体验与开发，有兴趣的同学可以前往官方文档进行研究使用。</p>\n<h2 id=\"faq\"><a href=\"#faq\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>FAQ</h2>\n<h3 id=\"但是我想让-yadm-管理-home-以外的文件怎么办\"><a href=\"#%E4%BD%86%E6%98%AF%E6%88%91%E6%83%B3%E8%AE%A9-yadm-%E7%AE%A1%E7%90%86-home-%E4%BB%A5%E5%A4%96%E7%9A%84%E6%96%87%E4%BB%B6%E6%80%8E%E4%B9%88%E5%8A%9E\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>但是我想让 yadm 管理 <code class=\"language-text\">$HOME</code> 以外的文件怎么办？</h3>\n<p>前面的表述中，我们可能已经发现了，<code class=\"language-text\">yadm</code> 默认情况下仅管理 <code class=\"language-text\">$HOME</code> 目录下的文件，也就是我们个人用户的文件。<code class=\"language-text\">yadm</code> 不会去管理系统文件，比如 <code class=\"language-text\">/etc</code>、<code class=\"language-text\">/mnt</code> 下的文件。这里的 <code class=\"language-text\">$HOME</code> 实际上就是 <code class=\"language-text\">yadm</code> 的默认工作树，其真实文件路径位于 <code class=\"language-text\">/home/&lt;你的用户名&gt;</code>，<code class=\"language-text\">yadm</code> 也「根据设计」仅管理这一目录下的文件，而大部分情况下这也是完全合理、够用的。</p>\n<p>但是，如果我们想要继续管理 <code class=\"language-text\">/home/xxx</code> 以外地方的文件，那么我们需要「扩大文件树的范围」，或者「选择使用其他目录作为主文件树」。首先，其他地方的文件 <code class=\"language-text\">yadm</code> 很可能没有读写权限，所以我们需要先设置一个专门用来管理系统文件的 <code class=\"language-text\">yadm</code> alias 命令：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># 使用 /etc/yadm 作为 yadm 系统文件管理的目录</span>\n<span class=\"token builtin class-name\">alias</span> <span class=\"token assign-left variable\">sysyadm</span><span class=\"token operator\">=</span><span class=\"token string\">\"sudo yadm -Y /etc/yadm\"</span></code></pre>\n<p>之后，我们可以直接使用 <code class=\"language-text\">sysyadm</code> 命令，并使用一个单独的远程仓库，来单独管理系统文件：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># 将 / 目录初始化为 sysyadm 的文件树</span>\nsysyadm init <span class=\"token parameter variable\">-w</span> /\n\n<span class=\"token comment\"># 和 yadm 一样，添加文件、签入版本控制系统、同步远程仓库</span>\nsysyadm <span class=\"token function\">add</span> <span class=\"token operator\">&lt;</span>某个 / 路径下的系统文件<span class=\"token operator\">></span>\nsysyadm commit <span class=\"token parameter variable\">-m</span> <span class=\"token string\">\"&lt;啊，我签入了一个系统文件耶>\"</span>\n<span class=\"token comment\"># ……</span></code></pre>\n<p>当然，你仅使用 <code class=\"language-text\">sysyadm</code> 管理整个系统里面的全部 dotfiles 也可以，但是你可能每次都需要申请 sudo 权限，不太优雅。</p>\n<p>更多使用细节请见：<a href=\"https://yadm.io/docs/faq#unconventional-cases\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">yadm Docs - FAQ #Unconventional Cases</a>.</p>\n<h3 id=\"我们这些-windows-用户怎么办\"><a href=\"#%E6%88%91%E4%BB%AC%E8%BF%99%E4%BA%9B-windows-%E7%94%A8%E6%88%B7%E6%80%8E%E4%B9%88%E5%8A%9E\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>我们这些 Windows 用户怎么办？</h3>\n<p>什么时候我们 Windows 用户才能站起来！气抖冷。</p>\n<p>实际上，如果你像我一样使用 WSL，那么我们用上文的方法其实也可以直接进行 Windows 的 dotfiles 管理。在 WSL 环境下，我们 <code class=\"language-text\">yadm</code> 拿到的 Windows 文件一般位于 <code class=\"language-text\">/mnt/c/Users/&lt;你的用户名&gt;</code> 里面。因此，这一情况需要我们将 <code class=\"language-text\">yadm</code> 的工作树设定在 <code class=\"language-text\">/</code> 或 <code class=\"language-text\">/mnt</code> 目录下，才可以有效管理 Windows 文件。</p>\n<p>但是，我还是觉得有点别扭，特别是当我需要给 <code class=\"language-text\">yadm</code> 权限直接管理整个 <code class=\"language-text\">/</code> 目录下的文件的时候。因此，为了方便（并不方便），我还是在 WSL 的 <code class=\"language-text\">$HOME</code> 里面创建了一个 <code class=\"language-text\">~/Dotfiles/Windows</code> 目录，用传统办法，手动复制粘贴 Windows 里面的 dotfiles 作为「配置文件参考」。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200724-211554.png\" alt=\"在 WSL 里面手动管理 Windows 中的 Dotfiles\"><figcaption>在 WSL 里面手动管理 Windows 中的 Dotfiles</figcaption></figure>\n<p>当然，还好 Windows 需要同步的文件不算太复杂，而且主要为了同步一下 Windows Terminal 的自定义图标，还好还好。</p>\n<h2 id=\"小结\"><a href=\"#%E5%B0%8F%E7%BB%93\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>小结</h2>\n<p>说到这里，我其实发现自己已经算是不太管曾经那个用笨方法管理的 <a href=\"https://github.com/spencerwooo/dotfiles\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">spencerwooo/dotfiles</a> 仓库了，即使标星的人那么多。（啊这，写着写着还发现<a href=\"https://github.com/spencerwooo/dotfiles/issues/9\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">有个老哥发了个 issue</a>，人傻了。）好了，本文到这里就结束啦，感谢阅读。(＠_＠;)</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">\n<p><a href=\"https://wiki.archlinux.org/index.php/Dotfiles\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://wiki.archlinux.org/index.php/Dotfiles</a></p>\n<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a>\n</li>\n</ol>\n</div>\n"}},{"node":{"title":"「输出」开销：为什么我们向 stdout 输出时那么慢？","path":"/2020/02/stdout-overhead/","date":"February 22. 2020","timeToRead":7,"cjkWordCount":1230,"cjkReadTime":6,"description":"Console output overhead: why is writing to stdout so slow?","content":"<blockquote>\n<p>本文发布于 Medium: <a href=\"https://medium.com/spencerweekly/console-output-overhead-why-is-writing-to-stdout-so-slow-b0cc7c88704c\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Console output overhead: why is writing to stdout so slow?</a></p>\n</blockquote>\n<p>Generally, when we code through our projects, we need to output certain values in order to understand what the program is currently doing and what results it shows. Normally we do this with a simple print function:</p>\n<pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Hey look, this is the result.'</span><span class=\"token punctuation\">)</span></code></pre>\n<p>And for most of our use cases, this would be more than enough. However, when we are outputting a huge amount of data, like printing a file with 10k lines of text onto the terminal, we will eventually suffer from IO bottlenecks. This is something I discovered when trying to find a nice progress bar library for PyTorch in order to monitor the model’s training progress. Let me explain.</p>\n<h2 id=\"what-did-i-discover\"><a href=\"#what-did-i-discover\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>What did I discover?</h2>\n<p>Now, if you are familiar with modern neural network libraries, you may have heard of Keras. Keras is a highly encapsulated library that takes care of data output, model compilation, backward propaganda and more for you under the hood, meaning that it offers less agility than other low-level libraries like PyTorch. The one feature I really appreciate about Keras is its nice little training progress bar that shows the current training progress, iteration duration, ETA, loss and other relevant statistics. Below is an example.</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215810.png\" alt=\"Visualizing training progress with Keras\"><figcaption>Visualizing training progress with Keras</figcaption></figure>\n<p>However, PyTorch offers far more customizable features when it comes to designing, compiling and training your model, but it also means you have to take care of outputting progress, training details and others by yourself. This is when I discovered IO bottlenecks when outputting directly to <code class=\"language-text\">stdout</code>, that is, your terminal.</p>\n<p>The library I first tried is called <a href=\"https://github.com/yueyericardo/pkbar\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><strong>pkbar</strong> — a progress bar library intended to bring Keras style progress monitoring to the PyTorch ecosystem</a>. <strong>(Don’t use it!)</strong> It’s outputs are like this:</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215810-1.png\" alt=\"pkbar: Keras style progress bar for PyTorch\"><figcaption>pkbar: Keras style progress bar for PyTorch</figcaption></figure>\n<p>Most progress bar libraries are implemented by wrapping itself around an iterative object, in our case, a PyTorch Data Loader. When building a progress bar, we need to refresh our progress, statistics and other parameters on each iteration. This means every time we come to the end of an iteration, we need to output to our terminal with a delay when the program waits for the writing to return. This delay is often unnoticed when we are simply writing a single message, but when we are iterating through thousands of images, we need to write the latest status on each iteration. A small delay multiplied by a thousand iterations gives us a huge time difference, and results in bottlenecks we encounter now.</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215810-2.png\" alt=\"Each iteration comes with a time cost that adds up to be a huge delay\"><figcaption>Each iteration comes with a time cost that adds up to be a huge delay</figcaption></figure>\n<p>What happened to me when I was using pkbar was exactly what I described above: <strong>each iteration was accompanied with a delay which eventually builds up into a time difference I simply can’t ignore.</strong> To put numbers into perspective, I was applying a DeepFool adversarial attack on a pre-trained ResNet18 CNN. It took about 5 minutes on my laptop running on GPU without pkbar, and when I added pkbar to visualize progress, it gave me an ETA of nearly 20 minutes! Holy crap, I removed pkbar almost immediately.</p>\n<h2 id=\"so-why-were-there-delays\"><a href=\"#so-why-were-there-delays\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>So why were there delays?</h2>\n<p>In order to find out what was causing this huge delay and how we could avoid it, I turned for help on Stack Overflow. A particular question gave me the answer: <a href=\"https://stackoverflow.com/questions/3857052/why-is-printing-to-stdout-so-slow-can-it-be-sped-up\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Why is printing to stdout so slow? Can it be sped up?</a></p>\n<p>In this question, the author compared the following speeds:</p>\n<ul>\n<li>Writing output to the terminal, which is <code class=\"language-text\">stdout</code></li>\n<li>Writing output to a file</li>\n<li>Writing output to <code class=\"language-text\">stdout</code>, but with <code class=\"language-text\">stdout</code> redirected to <code class=\"language-text\">/dev/null</code></li>\n</ul>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215810-3.png\" alt=\"Time cost for printing to stdout, file and /dev/null\"><figcaption>Time cost for printing to stdout, file and /dev/null</figcaption></figure>\n<p>Wow, that shows a huge difference for printing to <code class=\"language-text\">stdout</code> and redirecting <code class=\"language-text\">stdout</code> to <code class=\"language-text\">/dev/null</code>. Even writing output to file is faster than directly writing to the terminal. So…, why?</p>\n<blockquote>\n<p>Congratulations, you have just discovered the importance of I/O buffering. :-)</p>\n</blockquote>\n<p>So it turns out that I/O buffering is what made even “writing to file” faster than “writing to <code class=\"language-text\">stdout</code>”. When we are directly writing outputs to our terminal, each writing operation is being done “synchronously”, which means our programs waits for the “write” to complete before it continues to the next commands.</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215810-4.png\" alt=\"Synchronous writing to stdout\"><figcaption>Synchronous writing to stdout</figcaption></figure>\n<p>Each time our programs writes something to <code class=\"language-text\">stdout</code>, we are met with this delay. However, writing to files are not of the same case. When we are writing to files, we have what is known as “I/O buffering”, which means the program outputs whatever it needs to write to the file, and the OS catches all these contents to write where it then stores in a file <strong>as a bulk</strong> afterwards. <strong>All our “write” functions return before anything is actually written to a file.</strong></p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215810-5.png\" alt=\"Buffered writing output to file\"><figcaption>Buffered writing output to file</figcaption></figure>\n<p>So what should we do here? Well, in order to avoid I/O overhead, we either have to do training and update output in parallel or asynchronously like we do in GUIs when we have an UI thread and a controller, or we will need to write in bulks to <code class=\"language-text\">stdout</code> like what we are doing when writing to files. <strong>It’s a trade-off: interactivity versus bulk efficiency.</strong></p>\n<h2 id=\"what-i-did-to-visualize-pytorch-training-with-minimum-overhead\"><a href=\"#what-i-did-to-visualize-pytorch-training-with-minimum-overhead\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>What I did to visualize PyTorch training with minimum overhead?</h2>\n<p>After I ditched pkbar, I found a perfect progress bar library: <a href=\"https://github.com/tqdm/tqdm\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">tqdm — A Fast, Extensible Progress Bar for Python and CLI</a>. With over 13.4k+ stars, <code class=\"language-text\">tqdm</code> is easily the best Python library for us to implement training progress visualization.</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215810-6.png\" alt=\"tqdm in action\"><figcaption>tqdm in action</figcaption></figure>\n<p><code class=\"language-text\">tqdm</code> is simple, efficient and comes with minimal overhead. The author claims that <code class=\"language-text\">tqdm</code> only delays output for a minimum of 60ns per iteration. That’s impressive. In addition to its low overhead, <code class=\"language-text\">tqdm</code> uses smart algorithms to predict the remaining time and to skip unnecessary iteration displays, which allows for a negligible overhead in most cases.</p>\n<h3 id=\"installation\"><a href=\"#installation\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Installation</h3>\n<p>Either install <code class=\"language-text\">tqdm</code> using conda directly:</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">conda <span class=\"token function\">install</span> <span class=\"token parameter variable\">-c</span> conda-forge tqdm</code></pre>\n<p>And install <code class=\"language-text\">ipywidgets</code> with pip to enable Jupyter Notebook integration:</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">pip <span class=\"token function\">install</span> ipywidgets</code></pre>\n<p>Or integrate the following code to your <code class=\"language-text\">environment.yml</code>:</p>\n<pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">channels</span><span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">-</span> conda<span class=\"token punctuation\">-</span>forge\n  <span class=\"token punctuation\">-</span> defaults\n<span class=\"token key atrule\">dependencies</span><span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">-</span> tqdm\n  <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">pip</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> ipywidgets</code></pre>\n<p>Then run:</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">conda <span class=\"token function\">env</span> update</code></pre>\n<h3 id=\"integration\"><a href=\"#integration\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Integration</h3>\n<p>We can easily integrate <code class=\"language-text\">tqdm</code> into our PyTorch project. Basically what you need to do is just to wrap <code class=\"language-text\">tqdm</code> on an iterable object, and that’s it.</p>\n<pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> tqdm <span class=\"token keyword\">import</span> tqdm\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> tqdm<span class=\"token punctuation\">(</span><span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">10000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></code></pre>\n<pre class=\"language-text\"><code class=\"language-text\">76%|████████████████████████████ | 7568/10000 [00:33&lt;00:10, 229.00it/s]</code></pre>\n<p>For PyTorch <code class=\"language-text\">DataLoader</code>, we can first load our data like so:</p>\n<pre class=\"language-python\"><code class=\"language-python\">dataset_loader <span class=\"token operator\">=</span> torch<span class=\"token punctuation\">.</span>utils<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>DataLoader<span class=\"token punctuation\">(</span>dataset<span class=\"token punctuation\">,</span> batch_size<span class=\"token operator\">=</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span></code></pre>\n<p>Then initialize <code class=\"language-text\">tdqm</code>:</p>\n<pre class=\"language-python\"><code class=\"language-python\">pbar <span class=\"token operator\">=</span> tqdm<span class=\"token punctuation\">(</span>dataset_loader<span class=\"token punctuation\">)</span></code></pre>\n<p>Here, we can add the description of the progress bar:</p>\n<pre class=\"language-python\"><code class=\"language-python\">pbar<span class=\"token punctuation\">.</span>set_description<span class=\"token punctuation\">(</span><span class=\"token string\">'Validate predictions'</span><span class=\"token punctuation\">)</span></code></pre>\n<p>Also, we can initialize the post-fix dict for the progress bar, so that we can update the post-fix on the fly:</p>\n<pre class=\"language-python\"><code class=\"language-python\">pbar<span class=\"token punctuation\">.</span>set_postfix<span class=\"token punctuation\">(</span>loss<span class=\"token operator\">=</span><span class=\"token string\">'0.0%'</span><span class=\"token punctuation\">,</span> acc<span class=\"token operator\">=</span><span class=\"token string\">'0.0%'</span><span class=\"token punctuation\">)</span></code></pre>\n<p>And Voilà! We can directly iterate through <code class=\"language-text\">tdqm</code>, just like we did with PyTorch <code class=\"language-text\">DataLoader</code>. (My model is wrapped with Foolbox, so I can make predictions with the <code class=\"language-text\">.forward()</code> function.)</p>\n<pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">for</span> image<span class=\"token punctuation\">,</span> label <span class=\"token keyword\">in</span> pbar<span class=\"token punctuation\">:</span>\n  <span class=\"token comment\"># make a prediction</span>\n  prob <span class=\"token operator\">=</span> model<span class=\"token punctuation\">.</span>forward<span class=\"token punctuation\">(</span>image<span class=\"token punctuation\">.</span>numpy<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>  <span class=\"token comment\"># calculate and update loss</span>\n  pbar<span class=\"token punctuation\">.</span>set_postfix<span class=\"token punctuation\">(</span>loss<span class=\"token operator\">=</span><span class=\"token string\">'{:.2f}%'</span><span class=\"token punctuation\">.</span><span class=\"token builtin\">format</span><span class=\"token punctuation\">(</span>loss<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token comment\"># calculate and update accuracy</span>\n  pbar<span class=\"token punctuation\">.</span>set_postfix<span class=\"token punctuation\">(</span>acc<span class=\"token operator\">=</span><span class=\"token string\">'{:.2f}%'</span><span class=\"token punctuation\">.</span><span class=\"token builtin\">format</span><span class=\"token punctuation\">(</span>acc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre>\n<h3 id=\"features\"><a href=\"#features\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Features</h3>\n<p><code class=\"language-text\">tqdm</code> can be used directly in a CLI environment with no special configuration whatsoever.</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215810-7.gif\" alt=\"tqdm in a CLI enviroment\"><figcaption>tqdm in a CLI enviroment</figcaption></figure>\n<p>Also, we can run <code class=\"language-text\">tqdm</code> in VS Code’s Python Interactive console, or Jupyter Notebook. In this case, <code class=\"language-text\">tqdm</code> will output progress asynchronously according to the <a href=\"https://jupyter-notebook.readthedocs.io/en/stable/examples/Notebook/Running%20Code.html#Output-is-asynchronous\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Notebook API</a>.</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215810-8.gif\" alt=\"tqdm outputting inside Jupyter Notebook / VS Code Python Interactive\"><figcaption>tqdm outputting inside Jupyter Notebook / VS Code Python Interactive</figcaption></figure>\n<p>To kick it up a notch, we can actually output “real” progress bars. Utilizing <code class=\"language-text\">ipywidget</code>, we can directly draw interactive progress bars inside Jupyter Notebook. <a href=\"https://ipywidgets.readthedocs.io/en/latest/user_install.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">See here for instructions on how to enable </a><code class=\"language-text\">ipywidgets</code><a href=\"https://ipywidgets.readthedocs.io/en/latest/user_install.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">.</a></p>\n<p>After enabling these widgets inside Jupyter Notebook, all we have to do is change the way on how we imported <code class=\"language-text\">tqdm</code>. Change:</p>\n<pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> tqdm <span class=\"token keyword\">as</span> tqdm</code></pre>\n<p>To:</p>\n<pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> tqdm<span class=\"token punctuation\">.</span>notebook <span class=\"token keyword\">as</span> tqdm</code></pre>\n<p>Now, run the code once more, if everything goes well, we should be able to see a neat progress bar with colors indicating the current task’s state: pending, success or failure.</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215810-9.gif\" alt=\"tqdm integrating directly into Jupyter Notebook with ipywidgets - https://ipywidgets.readthedocs.io/en/latest\"><figcaption>tqdm integrating directly into Jupyter Notebook with ipywidgets - https://ipywidgets.readthedocs.io/en/latest</figcaption></figure>\n<hr>\n<p>This is the end of the article, for more information on how to utilize <code class=\"language-text\">tqdm</code>, I recommend this article: <a href=\"https://medium.com/better-programming/python-progress-bars-with-tqdm-by-example-ce98dbbc9697\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Python Progress Bars with tqdm by Example</a>. Also, the official documentation of <code class=\"language-text\">tqdm</code> is quite thorough, covering most cases when using <code class=\"language-text\">tqdm</code>.</p>\n<p>There’s one thing to note, and that is: you should not use “print” to output anything when a <code class=\"language-text\">tqdm</code> progress bar is running, as this behavior will mess up the <code class=\"language-text\">tqdm</code> output. If you have to write something, do remember to use:</p>\n<pre class=\"language-python\"><code class=\"language-python\">tqdm<span class=\"token punctuation\">.</span>write<span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span>context<span class=\"token operator\">></span><span class=\"token punctuation\">)</span></code></pre>\n<p>That’s all, thanks for reading.</p>\n"}}]}}},"context":{}}