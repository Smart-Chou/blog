{"hash":"adc5dd754921ba01e034b10e05b52eb94e7d1500","data":{"tag":{"title":"CLI","belongsTo":{"edges":[{"node":{"title":"Quit using nvm：快删掉这个占据 Zsh 启动时间一半的怪物！","path":"/2020/07/remove-nvm-to-speed-up-zsh/","date":"July 28. 2020","timeToRead":10,"cjkWordCount":2480,"cjkReadTime":11,"description":"没想到啊 nvm，竟然是你这个浓眉大眼的让我 Zsh 开一次足足等 2 秒！","content":"<blockquote>\n<p>✍ Sept 5. 2020 的更新：</p>\n</blockquote>\n<p>今天尝试了一下 <a href=\"https://github.com/zdharma/zinit\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">zinit</a>，这个作者跟 Powerlevel10k 的想法非常类似，都是对 Zsh 的插件进行懒加载，导致其 Turbo mode 加载 Zsh 速度快的飞起！</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/09/200905_212629.png\" alt=\"使用 zinit 加载插件，启动时间仅需 0.6s，但实际上打开瞬间 Zsh 就已经可以交互了\"><figcaption>使用 zinit 加载插件，启动时间仅需 0.6s，但实际上打开瞬间 Zsh 就已经可以交互了</figcaption></figure>\n<p>另外，看到 <code class=\"language-text\">zplug</code> 的 GitHub 上一次提交时间还是今年 2 月份，而且 issue 区已经出现寻找 Maintainer 的请求了，而 <code class=\"language-text\">zinit</code> 最近更新得非常频繁，因此这里推荐大家使用 <code class=\"language-text\">zinit</code> 作为 Zsh 的插件管理器。</p>\n<hr>\n<blockquote>\n<p>🍳 July 28. 2020 的原文章：</p>\n</blockquote>\n<p>我实在是受不了了。我这 10 代 i7 的顶配 ThinkPad 在 WSL 2 里面打开一个 Shell，竟然每次都需要在心里面默念 2 个数才能敲进去字。淦啊 (╬▔皿▔)╯</p>\n<h2 id=\"我管理-zsh-配置的方法\"><a href=\"#%E6%88%91%E7%AE%A1%E7%90%86-zsh-%E9%85%8D%E7%BD%AE%E7%9A%84%E6%96%B9%E6%B3%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>我管理 Zsh 配置的方法</h2>\n<p>对了，得先跟大家说说，我还在用 Zsh，但是我丢掉了 Oh My Zsh 这个好像大家都在用的 Zsh 框架，转而使用更加灵活的 <a href=\"https://github.com/zplug/zplug\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">zplug</a> 来管理我的 Zsh 配置。如果你用 Vim 和 <code class=\"language-text\">vim-plug</code>，那么 <code class=\"language-text\">zplug</code> 用起来的感觉将非常熟悉：<code class=\"language-text\">zplug</code> 跟 <code class=\"language-text\">vim-plug</code> 的设计风格就非常相似。当然，<code class=\"language-text\">zplug</code> 最吸引我的一点还是「高度的可自定义」。不像 Oh My Zsh 把 Zsh 所有配置都为我们设定好了，<code class=\"language-text\">zplug</code> 支持用「插件」的方式安装、配置 Zsh 的各项功能，甚至可以像安装插件一样安装 Oh My Zsh 的部分功能。</p>\n<p>比如，Oh My Zsh 的 Git 插件和预设 alias 们就很好用啊，那我直接就能用 <code class=\"language-text\">zplug</code> 装上：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">zplug <span class=\"token string\">\"plugins/git\"</span>, from:oh-my-zsh\nzplug <span class=\"token string\">\"plugins/common-aliases\"</span>, from:oh-my-zsh</code></pre>\n<p>自动补全 <code class=\"language-text\">zsh-completions</code> 和类似 Fish shell 的自动命令建议 <code class=\"language-text\">zsh-auto-suggestions</code> 也非常有用啊，那我也立刻拿 <code class=\"language-text\">zplug</code> 装上：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">zplug <span class=\"token string\">\"zsh-users/zsh-completions\"</span>\nzplug <span class=\"token string\">\"zsh-users/zsh-autosuggestions\"</span></code></pre>\n<p>可以看到，<code class=\"language-text\">zplug</code> 胜在灵活，自定义程度高，所以我才舍 Oh My Zsh 而取 <code class=\"language-text\">zplug</code>。另外，<code class=\"language-text\">zplug</code> 还支持 parallel update，这点也非常讨我欢心：</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200727-221325.gif\" alt=\"zplug update 支持多个插件同时并行更新\"><figcaption>zplug update 支持多个插件同时并行更新</figcaption></figure>\n<p>好了，这篇文章不光是吹 <code class=\"language-text\">zplug</code> 多好，而是为了找到到底哪个混蛋在耽误我 Zsh 的启动速度。</p>\n<h2 id=\"对-zsh-启动时间进行测量\"><a href=\"#%E5%AF%B9-zsh-%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%B4%E8%BF%9B%E8%A1%8C%E6%B5%8B%E9%87%8F\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>对 Zsh 启动时间进行测量</h2>\n<p>为了定量的衡量 Zsh 的启动过程，我们先建立一个 baseline：测量在当前没有任何插件调整情况下 Zsh 的「冷启动」时间。</p>\n<p>我使用了下面的命令来测量 Zsh 启动时间：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">time</span> <span class=\"token function\">zsh</span> <span class=\"token parameter variable\">-i</span> <span class=\"token parameter variable\">-c</span> <span class=\"token builtin class-name\">exit</span></code></pre>\n<p>未经调整的 Zsh 启动时间数据如下：</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200727-221927.png\" alt=\"初始 Zsh 启动时间\"><figcaption>初始 Zsh 启动时间</figcaption></figure>\n<p>最后一行可以看到，总时间用了 1.93s，多次启动得到的数据类似，1.93s 也符合上面我人肉感知的「心中默念两个数」的时间。</p>\n<p>要知道，为了让 Zsh 更快的显示，我可是直接用上了 Powerlevel10k 这个地表最快，连作者都疯狂优化的 Zsh prompt 主题框架。用 Powerlevel10k 渲染的 Zsh prompt 显示速度可以说是优化到了极致，<a href=\"https://github.com/romkatv/powerlevel10k#uncompromising-performance\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><strong>提供 uncompromising performance</strong></a>。但是接近 2s 的冷启动时间还是令人难受，而这显然不是 Powerlevel10k 的锅。</p>\n<h2 id=\"深入评估-zsh-冷启动过程中的时间使用\"><a href=\"#%E6%B7%B1%E5%85%A5%E8%AF%84%E4%BC%B0-zsh-%E5%86%B7%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%97%B6%E9%97%B4%E4%BD%BF%E7%94%A8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>深入评估 Zsh 冷启动过程中的时间使用</h2>\n<p>经过一番搜索，我发现 Zsh 内部就有一个能够 benchmark 并 profile Zsh 自己启动过程时间使用的工具：<code class=\"language-text\">zprof</code>。如果你学过软件工程，你应该知道评价软件质量的一个重要工具：Profiler，用于衡量软件各个部分各个模块具体执行时间的评测工具。</p>\n<blockquote>\n<p>A <em>profile</em> is a set of statistics that describes how often and for how long various parts of the program executed. <sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup></p>\n</blockquote>\n<p>常见的语言环境都有原生的 Profiler，比如 Python 内置的 <code class=\"language-text\">cProfile</code>、Node.js 内置的功能 <code class=\"language-text\">node --prof</code>……部分 IDE 比如 Visual Studio 也有类似的工具，这些 Profiler 在优化软件的执行速度上起到了举足轻重的作用。</p>\n<p>我们用 <code class=\"language-text\">zprof</code> 来对 Zsh 进行 Profile 评估：</p>\n<ul>\n<li>在 <code class=\"language-text\">.zshrc</code> 的最开头新增一行并写入 <code class=\"language-text\">zmodload zsh/zprof</code>；</li>\n<li>在 <code class=\"language-text\">.zshrc</code> 文件末尾添加一行再写入 <code class=\"language-text\">zprof</code>；</li>\n<li>保存 <code class=\"language-text\">.zshrc</code> 再重启我们的 Zsh Shell（关闭再打开终端）；</li>\n</ul>\n<p>添加了 <code class=\"language-text\">zprof</code> 必要命令后，重新打开 Zsh 时 <code class=\"language-text\">zprof</code> 会开始自动对 Zsh 启动过程中各个过程所用时间进行测算，最终得到类似这样的报告：</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200727-224130.png\" alt=\"zprof 测量 Zsh 冷启动过程各个功能模块执行所用时间报告\"><figcaption>zprof 测量 Zsh 冷启动过程各个功能模块执行所用时间报告</figcaption></figure>\n<p>看前几行的 <code class=\"language-text\">nvm_die_on_prefix</code>、<code class=\"language-text\">nvm</code>、<code class=\"language-text\">nvm_auto</code> 和 <code class=\"language-text\">nvm_ensure_version_installed</code>，它们依次占用了 17.82%、16.34%、15.18% 和 4.80% 的启动时间，<code class=\"language-text\">nvm</code> 相关的模块一共占据了我 Zsh 启动时间的一半以上。原来是你，<code class=\"language-text\">nvm</code>！(ノ｀Д)ノ</p>\n<h2 id=\"删掉-nvm\"><a href=\"#%E5%88%A0%E6%8E%89-nvm\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>删掉 <code class=\"language-text\">nvm</code>？</h2>\n<p>显然，删掉 <code class=\"language-text\">nvm</code> 看起来应该是我们最显而易见、一劳永逸的解决方案，根据上面的数据，删掉 <code class=\"language-text\">nvm</code> 或者不让 <code class=\"language-text\">nvm</code> 在 Zsh 启动时加载大概率能节省一半的启动时间。后者被称为「懒加载」，也就是我们常说的 lazy loading。不过我 Node.js 环境用的还是挺多的，同时 <code class=\"language-text\">nvm</code> 也是出了名的慢，而 <code class=\"language-text\">nvm</code> 市面上的替代品还是挺多的，所以咱们先删掉再说。</p>\n<p><code class=\"language-text\">nvm</code> 实际上仅是一个帮我们管理 Node.js 版本的 Bash 脚本，<code class=\"language-text\">.zshrc</code> 中 <code class=\"language-text\">nvm</code> 相关的加载不多，只有这些：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">NVM_DIR</span><span class=\"token operator\">=</span><span class=\"token string\">\"<span class=\"token environment constant\">$HOME</span>/.nvm\"</span>\n<span class=\"token punctuation\">[</span> <span class=\"token parameter variable\">-s</span> <span class=\"token string\">\"<span class=\"token variable\">$NVM_DIR</span>/nvm.sh\"</span> <span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">\\</span>. <span class=\"token string\">\"<span class=\"token variable\">$NVM_DIR</span>/nvm.sh\"</span> <span class=\"token comment\"># This loads nvm</span>\n<span class=\"token punctuation\">[</span><span class=\"token punctuation\">[</span> <span class=\"token parameter variable\">-r</span> <span class=\"token variable\">$NVM_DIR</span>/bash_completion <span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token punctuation\">\\</span>. <span class=\"token variable\">$NVM_DIR</span>/bash_completion</code></pre>\n<p>将我 <code class=\"language-text\">.zshrc</code> 中加载 <code class=\"language-text\">nvm</code> 的这部分删掉后，重新对 Zsh 的冷启动时间进行测量，得到这样的结果：</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200727-221837.png\" alt=\"删除 nvm 优化后 Zsh 启动时间\"><figcaption>删除 nvm 优化后 Zsh 启动时间</figcaption></figure>\n<p>哟，直接降到 1s 以内了，跟我们设想预期完全一致。拜拜了您嘞 <code class=\"language-text\">nvm</code>！</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">rm</span> <span class=\"token parameter variable\">-rf</span> ~/.nvm</code></pre>\n<h2 id=\"那我后面用什么来管理安装-nodejs\"><a href=\"#%E9%82%A3%E6%88%91%E5%90%8E%E9%9D%A2%E7%94%A8%E4%BB%80%E4%B9%88%E6%9D%A5%E7%AE%A1%E7%90%86%E5%AE%89%E8%A3%85-nodejs\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>那我后面用什么来管理安装 Node.js？</h2>\n<p>好了，删掉了 <code class=\"language-text\">nvm</code>，我们后面用什么呢？这里我推荐一个设计更精良，安装更合理的 Node.js version manager：<a href=\"https://github.com/tj/n\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">n - Interactively Manage Your Node.js Versions</a>。基本的使用方法跟 <code class=\"language-text\">nvm</code> 其实非常相似，但是 <code class=\"language-text\">n</code> 不用往我们 <code class=\"language-text\">.zshrc</code> 里面加一些奇奇怪怪的执行命令，最多只需要一个 <code class=\"language-text\">N_PREFIX</code> 的环境变量来定义 <code class=\"language-text\">n</code> 安装目录。轻量简便，推荐使用！</p>\n<p>推荐大家用 <a href=\"https://github.com/mklement0/n-install\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">n-install</a> 来在 Linux 和 macOS 上安装 <code class=\"language-text\">n</code>：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">curl</span> <span class=\"token parameter variable\">-L</span> https://git.io/n-install <span class=\"token operator\">|</span> <span class=\"token function\">bash</span></code></pre>\n<p><code class=\"language-text\">n-install</code> 可以自动帮我们在 <code class=\"language-text\">$HOME</code> 文件夹下创建 <code class=\"language-text\">n</code> 所使用的安装目录，并将环境变量替我们设定完整，应该是目前为止最方便的 <code class=\"language-text\">n</code> 安装方法。</p>\n<div class=\"admonition admonition-important\"><div class=\"admonition-heading\"><h5><div class=\"admonition-icon\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"14\" height=\"16\" viewBox=\"0 0 14 16\"><path fill-rule=\"evenodd\" d=\"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z\"></path></svg></div>🎍 阅读更多</h5></div><div class=\"admonition-content\"><p>有关 <code class=\"language-text\">n-install</code> 的更多使用细节（包括安装、更新、卸载……）请参考 <code class=\"language-text\">n-install</code> 官方仓库：<a href=\"https://github.com/mklement0/n-install\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">mklement0/n-install</a>。</p></div></div>\n<p>安装成功 <code class=\"language-text\">n</code> 之后，我们就可以像往常一样，安装使用多个版本的 Node.js 啦。</p>\n<h2 id=\"使用-wsl-同学的注意事项\"><a href=\"#%E4%BD%BF%E7%94%A8-wsl-%E5%90%8C%E5%AD%A6%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>使用 WSL 同学的注意事项</h2>\n<p>在上面用 <code class=\"language-text\">n-install</code> 安装 <code class=\"language-text\">n</code> 的时候，在 WSL 里面执行时，我发现了一个很憨批的问题。<code class=\"language-text\">n-install</code> 会检测当前系统 <code class=\"language-text\">$PATH</code> 中是否已经有 <code class=\"language-text\">n</code>、Node.js 或者其他相关的二进制文件，如果发现就会报错：</p>\n<pre class=\"language-text\"><code class=\"language-text\">Aborting, because n and/or Node.js-related binaries are already in the $PATH.</code></pre>\n<p>而 WSL 默认情况下会将 Windows 的 <code class=\"language-text\">$PATH</code> 一并 append 到自己的 <code class=\"language-text\">$PATH</code> 里面，当然这样做无可厚非，毕竟这样可以让我们直接在 WSL 里面调用比如 <code class=\"language-text\">clip.exe</code>、<code class=\"language-text\">explorer.exe</code> 等 Windows 可执行文件。但是，由于我 Windows 里面也安装了 Node.js、yarn 等等，导致 <code class=\"language-text\">n-install</code> 检测到 WSL 的 <code class=\"language-text\">$PATH</code> 包含这些内容，拒绝安装。（在 WSL 中我们可以用 <code class=\"language-text\">echo $PATH</code> 来查看当前 <code class=\"language-text\">$PATH</code> 中包含哪些路径，大概率包含许多 <code class=\"language-text\">/mnt/c/xxx</code> 的路径，这些就是 Windows 的可执行文件路径。）</p>\n<p>这一情况就要我们自己来修改 WSL 的 <code class=\"language-text\">$PATH</code> 了。为了后续工作的顺利开展，我直接利用 <code class=\"language-text\">/etc/wsl.conf</code> 来设定 WSL 的 <code class=\"language-text\">$PATH</code> 中默认不包含 Windows <code class=\"language-text\">$PATH</code>：</p>\n<pre class=\"language-text\"><code class=\"language-text\">[interop]\nappendWindowsPath = false</code></pre>\n<p>重启 WSL 环境（在 Windows 中用命令 <code class=\"language-text\">wsl --shutdown</code>），再次 <code class=\"language-text\">echo $PATH</code>，我们就会得到非常干净的纯 WSL 的 <code class=\"language-text\">$PATH</code>。这样我们即可用 <code class=\"language-text\">n-install</code> 顺利安装 <code class=\"language-text\">n</code> 了。</p>\n<p>不过，这样设定后，我们就无法继续在 WSL 中直接运行 Windows 的可执行文件了。别慌！我们手动将 Windows 中所需要的几个可执行文件添加到 WSL 的 <code class=\"language-text\">$PATH</code> 里面即可。常见的几个 Windows 系统可执行文件的目录位于：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">工具名称</th>\n<th align=\"left\">可执行文件</th>\n<th align=\"left\">WSL 路径</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"left\">Windows 剪贴板</td>\n<td align=\"left\"><code class=\"language-text\">clip.exe</code></td>\n<td align=\"left\"><code class=\"language-text\">/mnt/c/WINDOWS/system32</code></td>\n</tr>\n<tr>\n<td align=\"left\">Windows 资源管理器</td>\n<td align=\"left\"><code class=\"language-text\">explorer.exe</code></td>\n<td align=\"left\"><code class=\"language-text\">/mnt/c/WINDOWS</code></td>\n</tr>\n<tr>\n<td align=\"left\">VS Code 的 <code class=\"language-text\">code</code> 命令</td>\n<td align=\"left\"><code class=\"language-text\">code.exe</code></td>\n<td align=\"left\"><code class=\"language-text\">/mnt/c/Users/&lt;YOUR WINDOWS USERNAME&gt;/AppData/Local/Programs/Microsoft VS Code/bin</code></td>\n</tr>\n</tbody>\n</table>\n<p>我们依次将我们所需要的这些路径在 <code class=\"language-text\">.zshrc</code> 中重新添加到 WSL 的 <code class=\"language-text\">$PATH</code> 即可：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># Manually add Windows explorer and clipboard executables etc. to Linux $PATH</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\"><span class=\"token environment constant\">PATH</span></span><span class=\"token operator\">=</span><span class=\"token string\">\"<span class=\"token environment constant\">$PATH</span>:/mnt/c/WINDOWS:/mnt/c/WINDOWS/system32\"</span>\n<span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\"><span class=\"token environment constant\">PATH</span></span><span class=\"token operator\">=</span><span class=\"token string\">\"<span class=\"token environment constant\">$PATH</span>:/mnt/c/Users/Spencer/AppData/Local/Programs/Microsoft VS Code/bin\"</span></code></pre>\n<h2 id=\"小结\"><a href=\"#%E5%B0%8F%E7%BB%93\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>小结</h2>\n<p>文章到这里就介绍完毕啦，<strong>这里我只是为大家提供给 Zsh 启动过程进行时间测量和 profile benchmark 的标准方法</strong>，如果各位也想加速自己 Zsh 的启动过程，那么可能除了删掉 <code class=\"language-text\">nvm</code> 换用 <code class=\"language-text\">n</code>，还需要结合自己的实际情况，删除、懒加载部分插件或工具。个人认为优化到 1s 以内就是比较合理的、可以接受的冷启动时间啦。就酱，感谢阅读。(<em>/ω＼</em>)</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">\n<p><a href=\"https://docs.python.org/3/library/profile.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://docs.python.org/3/library/profile.html</a></p>\n<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a>\n</li>\n</ol>\n</div>\n"}},{"node":{"title":"Yadm：我是如何同步并管理我的 Dotfiles 的？","path":"/2020/07/how-i-manage-my-dotfiles/","date":"July 24. 2020","timeToRead":13,"cjkWordCount":3019,"cjkReadTime":14,"description":"Yet Another Dotfiles Manager，基于 Git 的 Dotfiles 管理器。","content":"<p>没想到啊，<a href=\"https://github.com/spencerwooo/dotfiles\" title=\"我的 dotfiles 仓库\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">我的 dotfiles 仓库</a>竟然是目前我 GitHub 上面星星数量最多的单仓库。</p>\n<p>Dotfiles 顾名思义，就是我们在使用软件的时候，软件为了存储我们个人偏好设置而建立的一个以 <code class=\"language-text\">.</code> 开头的文件。</p>\n<blockquote>\n<p>User-specific application configuration is traditionally stored in so called <strong><em>dotfiles.</em></strong> <sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup></p>\n</blockquote>\n<p>比如，编辑器 Vim 有 <code class=\"language-text\">.vimrc</code>，常用的 Zsh、Bash 等 Shell 分别有 <code class=\"language-text\">.zshrc</code>、<code class=\"language-text\">.bashrc</code> 等等。另外，广义的 dotfiles 也包括 <code class=\"language-text\">JSON</code>、<code class=\"language-text\">TOML</code> 等常规配置文件（当然也包含 Neovim 的 <code class=\"language-text\">init.vim</code> 等等）。总之，这么多的 dotfiles 都是我们第一次配置安装好系统、软件之后存在于我们电脑上面的个性化配置文件。但是这些 dotfiles 往往都只存在于我们电脑上独一份，一旦重置系统、更新换代，新电脑上就有需要重新配置一遍所有的 dotfiles 才能还原我们原本的设置。手动配置这些内容一想就非常繁琐，为了最快让新电脑能够用上我们熟悉的工具和配置，也为了对我们自己的配置进行版本控制，我们需要用工具来管理我们的 dotfiles。</p>\n<h2 id=\"用-git-的思想来管理-dotfiles\"><a href=\"#%E7%94%A8-git-%E7%9A%84%E6%80%9D%E6%83%B3%E6%9D%A5%E7%AE%A1%E7%90%86-dotfiles\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>用 Git 的思想来管理 dotfiles</h2>\n<p>如果说要管理 dotfiles，我的第一反应就是用 Git 来管理，<strong>毕竟专业的版本控制工具，用来管理纯文本文件的修改和同步再合适不过了。</strong>现在前面提到的那个星星数量最多的 repo 就是我最初用 Git 来将我的 dotfiles 集合到一个 GitHub 仓库里面时所做的尝试。那个仓库现在来看其实比较混乱，由于是一个标准的 Git 仓库，所有的文件都在当前文件夹下，因此为了三个系统的 dotfiles 都同步于一个仓库里，我建立了三个不同的文件夹：macOS、Windows 和 Linux。同时我也得手动将我本地的实际修改复制粘贴到这一 dotfiles 仓库之中。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200724-173035.png\" alt=\"我之前利用 Git 手动同步的 Dotfiles 仓库\"><figcaption>我之前利用 Git 手动同步的 Dotfiles 仓库</figcaption></figure>\n<p>那么这样管理的弊端显而易见：这一仓库仅仅算是「一个配置参考」，<strong>而非实际意义上的 portable dotfiles repository。</strong>多机同步靠粘贴，版本控制靠脑袋，有时候我的工具或者配置更换了，只能徒手把原来的配置移动到 <code class=\"language-text\">/archive</code> 文件夹下……这样管理一点也不优雅！如果我们可以直接在每个 dotfile 所在的原本位置就将其签入 Git 系统进行版本控制和远程同步就好了。🎈</p>\n<h2 id=\"yet-another-dotfiles-manager\"><a href=\"#yet-another-dotfiles-manager\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Yet Another Dotfiles Manager</h2>\n<p><code class=\"language-text\">yadm</code> —— Yet Another Dotfiles Manager，恰好就是为管理 dotfiles 而生的一个工具。利用 <code class=\"language-text\">yadm</code>，我们可以在每个 dotfile 的原始位置，用超出原生 Git 所支持的功能，来任意的管理、同步我们的 dotfiles。</p>\n<ul>\n<li><code class=\"language-text\">yadm</code> 的官方 GitHub 地址位于：<a href=\"https://github.com/TheLocehiliosan/yadm\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">TheLocehiliosan/yadm</a></li>\n<li><code class=\"language-text\">yadm</code> 的官方介绍于文档位于：<a href=\"https://yadm.io/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Yet Another Dotfiles Manager</a></li>\n</ul>\n<p>首先，实际上 <code class=\"language-text\">yadm</code> 的底层依旧是 Git，也就是说，我们在用 <code class=\"language-text\">yadm</code> 管理 dotfiles 的时候，实际上依旧是用 Git 来进行版本控制、远程同步等等操作的。但是，<code class=\"language-text\">yadm</code> 在 Git 的基础之上，进行了合理的功能拓展：<code class=\"language-text\">yadm</code> 能够让我们不必被一个 Git 仓库文件夹所限制，不必将 <code class=\"language-text\">$HOME</code> 目录下的全部非相关文件放入 <code class=\"language-text\">.gitignore</code>，能够直接管理同步 dotfile 文件。</p>\n<p>总之，如果我们使用 <code class=\"language-text\">yadm</code> 而不是直接用 Git 来管理 dotfiles 的话：</p>\n<ul>\n<li>我们不必关心当前目录是否是 Git 目录（非 Git 初始化的目录原版 Git 是拒绝工作的：<code class=\"language-text\">fatal: not a git repository</code>）；</li>\n<li>我们不必将原 dotfile 的位置进行移动，也不必将原 dotfile 通过软链接 symlink 到其他位置来统一管理；</li>\n<li>但我们依旧可以直接使用 Git 的全部功力，包括 Git 分支、merge、rebase、使用 submodules 等等；</li>\n</ul>\n<p>不过，<code class=\"language-text\">yadm</code> 是一个 *NIX 工具，如果你使用 macOS 或者 Linux，那么没问题，你可以直接用 <code class=\"language-text\">yadm</code> 管理 dotfiles；但是如果你用 Windows，那么很遗憾，<code class=\"language-text\">yadm</code> 只能在 WSL 里面进行安装。（不过没事！还是有解决办法的！）</p>\n<h2 id=\"用-yadm-管理同步并自动部署-dotfiles\"><a href=\"#%E7%94%A8-yadm-%E7%AE%A1%E7%90%86%E5%90%8C%E6%AD%A5%E5%B9%B6%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2-dotfiles\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>用 yadm 管理、同步并自动部署 dotfiles</h2>\n<p>到这里，我们终于正式开始用 <code class=\"language-text\">yadm</code> 管理同步 dotfiles 了。首先，如果你还没有安装，那么根据你使用的操作系统，先<a href=\"https://yadm.io/docs/install\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">按照官方安装文档</a>安装 <code class=\"language-text\">yadm</code>。接下来，我按照「我已经有大量 dotfiles，但是还没有统一进行系统管理」的情况，来简单介绍 <code class=\"language-text\">yadm</code> 的使用和功能。</p>\n<h3 id=\"用-github-仓库同步-dotfiles-文件\"><a href=\"#%E7%94%A8-github-%E4%BB%93%E5%BA%93%E5%90%8C%E6%AD%A5-dotfiles-%E6%96%87%E4%BB%B6\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>用 GitHub 仓库同步 dotfiles 文件</h3>\n<p>第一步，在 GitHub 上创建一个<strong>空的私有仓库</strong>（建议除非特别自信，还是用私有仓库比较保险），用作我们整个系统 dotfiles 的同步仓库。</p>\n<div class=\"admonition admonition-caution\"><div class=\"admonition-heading\"><h5><div class=\"admonition-icon\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\"><path fill-rule=\"evenodd\" d=\"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z\"></path></svg></div>🍌 注意</h5></div><div class=\"admonition-content\"><p>建议这里如果是从头开始，<strong>直接创建完全空白，不带 README 或 LICENSE 的仓库为宜。</strong></p></div></div>\n<p>之后，在我们的根目录（即 <code class=\"language-text\">~/</code>、<code class=\"language-text\">$HOME</code>）下，直接初始化 <code class=\"language-text\">yadm</code> 仓库并添加我们需要管理的 dotfile 文件：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># 初始化 yadm 仓库（在哪里都一样噢！）</span>\nyadm init\n\n<span class=\"token comment\"># 用 yadm 添加 dotfile 文件至仓库</span>\nyadm <span class=\"token function\">add</span> <span class=\"token operator\">&lt;</span>某个 dotfile 文件<span class=\"token operator\">></span>\n\n<span class=\"token comment\"># 继续添加……</span>\n\n<span class=\"token comment\"># 最后，将添加好的 dotfile 签入 Git</span>\nyadm commit <span class=\"token parameter variable\">-m</span> <span class=\"token string\">\"&lt;写个 commit 信息>\"</span></code></pre>\n<p>这样，本地的 <code class=\"language-text\">yadm</code> 仓库就已经用 Git 存储好了我们 dotfile 文件的全部信息，以及最重要的：相对于 <code class=\"language-text\">$HOME</code> 的文件路径（实际上就是绝对路径）。接下来，我们将本地仓库跟刚刚 GitHub 上面创建好的远程仓库进行关联，并将本地更新推送至远程：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">yadm remote <span class=\"token function\">add</span> origin <span class=\"token operator\">&lt;</span>刚刚建立的 GitHub 远程仓库地址<span class=\"token operator\">></span>\nyadm push <span class=\"token parameter variable\">-u</span> origin master</code></pre>\n<p>至此，我们就像平日里用 Git 一样将我们分散在系统各个地方的 dotfiles 统一签入了 <code class=\"language-text\">yadm</code> 管理的「专属 dotfiles 仓库」里面。我们也可以直接将 <code class=\"language-text\">yadm</code> 理解成一个在任意目录下都可以直接使用的 dotfiles 专属 Git 版本控制工具。用 <code class=\"language-text\">yadm list</code> 可以看到我们使用 <code class=\"language-text\">yadm</code> 管理的全部 dotfiles 列表，当然，<code class=\"language-text\">yadm status</code> 跟 <code class=\"language-text\">git status</code> 一样可以查看每个 dotfile 文件的修改情况。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200724-202658.png\" alt=\"命令：yadm list 和 yadm status\"><figcaption>命令：yadm list 和 yadm status</figcaption></figure>\n<h3 id=\"借助-yadm-的-bootstrap-功能自动配置环境\"><a href=\"#%E5%80%9F%E5%8A%A9-yadm-%E7%9A%84-bootstrap-%E5%8A%9F%E8%83%BD%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>借助 yadm 的 bootstrap 功能自动配置环境</h3>\n<p>很多情况下，光用 <code class=\"language-text\">yadm</code> 将 dotfiles 同步到本地是不够的，拿到新电脑我们还得安装许多工具。这时候，我们即可借助 <code class=\"language-text\">yadm</code> 的 bootstrap 功能，自动将任务脚本的执行 hook 在 <code class=\"language-text\">yadm</code> 克隆之后，完成环境的全自动部署。不过，<code class=\"language-text\">yadm</code> 的 bootstrap 脚本是需要我们自己撰写的，默认位于 <code class=\"language-text\">$HOME/.config/yadm/bootstrap</code>，这里不论是 Bash 脚本、Python 脚本还是什么别的，只要是可执行文件就可以。</p>\n<p>这里我给我自己简单写了一个 Bash 脚本，自动安装 Zsh、<a href=\"https://github.com/zplug/zplug\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">zplug</a> 和 Neovim 三个软件 / 插件。具体代码如下：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token shebang important\">#!/bin/sh</span>\n\n<span class=\"token assign-left variable\">system_type</span><span class=\"token operator\">=</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">uname</span> <span class=\"token parameter variable\">-s</span><span class=\"token variable\">)</span></span>\n\n<span class=\"token keyword\">if</span> <span class=\"token punctuation\">[</span> <span class=\"token string\">\"<span class=\"token variable\">$system_type</span>\"</span> <span class=\"token operator\">=</span> <span class=\"token string\">\"Linux\"</span> <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n  <span class=\"token comment\"># install zsh, zplug, neovim</span>\n  <span class=\"token keyword\">if</span> <span class=\"token operator\">!</span> <span class=\"token builtin class-name\">command</span> <span class=\"token parameter variable\">-v</span> <span class=\"token function\">zsh</span> <span class=\"token operator\">></span> /dev/null <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span><span class=\"token file-descriptor important\">&amp;1</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Installing zsh...\"</span>\n    <span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> <span class=\"token function\">install</span> <span class=\"token function\">zsh</span>\n  <span class=\"token keyword\">elif</span> <span class=\"token punctuation\">[</span> <span class=\"token operator\">!</span> <span class=\"token parameter variable\">-f</span> <span class=\"token variable\">${<span class=\"token environment constant\">HOME</span>}</span>/.zplug/init.zsh <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Installing zplug...\"</span>\n    <span class=\"token function\">curl</span> <span class=\"token parameter variable\">-sL</span> --proto-redir -all,https https://cdn.jsdelivr.net/gh/zplug/installer/installer.zsh <span class=\"token operator\">|</span> <span class=\"token function\">zsh</span>\n  <span class=\"token keyword\">elif</span> <span class=\"token operator\">!</span> <span class=\"token builtin class-name\">command</span> <span class=\"token parameter variable\">-v</span> nvim <span class=\"token operator\">></span> /dev/null <span class=\"token operator\"><span class=\"token file-descriptor important\">2</span>></span><span class=\"token file-descriptor important\">&amp;1</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">then</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Installing neovim...\"</span>\n    <span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> <span class=\"token function\">install</span> neovim\n    <span class=\"token comment\"># sudo apt install python-neovim</span>\n    <span class=\"token comment\"># sudo apt install python3-neovim</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"Installing neovim plugins with vim-plug...\"</span>\n    nvim <span class=\"token string\">\"+PlugUpdate\"</span> <span class=\"token string\">\"+PlugClean!\"</span> <span class=\"token string\">\"+PlugUpdate\"</span> <span class=\"token string\">\"+qall\"</span>\n  <span class=\"token keyword\">else</span>\n    <span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"All packages are installed.\"</span>\n  <span class=\"token keyword\">fi</span>\n<span class=\"token keyword\">fi</span></code></pre>\n<p>这里必须注意的是：</p>\n<ul>\n<li>我们所编写的自动 bootstrap 脚本最好是「幂等」的，简单来讲就是有对软件当前存在状态的检测，以免发生重复安装、覆盖原始配置的问题；</li>\n<li>我们最好先对当前操作系统进行检测，比如 macOS 和 Linux 实际上环境有很大不同，需要区别处理；</li>\n</ul>\n<p>我们可以用 <code class=\"language-text\">yadm bootstrap</code> 命令来手动执行与测试这一脚本。当然，我们编写的 bootstrap 可执行文件，同样可以用 <code class=\"language-text\">yadm</code> 签入并进行同步，和普通 dotfile 文件一样处理即可。</p>\n<p>更多有关 <code class=\"language-text\">yadm</code> 的 bootstrap 功能请参考：<a href=\"https://yadm.io/docs/bootstrap\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">yadm Docs - Bootstrap</a>.</p>\n<h3 id=\"其他功能\"><a href=\"#%E5%85%B6%E4%BB%96%E5%8A%9F%E8%83%BD\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>其他功能</h3>\n<p>除了上面简单的 dotfiles 同步与版本管理、bootstrap 自动环境部署等功能外，<code class=\"language-text\">yadm</code> 还可以：</p>\n<ul>\n<li>对敏感文件（比如 SSH 密钥、SSH <code class=\"language-text\">config</code> 文件……）进行加密、解密，提供私有仓库以外的额外一层保护：<a href=\"https://yadm.io/docs/encryption\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">yadm Docs - Encryption</a>；</li>\n<li>针对不同的操作系统、不同的环境以及不同的电脑维护不同种类的同一软件 / 插件的 dotfile 文件：<a href=\"https://yadm.io/docs/alternates\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">yadm Docs - Alternate Files</a>、<a href=\"https://yadm.io/docs/templates\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">yadm Docs - Templates</a>；</li>\n</ul>\n<p>这两个功能我还有待体验与开发，有兴趣的同学可以前往官方文档进行研究使用。</p>\n<h2 id=\"faq\"><a href=\"#faq\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>FAQ</h2>\n<h3 id=\"但是我想让-yadm-管理-home-以外的文件怎么办\"><a href=\"#%E4%BD%86%E6%98%AF%E6%88%91%E6%83%B3%E8%AE%A9-yadm-%E7%AE%A1%E7%90%86-home-%E4%BB%A5%E5%A4%96%E7%9A%84%E6%96%87%E4%BB%B6%E6%80%8E%E4%B9%88%E5%8A%9E\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>但是我想让 yadm 管理 <code class=\"language-text\">$HOME</code> 以外的文件怎么办？</h3>\n<p>前面的表述中，我们可能已经发现了，<code class=\"language-text\">yadm</code> 默认情况下仅管理 <code class=\"language-text\">$HOME</code> 目录下的文件，也就是我们个人用户的文件。<code class=\"language-text\">yadm</code> 不会去管理系统文件，比如 <code class=\"language-text\">/etc</code>、<code class=\"language-text\">/mnt</code> 下的文件。这里的 <code class=\"language-text\">$HOME</code> 实际上就是 <code class=\"language-text\">yadm</code> 的默认工作树，其真实文件路径位于 <code class=\"language-text\">/home/&lt;你的用户名&gt;</code>，<code class=\"language-text\">yadm</code> 也「根据设计」仅管理这一目录下的文件，而大部分情况下这也是完全合理、够用的。</p>\n<p>但是，如果我们想要继续管理 <code class=\"language-text\">/home/xxx</code> 以外地方的文件，那么我们需要「扩大文件树的范围」，或者「选择使用其他目录作为主文件树」。首先，其他地方的文件 <code class=\"language-text\">yadm</code> 很可能没有读写权限，所以我们需要先设置一个专门用来管理系统文件的 <code class=\"language-text\">yadm</code> alias 命令：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># 使用 /etc/yadm 作为 yadm 系统文件管理的目录</span>\n<span class=\"token builtin class-name\">alias</span> <span class=\"token assign-left variable\">sysyadm</span><span class=\"token operator\">=</span><span class=\"token string\">\"sudo yadm -Y /etc/yadm\"</span></code></pre>\n<p>之后，我们可以直接使用 <code class=\"language-text\">sysyadm</code> 命令，并使用一个单独的远程仓库，来单独管理系统文件：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># 将 / 目录初始化为 sysyadm 的文件树</span>\nsysyadm init <span class=\"token parameter variable\">-w</span> /\n\n<span class=\"token comment\"># 和 yadm 一样，添加文件、签入版本控制系统、同步远程仓库</span>\nsysyadm <span class=\"token function\">add</span> <span class=\"token operator\">&lt;</span>某个 / 路径下的系统文件<span class=\"token operator\">></span>\nsysyadm commit <span class=\"token parameter variable\">-m</span> <span class=\"token string\">\"&lt;啊，我签入了一个系统文件耶>\"</span>\n<span class=\"token comment\"># ……</span></code></pre>\n<p>当然，你仅使用 <code class=\"language-text\">sysyadm</code> 管理整个系统里面的全部 dotfiles 也可以，但是你可能每次都需要申请 sudo 权限，不太优雅。</p>\n<p>更多使用细节请见：<a href=\"https://yadm.io/docs/faq#unconventional-cases\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">yadm Docs - FAQ #Unconventional Cases</a>.</p>\n<h3 id=\"我们这些-windows-用户怎么办\"><a href=\"#%E6%88%91%E4%BB%AC%E8%BF%99%E4%BA%9B-windows-%E7%94%A8%E6%88%B7%E6%80%8E%E4%B9%88%E5%8A%9E\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>我们这些 Windows 用户怎么办？</h3>\n<p>什么时候我们 Windows 用户才能站起来！气抖冷。</p>\n<p>实际上，如果你像我一样使用 WSL，那么我们用上文的方法其实也可以直接进行 Windows 的 dotfiles 管理。在 WSL 环境下，我们 <code class=\"language-text\">yadm</code> 拿到的 Windows 文件一般位于 <code class=\"language-text\">/mnt/c/Users/&lt;你的用户名&gt;</code> 里面。因此，这一情况需要我们将 <code class=\"language-text\">yadm</code> 的工作树设定在 <code class=\"language-text\">/</code> 或 <code class=\"language-text\">/mnt</code> 目录下，才可以有效管理 Windows 文件。</p>\n<p>但是，我还是觉得有点别扭，特别是当我需要给 <code class=\"language-text\">yadm</code> 权限直接管理整个 <code class=\"language-text\">/</code> 目录下的文件的时候。因此，为了方便（并不方便），我还是在 WSL 的 <code class=\"language-text\">$HOME</code> 里面创建了一个 <code class=\"language-text\">~/Dotfiles/Windows</code> 目录，用传统办法，手动复制粘贴 Windows 里面的 dotfiles 作为「配置文件参考」。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200724-211554.png\" alt=\"在 WSL 里面手动管理 Windows 中的 Dotfiles\"><figcaption>在 WSL 里面手动管理 Windows 中的 Dotfiles</figcaption></figure>\n<p>当然，还好 Windows 需要同步的文件不算太复杂，而且主要为了同步一下 Windows Terminal 的自定义图标，还好还好。</p>\n<h2 id=\"小结\"><a href=\"#%E5%B0%8F%E7%BB%93\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>小结</h2>\n<p>说到这里，我其实发现自己已经算是不太管曾经那个用笨方法管理的 <a href=\"https://github.com/spencerwooo/dotfiles\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">spencerwooo/dotfiles</a> 仓库了，即使标星的人那么多。（啊这，写着写着还发现<a href=\"https://github.com/spencerwooo/dotfiles/issues/9\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">有个老哥发了个 issue</a>，人傻了。）好了，本文到这里就结束啦，感谢阅读。(＠_＠;)</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">\n<p><a href=\"https://wiki.archlinux.org/index.php/Dotfiles\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://wiki.archlinux.org/index.php/Dotfiles</a></p>\n<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a>\n</li>\n</ol>\n</div>\n"}},{"node":{"title":"cwim 背后的故事：Rust 与 Ownership","path":"/2020/01/cli-app-in-rust/","date":"January 23. 2020","timeToRead":14,"cjkWordCount":3472,"cjkReadTime":16,"description":"Rust 是如何保证「内存安全」的","content":"<p>前几天 Stack Overflow 博客上面有一篇文章<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup>，里面提到了 Rust 已经连续四年位列 Stack Overflow 社区最爱编程语言榜首。的确，Rust 是一门神奇又美丽的语言。Rust 是一门标榜 safe 与 zero-cost abstraction 的语言<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup>，意味着只要你编写的 Rust 代码符合官方标准 —— 能够通过编译 —— 那么你的项目几乎可以肯定地说是内存安全的。</p>\n<h2 id=\"初衷\"><a href=\"#%E5%88%9D%E8%A1%B7\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>初衷</h2>\n<p>偏向底层的 Rust 让我在之前一直没有机会尝试，毕竟我相信国内高校没有一所是敢直接抛弃 C、C++ 而使用 Rust 作为其主语言进行授课的。最近我重构了 <a href=\"https://dowww.spencerwoo.com\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Dev on Windows with WSL</a>：一个近 2w 字的 WSL 开发配置文档。我前后用了大概半个月的时间，增加了许多内容，因此我在结束编写工作之后，试图找到一个类似 <code class=\"language-text\">cloc</code>，能帮我统计一个目录下全部 Markdown 文件的命令行工具。很失望，没找到。</p>\n<p>我决定自己尝试实现这个命令行工具，当然，我也相信 Python、Node.js、Ruby 等脚本语言一定适合做这些事情，毕竟 <code class=\"language-text\">cloc</code> 本身就是使用 Perl 实现的。不过，Rust 作为一门高效的、静态的、可以直接编译到三个操作系统的底层语言，还是很有吸引力的。因此我才决定使用 Rust 开新坑。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215236.png\" alt=\"使用 Rust 实现的 cwim - Count words in Markdown\"><figcaption>使用 Rust 实现的 cwim - Count words in Markdown</figcaption></figure>\n<p>另外：cwim 的第一个小版本我已经编译并发布 Release 版本，有兴趣的同学可以前往 GitHub 查看：<a href=\"https://github.com/spencerwooo/cwim\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">spencerwooo/cwim</a>.</p>\n<h2 id=\"开始一个-rust-项目\"><a href=\"#%E5%BC%80%E5%A7%8B%E4%B8%80%E4%B8%AA-rust-%E9%A1%B9%E7%9B%AE\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>开始一个 Rust 项目</h2>\n<p>Rust 最 beginner friendly 的地方我觉得在于其<a href=\"https://www.rust-lang.org/zh-CN/learn/get-started\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">官方入门文档</a>的简洁易懂。从安装、编译到包管理、打包项目 …… Rust 的官方文档讲解的都比任何其他语言的文档讲解的要易懂不少。我这里简单记录一下 Rust 环境的安装搭建的基本过程。</p>\n<h3 id=\"安装-rust-环境\"><a href=\"#%E5%AE%89%E8%A3%85-rust-%E7%8E%AF%E5%A2%83\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>安装 Rust 环境</h3>\n<p>Rust 语言虽然小众，但是其生态相当完善。Rust 借鉴了其他语言的多种环境配置工具，官方直接提供了一整套完善的闭环 Toolkit，基本能满足我们在使用 Rust 时的安装、构建、编译、发布的整套流程：</p>\n<ul>\n<li>Rustup：Rust 版本管理（类似 Python 的 <code class=\"language-text\">pyenv</code>、Node.js 的 <code class=\"language-text\">nvm</code> 等）</li>\n<li>Cargo：Rust 构建工具与包管理（类似 Python 的 <code class=\"language-text\">pip</code>、Node.js 的 <code class=\"language-text\">yarn</code> 等）</li>\n<li>crates.io：Rust 的 Package Registry</li>\n</ul>\n<p>首先，我们安装 Rustup：Rust 安装器与 Rust 版本控制器。使用 Arch Linux（以及 WSL 的 Arch Linux）的同学可以直接在 AUR 中安装 <code class=\"language-text\">rustup</code>：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">yay rustup</code></pre>\n<p>如果使用 WSL 其他 Linux 发行版，我们也可以用下面的命令安装 <code class=\"language-text\">rustup</code>：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">curl</span> <span class=\"token parameter variable\">--proto</span> <span class=\"token string\">'=https'</span> <span class=\"token parameter variable\">--tlsv1.2</span> <span class=\"token parameter variable\">-sSf</span> https://sh.rustup.rs <span class=\"token operator\">|</span> <span class=\"token function\">sh</span></code></pre>\n<p>其他安装方法请参考：<a href=\"https://www.rust-lang.org/zh-CN/tools/install\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Rust | 安装 Rust</a></p>\n<p>安装了 <code class=\"language-text\">rustup</code> 之后，我们就应该已经安装完成了 Cargo：Rust 的构建工具与包管理工具。Cargo 可以做很多事情：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">cargo</span> build     <span class=\"token comment\"># 可以构建项目</span>\n<span class=\"token function\">cargo</span> run       <span class=\"token comment\"># 可以运行项目</span>\n<span class=\"token function\">cargo</span> <span class=\"token builtin class-name\">test</span>      <span class=\"token comment\"># 可以测试项目</span>\n<span class=\"token function\">cargo</span> doc       <span class=\"token comment\"># 可以为项目构建文档</span>\n<span class=\"token function\">cargo</span> publish   <span class=\"token comment\"># 可以将库发布到 crates.io</span></code></pre>\n<p>要检查是否安装了 Rust 和 Cargo，可以在终端中运行：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">cargo</span> <span class=\"token parameter variable\">--version</span></code></pre>\n<p>接下来我们就可以使用 Cargo 来创建一个 Rust 项目，并用它来安装我们必须的 Rust 库等内容。</p>\n<h3 id=\"rust--vs-code\"><a href=\"#rust--vs-code\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Rust / VS Code</h3>\n<p>VS Code 是一个通用的文本 / 代码编辑器，能够通过插件支持多种语言环境下代码的编写任务。我们下载 Rust 官方提供的 VS Code 插件：<a href=\"https://marketplace.visualstudio.com/items?itemName=rust-lang.rust\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Visual Studio Code Marketplace | Rust (rls)</a></p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215236-1.png\" alt=\"Visual Studio Code Marketplace | Rust (rls)\"><figcaption>Visual Studio Code Marketplace | Rust (rls)</figcaption></figure>\n<p>之后，我们用 Cargo 创建一个新的项目 <code class=\"language-text\">hello-rust</code>：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">cargo</span> new hello-rust</code></pre>\n<p>或者在已有文件夹 <code class=\"language-text\">hello-rust</code> 下，生成新 Rust 项目：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">cd</span> hello-rust\n<span class=\"token function\">cargo</span> init</code></pre>\n<p>新的 Rust 项目目录下应该拥有以下内容：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">hello-rust      <span class=\"token comment\"># 根目录</span>\n<span class=\"token operator\">|</span>- Cargo.toml   <span class=\"token comment\"># Rust 的清单文件，其中包含项目的元数据和依赖库</span>\n<span class=\"token operator\">|</span>- src\n  <span class=\"token operator\">|</span>- main.rs    <span class=\"token comment\"># 主程序入口</span></code></pre>\n<p>用 VS Code 打开这一目录，我们即可开始 Rust 项目的编写。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215236-2.png\" alt=\"使用 VS Code 撰写 Rust 项目\"><figcaption>使用 VS Code 撰写 Rust 项目</figcaption></figure>\n<p>使用下面命令即可运行项目：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">cargo</span> run</code></pre>\n<h2 id=\"rust-语言特性\"><a href=\"#rust-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Rust 语言特性</h2>\n<p>在用 Rust 编写 <code class=\"language-text\">cwim</code> 的时候，有两个令我印象深刻的地方：一个是 Rust 语言实际上非常清晰易懂，有 C、C++ 等强类型语言的严谨，也有脚本语言的易读；另一个就是 Rust 编译器非常严格，但给我们的问题提示也非常清晰，方便追溯问题所在，容易 debug。严苛的 Rust 编译器让我们必须考虑「内存分配」，也正因如此，使得 <strong>Rust 在并未实现「垃圾回收」的前提下，确保了任何 Rust 程序都生来具有「内存安全」特性。</strong></p>\n<blockquote>\n<p>🧲 <strong>Rust Playground</strong></p>\n<p>下面涉及到的代码内容可以在 Rust 在线 Playground 中自己尝试。链接位于：<a href=\"https://play.rust-lang.org\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Rust Playground</a></p>\n</blockquote>\n<h3 id=\"ownership\"><a href=\"#ownership\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Ownership</h3>\n<p>Rust 的 Ownership（所有权）是保证 Rust 程序「内存安全」的重点特性。什么是「内存安全」？保证「内存安全」就是指或语言本身，或使用语言的开发者，在其程序运行时管理系统的「内存分配」的过程中保证内存没有浪费、没有泄露。我们一般的程序都需要实施「静态」与「动态」两种形式的内存分配，其中前者指已知变量所需空间，直接在内存中划分一部分不变的区域给变量；后者为在程序运行过程中动态地给变量分配内存空间，使得变量能够在程序运行时变化地占用内存大小。</p>\n<h3 id=\"数据存储方式\"><a href=\"#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>数据存储方式</h3>\n<p>Rust 是使用「栈」和「堆」这两种数据结构来对这两种内存分配形式进行划分的。为了更好的理解 Rust 的 Ownership 的工作机制，我们首先看看 Rust 是如何利用「栈」和「堆」进行内存分配。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215236-3.png\" alt=\"使用「栈」和「堆」进行内存分配\"><figcaption>使用「栈」和「堆」进行内存分配</figcaption></figure>\n<p>首先，「栈」从实现上来说是一种效率非常高的数据结构，因为「栈」拥有「后进先出」的数据存储特点（LIFO），使得最后压入栈顶的元素会被最先从栈顶移出。这种数据结构的优势在于：当我们用「栈」来维护内存数据时，<strong>我们只需要维护「栈顶」元素的信息即可</strong>。同时，Rust 内存管理的「栈」在编译时即可知道其具体大小，静态分配内存空间即可<sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup>。</p>\n<p>而 Rust 的「堆」则不一样，「堆」是一个动态分配内存空间的数据结构。当我们使用「堆」分配内存空间时，我们实际上是在「堆」上寻找对应的内存地址，将之标记，并返回与之相对映的指针。这一过程跟我们 C、C++ 中的 allocate memory 的原理是一致的。</p>\n<h3 id=\"所有权如何保证内存安全\"><a href=\"#%E6%89%80%E6%9C%89%E6%9D%83%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>所有权如何保证内存安全</h3>\n<p>为什么 Rust 需要引入「所有权」的机制？因为 Rust 保证「内存安全」的方法是：追踪第二种「堆」结构中哪部分数据被哪部分代码使用，从而尽量减少「堆」中的重复数据，保证「堆」中不出现有未使用的数据等问题。</p>\n<blockquote>\n<p>Keeping track of what parts of code are using what data on the heap, minimizing the amount of duplicate data on the heap, and cleaning up unused data on the heap so you don’t run out of space are all problems that ownership addresses. —— <a href=\"https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">The Rust Book</a></p>\n</blockquote>\n<p>Rust 正是使用基于「所有权」理念的一系列规定来保证 Rust 程序的「内存安全」。这其中的机制包括：</p>\n<ul>\n<li>Rust 中的每个「值」都有一个被叫做 owner 的变量（所有者）</li>\n<li>同一时间只能有一个 owner</li>\n<li>当 owner 离开我们程序段的 scope 之后，这一「值」就会被释放掉</li>\n</ul>\n<p>我们来看下面的几个例子，来具体看看 Rust 如何保证「内存安全」的。</p>\n<p>我们以 Rust 中字符串（String Literal）为例子，Rust 中字符串有 <code class=\"language-text\">&amp;str</code> 的静态字符串变量，以及 <code class=\"language-text\">String</code> 的动态字符串变量。我们来看看 Rust 是如何分别利用「栈」来存储 <code class=\"language-text\">&amp;str</code>、用「堆」来存储 <code class=\"language-text\">String</code> 的。</p>\n<p>首先来看一个 <code class=\"language-text\">&amp;str</code> 的例子：</p>\n<pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// &amp;str 用「栈」存储</span>\n  <span class=\"token keyword\">let</span> s1 <span class=\"token operator\">=</span> <span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 字符串 \"Hello\" 赋值给变量 s1</span>\n  <span class=\"token keyword\">let</span> s2 <span class=\"token operator\">=</span> s1<span class=\"token punctuation\">;</span>         <span class=\"token comment\">// 将变量 s1 复制并赋值给 s2</span>\n  <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}\"</span><span class=\"token punctuation\">,</span> s1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 这样做没有问题！</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>可以发现，当我们直接使用 <code class=\"language-text\">&amp;str</code> 存储字符串时，Rust 是将前一个变量 <code class=\"language-text\">s1</code> 的值<strong>直接复制</strong>给后一个变量 <code class=\"language-text\">s2</code>，前一个变量 <code class=\"language-text\">s1</code> 并没有变化。此时我们访问前一个变量 <code class=\"language-text\">s1</code> 没有任何问题。</p>\n<p>接下来，我们来看一个 <code class=\"language-text\">String</code> 的例子：</p>\n<pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// String 用「堆」存储</span>\n  <span class=\"token keyword\">let</span> s1 <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello again\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// String 变量 \"Hello again\" 赋值给 s1</span>\n  <span class=\"token keyword\">let</span> s2 <span class=\"token operator\">=</span> foo<span class=\"token punctuation\">;</span>                         <span class=\"token comment\">// 将 s1 变量中的内容「移动」到 s2 中</span>\n  <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}, {}\"</span><span class=\"token punctuation\">,</span> s1<span class=\"token punctuation\">,</span> s2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>           <span class=\"token comment\">// 出错了！s1 中内容被 moved，无法被 reference</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>此时，编译器会报出 <code class=\"language-text\">error[E0382]: borrow of moved value: &#39;s1&#39;</code> 的错误。可以发现，当我们使用 String 存储字符串时，Rust 不会将变量的值「复制」，而是会将变量「移动」到目标变量中。这种情况下，Rust 会认为前一个变量 <code class=\"language-text\">s1</code> 已经不再有效（no longer valid），因此，当我们在之后试图访问 <code class=\"language-text\">s1</code> 时，Rust 就会报出这一错误。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215236-4.png\" alt=\"error[E0382] 报错\"><figcaption>error[E0382] 报错</figcaption></figure>\n<p>为什么 Rust 在使用「堆」进行动态内存分配时，会 move 而不 copy 呢？一方面是因为 copy 的消耗是比 move 大得多的；另一方面，Rust 这一设计恰好帮助我们避免了 C 语言中非常可能遇到的一种内存泄露的问题：<strong>double free 异常</strong><sup id=\"fnref-4\"><a href=\"#fn-4\" class=\"footnote-ref\">4</a></sup>。</p>\n<p>Double free 异常是如何发生的？当我们使用 <code class=\"language-text\">String</code> 类型来存储字符串时，我们实际上存储了以下三个 field 的值：<code class=\"language-text\">ptr</code>、<code class=\"language-text\">len</code>、<code class=\"language-text\">capacity</code>。<code class=\"language-text\">ptr</code> 指向存储字符串内容的内存空间。比如 <code class=\"language-text\">let s1 = String::from(&quot;Hello&quot;);</code> 即声明了如下的存储方式：</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215236-5.png\" alt=\"String 的存储方式\"><figcaption>String 的存储方式</figcaption></figure>\n<p>我们如果使用 <code class=\"language-text\">copy</code> 将 String <code class=\"language-text\">s1</code> 复制给 <code class=\"language-text\">s2</code>，我们实际上就将三个 field 的值 <code class=\"language-text\">ptr</code>、<code class=\"language-text\">len</code> 和 <code class=\"language-text\">capacity</code> 全部复制，也就是我们的 <code class=\"language-text\">ptr</code> 指针实际上指向上一块地址空间，如下图所示：</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215236-6.png\" alt=\"使用 copy 将 s1 复制给 s2\"><figcaption>使用 copy 将 s1 复制给 s2</figcaption></figure>\n<p>前面我们提到了，<em>对于一个「值」来说，当程序离开「值」的 owner 所在的 scope 之后，这一「值」就会被释放掉</em>，那么当我们离开 <code class=\"language-text\">s1</code> 和 <code class=\"language-text\">s2</code> 所在的 scope 之后，程序则会试图将这两个「值」的内存空间全部释放，而此时 <code class=\"language-text\">s1</code> 和 <code class=\"language-text\">s2</code> 指向同一块地址空间，<strong>这种情况下就会出现 double free 异常的情况</strong>。</p>\n<blockquote>\n<p>Freeing memory twice can lead to memory corruption, which can potentially lead to security vulnerabilities.</p>\n</blockquote>\n<p>而我们 Rust 就通过「所有权」规避了这一问题，如下图所示，Rust 在上述过程中，实际上是将 <code class=\"language-text\">s1</code> 的值移动到了 <code class=\"language-text\">s2</code> 上，在 <code class=\"language-text\">s2</code> 的指针指向对应的内存空间时，Rust 会认为 <code class=\"language-text\">s1</code> 此时已经无用了，从而直接 invalidate 掉 <code class=\"language-text\">s1</code>，那么当我们程序离开当前 scope 后，valid 的「值」只有 <code class=\"language-text\">s2</code>，Rust 就只会将 <code class=\"language-text\">s2</code> 释放，从而避免出现 double free 异常的情况。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215236-7.png\" alt=\"Rust 中 s1 move 给 s2 之后，s1 被认为 invalid\"><figcaption>Rust 中 s1 move 给 s2 之后，s1 被认为 invalid</figcaption></figure>\n<p>不过，如果我们此时一定要访问 <code class=\"language-text\">s1</code> 的内容怎么办？Rust 有一个专门的方法，让 <code class=\"language-text\">s2</code> 创建时，不 move 而是深度拷贝 <code class=\"language-text\">s1</code> 的全部内容，如下图所示：</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215236-8.png\" alt=\"Rust 中将 s1 deep copy 给 s2\"><figcaption>Rust 中将 s1 deep copy 给 s2</figcaption></figure>\n<p>这里 Rust 所做的事情类似于其他语言中的 deep copy —— 花费更大的开销，将 <code class=\"language-text\">s1</code> 字符串对应的「堆」复制一个，再分配内存空间存储复制出来的 <code class=\"language-text\">s1</code> 并将之赋给 <code class=\"language-text\">s2</code>。在 Rust 中我们可以用 <code class=\"language-text\">&lt;VARIABLE&gt;.clone()</code> 来表示这一功能：</p>\n<pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> s1 <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> s2 <span class=\"token operator\">=</span> s1<span class=\"token punctuation\">.</span><span class=\"token function\">clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"s1 = {}, s2 = {}\"</span><span class=\"token punctuation\">,</span> s1<span class=\"token punctuation\">,</span> s2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>上面的代码就不会出现类似的错误了。Rust 语言<strong>对「动态」数据结构</strong>都有类似的功能安排：利用 Ownership 的设计思想，在没有垃圾回收的基础之上，避免内存错误。</p>\n<h2 id=\"小结\"><a href=\"#%E5%B0%8F%E7%BB%93\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>小结</h2>\n<p>Rust 的确是一门神奇的语言，不仅拥有 C、C++ 等系统级别语言的高效迅速，还利用 Ownership 的设计思想保证了内存安全。上面仅仅是 Rust 语言中一个小小的独特之处，由于这一特性所保证的功能我在其他语言中也有过类似的体验（比如 Python 的 deep copy 与 shallow copy<sup id=\"fnref-5\"><a href=\"#fn-5\" class=\"footnote-ref\">5</a></sup>），因此拿来和大家分享。Rust 还有更多有趣的设计与内容等待大家发掘。感谢阅读。</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">\n<p><a href=\"https://stackoverflow.blog/2020/01/20/what-is-rust-and-why-is-it-so-popular/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">What is Rust and why is it so popular? - Stack Overflow Blog</a></p>\n<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-2\">\n<p><a href=\"https://www.reddit.com/r/rust/comments/5lg3ih/what_do_rusts_buzzwords_like_safe_and_zerocost/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">What do Rust's buzzwords like \"safe\" and \"zero-cost abstraction\" mean?</a></p>\n<a href=\"#fnref-2\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-3\">\n<p><a href=\"https://medium.com/@thomascountz/ownership-in-rust-part-1-112036b1126b\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Ownership in Rust, Part 1 - Medium</a></p>\n<a href=\"#fnref-3\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-4\">\n<p><a href=\"https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">The Rust Programming Language - Understanding Ownership</a></p>\n<a href=\"#fnref-4\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-5\">\n<p><a href=\"https://www.geeksforgeeks.org/copy-python-deep-copy-shallow-copy/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">copy in Python (Deep Copy and Shallow Copy) - GeeksforGeeks</a></p>\n<a href=\"#fnref-5\" class=\"footnote-backref\">↩</a>\n</li>\n</ol>\n</div>\n"}}]}}},"context":{}}