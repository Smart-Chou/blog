{"hash":"adc5dd754921ba01e034b10e05b52eb94e7d1500","data":{"tag":{"title":"Algorithm","belongsTo":{"edges":[{"node":{"title":"Time Complexity：CPython 实现的 Python 操作的时间复杂度","path":"/2020/08/cpython-implemented-python-time-complexity/","date":"August 20. 2020","timeToRead":12,"cjkWordCount":2721,"cjkReadTime":12,"description":"「哎！这也能直接用！那也能直接用！快排都不用我手写了！」","content":"<blockquote>\n<p>🧊 我算法实在太菜了，本文部分内容可能是小学二年级就应该知道的东西，所以如果各位大佬看到这篇文章的话，就当看个乐呵，还请不要嫌弃 555。(⊙﹏⊙)</p>\n</blockquote>\n<p>这篇文章起源于各大 OJ 平台可能是最经典的一道题：<a href=\"https://leetcode.com/problems/two-sum\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Two Sum（两数之和）</a>。我已经<strong>很久很久</strong>（可能已经有两年了）没做算法题了，由于我之前的项目里面其实很少涉及到一些比较复杂的算法，各个语言和框架的封装也让我对具体程序逻辑的优化放松了警惕，导致我对我写的代码的性能非常不敏感。于是我在前几天准备秒掉 TwoSums 的时候，就出现了极为尴尬的情况（提交顺序自下而上）：</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/08/200819_223330.png\" alt=\"嗯，第一发正式比赛应该直接就 TLE 了，真实的菜\"><figcaption>嗯，第一发正式比赛应该直接就 TLE 了，真实的菜</figcaption></figure>\n<p>感觉自己被自己的水平羞辱到之后，我开始仔细找到 Python 官方文档里面对各个 native 数据结构操作的时间复杂度介绍，并也着手尝试通过巧妙的办法寻找时间优化方法，于是便有了这篇文章。</p>\n<h2 id=\"基础知识\"><a href=\"#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>基础知识</h2>\n<h3 id=\"cpython\"><a href=\"#cpython\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>CPython</h3>\n<p>先来介绍一些基础知识。Python 是一门动态语言（Dynamic language），也就是说：Python 在执行过程中是 Python 解释器对每一条 Python 代码进行翻译再运行，而不是像静态语言，比如 C、C++ 等，被编译为 native binary 后再执行的。其中，CPython 就是一个用 C 语言实现的 Python 解释器，也就是我们默认从官网安装 Python 时得到的那个最传统、最经典的 Python 解释器（但是性能表现并不算优秀）。</p>\n<h3 id=\"时间复杂度\"><a href=\"#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>时间复杂度</h3>\n<p>为了准确的表达或衡量我们算法的执行时间，我们常常采用大 O 表示法，也就是 Big-O notation，来表达时间复杂度。比如 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> 表示常数时间、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(\\log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">)</span></span></span></span> 表示对数时间、<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">)</span></span></span></span> 表示线性时间，等等。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/08/200819_230352.png\" alt=\"来自：https://www.bigocheatsheet.com\"><figcaption>来自：https://www.bigocheatsheet.com</figcaption></figure>\n<h2 id=\"cpython-实现的-python-操作的时间复杂度\"><a href=\"#cpython-%E5%AE%9E%E7%8E%B0%E7%9A%84-python-%E6%93%8D%E4%BD%9C%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>CPython 实现的 Python 操作的时间复杂度</h2>\n<p>CPython 是 Python 官方的解释器，也是我们最为常用的 Python 解释器。我重点研究了官方给出的 CPython 实现的几个 Python 原生数据结构操作的时间复杂度<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup>，本文我把重点放在列表 <code class=\"language-text\">list</code> 和字典 <code class=\"language-text\">dict</code> 这两种数据结构上。</p>\n<h3 id=\"列表-list\"><a href=\"#%E5%88%97%E8%A1%A8-list\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>列表 <code class=\"language-text\">list</code></h3>\n<p>Python 中的列表 <code class=\"language-text\">list</code> 是一个非常典型的数据结构，也是我们在 Python 里面最常用的一个数据结构。内部实现中，Python 的列表是用动态数组 — dynamic array<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup>来实现的（而非链表）。在 CPython 中，Python 的列表实际上这样的一个 C 语言结构体：</p>\n<pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">typedef</span> <span class=\"token keyword\">struct</span> <span class=\"token punctuation\">{</span>\n    PyObject_VAR_HEAD<span class=\"token punctuation\">;</span>\n    PyObject <span class=\"token operator\">*</span><span class=\"token operator\">*</span>ob_item<span class=\"token punctuation\">;</span>\n    Py_ssize_t allocated<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span> PyListObject<span class=\"token punctuation\">;</span></code></pre>\n<p>其中，<code class=\"language-text\">**ob_item</code> 是指向列表中每个项目的一组指针，<code class=\"language-text\">allocated</code> 是为列表在内存中分配的空间格数（可以理解为一个列表项目一格）。</p>\n<p>CPython 实现的 Python 列表数据结构决定了 Python 列表各种操作的时间复杂度。很容易理解下面常见的「列表操作」的时间复杂度<sup id=\"fnref-6\"><a href=\"#fn-6\" class=\"footnote-ref\">6</a></sup>：</p>\n<ul>\n<li>向列表末尾插入元素 <code class=\"language-text\">.append(x)</code>、移除列表末尾元素 <code class=\"language-text\">.pop()</code> 的时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>；</li>\n<li>向列表中任意位置插入元素 <code class=\"language-text\">.insert(idx)</code>，移除列表中<strong>任意元素</strong> <code class=\"language-text\">.remove(x)</code>，移除列表中<strong>任意位置的元素</strong> <code class=\"language-text\">.pop(idx)</code> 的时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">)</span></span></span></span>；</li>\n<li>查询列表包含 / 不包含元素：<code class=\"language-text\">x in/not in l</code> 时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">)</span></span></span></span>（线性查找）；</li>\n<li>典型的列表排序 <code class=\"language-text\">.sort()</code> 的时间复杂度为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n\\log n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">n</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mop\">lo<span style=\"margin-right:0.01389em;\">g</span></span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">)</span></span></span></span>。</li>\n</ul>\n<h3 id=\"字典-dict\"><a href=\"#%E5%AD%97%E5%85%B8-dict\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>字典 <code class=\"language-text\">dict</code></h3>\n<p>字典，也就是 Python 的 dictionaries —— <code class=\"language-text\">dict</code>，是一种索引数据结构，且是通过 <code class=\"language-text\">dict</code> 的键 —— <code class=\"language-text\">keys</code> 进行索引，我们可以将其看作是关联性数组（Associative arrays）。在 CPython 内部，<code class=\"language-text\">dict</code> 是利用 Hash Table（哈希表）来实现的，也就是说：Python 字典是一个数组，其索引是使用每个 <code class=\"language-text\">key</code> 上的哈希函数获得的。</p>\n<p>另外，实际上在 Hash Table 中，当我们使用一些较为复杂的随机哈希函数时，我们的主要目的是为了让设定的 <code class=\"language-text\">key</code> 的哈希能够在数组中均匀分布，同时最小化哈希冲突（Hash collisions），避免多个 <code class=\"language-text\">key</code> 对应同一个哈希值。然而 Python 的哈希函数实现则比较简单，实际也并不具备这种特性，我们可以尝试：</p>\n<pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># Hash integers</span>\n<span class=\"token builtin\">list</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">hash</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">,</span> <span class=\"token number\">3</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\"># Hash strings</span>\n<span class=\"token builtin\">list</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">map</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">hash</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"b\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"c\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"d\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/08/200820_000117.png\" alt=\"Python 默认哈希函数对整数和字符串的处理\"><figcaption>Python 默认哈希函数对整数和字符串的处理</figcaption></figure>\n<p>不过，Python 在 <code class=\"language-text\">dict</code> 中所使用的这样的 <code class=\"language-text\">hash</code> 函数，对于常见的具有连续 <code class=\"language-text\">key</code> 的 <code class=\"language-text\">dict</code> 则是被证明非常高效，不容易产生冲突的。当然，冲突还是避免不了，因此 Python 在 <code class=\"language-text\">dict</code> 实现中为了解决冲突（Collision resolution），会通过「开放地址法」来为冲突地址重新分配<sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup>。</p>\n<p>好了，讲了这么多，我们的重点还是在于 Python 字典数据结构存储「键值对」的<strong>哈希表 Hash Table 实现</strong>。在实际 CPython（以及 PyPy<sup id=\"fnref-4\"><a href=\"#fn-4\" class=\"footnote-ref\">4</a></sup>）中，Python 字典是使用如下的 C 语言结构体定义的：</p>\n<pre class=\"language-c\"><code class=\"language-c\"><span class=\"token keyword\">struct</span> <span class=\"token class-name\">dict</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">long</span> num_items<span class=\"token punctuation\">;</span>\n    variable_int <span class=\"token operator\">*</span>sparse_array<span class=\"token punctuation\">;</span>\n    dict_entry<span class=\"token operator\">*</span> compact_array<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">struct</span> <span class=\"token class-name\">dict_entry</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">long</span> hash<span class=\"token punctuation\">;</span>\n    PyObject <span class=\"token operator\">*</span>key<span class=\"token punctuation\">;</span>\n    PyObject <span class=\"token operator\">*</span>value<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>其中的 <code class=\"language-text\">dict_entry</code> 就是存储我们字典中「键值对」的数据结构了。使用 Hash Table 实现的 <code class=\"language-text\">dict</code> 字典能够极为高效的实现数据存取，也就是说<sup id=\"fnref-6\"><a href=\"#fn-6\" class=\"footnote-ref\">6</a></sup>：</p>\n<ul>\n<li>根据 <code class=\"language-text\">key</code> 获取字典中的 <code class=\"language-text\">value</code> 的 <code class=\"language-text\">d[k]</code> 或 <code class=\"language-text\">d.get(k)</code> 时间复杂度均为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>；</li>\n<li>设定某个 <code class=\"language-text\">key</code> 的值 <code class=\"language-text\">value</code> 的 <code class=\"language-text\">d[k] = v</code> 的时间复杂度也为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>；</li>\n<li>查询字典中是否包括某个 <code class=\"language-text\">key</code> 的 <code class=\"language-text\">k in/not in d</code> 的时间复杂度依旧为 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>；</li>\n<li>甚至于获取整个字典的全部 <code class=\"language-text\">keys</code> 的 <code class=\"language-text\">d.keys()</code> 的时间复杂度还是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span>！</li>\n</ul>\n<p>大部分 Python 字典的操作时间复杂度都是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span> 的，因此使用「字典」作为我们的数据载体往往能够极大的提升我们算法的执行效率。当然，其他语言的 Hash Table（比如 Java 的 <code class=\"language-text\">HashSet</code>、JavaScript 的 Object）实现同样也有类似的效果。</p>\n<h2 id=\"疏忽导致的性能问题和解决措施\"><a href=\"#%E7%96%8F%E5%BF%BD%E5%AF%BC%E8%87%B4%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E6%8E%AA%E6%96%BD\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>疏忽导致的性能问题和解决措施</h2>\n<h3 id=\"用-index-寻找列表中的元素序号\"><a href=\"#%E7%94%A8-index-%E5%AF%BB%E6%89%BE%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E5%BA%8F%E5%8F%B7\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>用 <code class=\"language-text\">index()</code> 寻找列表中的元素序号</h3>\n<p>讲完了 CPython 内部的列表与字典的实现，我们回到最初那道算法题。Two Sum 这道题本身其实非常简单，其中要求返回的是取得的两个数字在原列表中的 index：</p>\n<blockquote>\n<p>..., <strong>return indices of the two numbers</strong> such that they add up to a specific target.</p>\n</blockquote>\n<p>当时我并没多思考性能问题，为了简单的用一个函数同时判断数字是否存在于列表中，并返回数字在列表中的 index，我大胆使用 <code class=\"language-text\">.index()</code>！</p>\n<pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># ...</span>\n<span class=\"token keyword\">try</span><span class=\"token punctuation\">:</span>\n    partner_idx <span class=\"token operator\">=</span> nums<span class=\"token punctuation\">.</span>index<span class=\"token punctuation\">(</span>partner<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> idx <span class=\"token operator\">==</span> partner_idx<span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">continue</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>idx<span class=\"token punctuation\">,</span> partner_idx<span class=\"token punctuation\">]</span>\n<span class=\"token keyword\">except</span> ValueError<span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">continue</span>\n<span class=\"token comment\"># ...</span></code></pre>\n<p>Python 列表的 <code class=\"language-text\">.index(x)</code> 方法会遍历整个列表，并返回所求元素 <code class=\"language-text\">x</code> 第一次出现的 index，如果没有找到，那么会 raise 一个 <code class=\"language-text\">ValueError</code>。请大家看，我这里为了能用上 <code class=\"language-text\">.index()</code> 方法，甚至直接用 try except 异常处理来写，太憨憨了。<code class=\"language-text\">.index(x)</code> 需要遍历整个列表，因此这部分的时间复杂度是 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">)</span></span></span></span> 的，整个算法的时间复杂度就趋近于 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>，我的第一发 1224ms 的憨批运行时间也主要耽误在这里了。使用 <code class=\"language-text\">dict</code> 实现一个查找表，使用 <span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>n</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">)</span></span></span></span> 的时间，一次遍历即可完成查询：</p>\n<pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># ...</span>\n<span class=\"token keyword\">if</span> num <span class=\"token keyword\">not</span> <span class=\"token keyword\">in</span> lookup_dict<span class=\"token punctuation\">:</span>\n    lookup_dict<span class=\"token punctuation\">[</span>partner<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> idx\n<span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span>lookup_dict<span class=\"token punctuation\">[</span>num<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> idx<span class=\"token punctuation\">]</span>\n<span class=\"token comment\"># ...</span></code></pre>\n<h3 id=\"用-dgetk-与-dk-对字典进行访问\"><a href=\"#%E7%94%A8-dgetk-%E4%B8%8E-dk-%E5%AF%B9%E5%AD%97%E5%85%B8%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>用 <code class=\"language-text\">d.get(k)</code> 与 <code class=\"language-text\">d[k]</code> 对字典进行访问</h3>\n<p>除了上面这个问题以外，在使用 Python 字典的时候我还遇到了这样的问题。我们都知道其实根据键 <code class=\"language-text\">k</code> 来访问 Python 字典对应的值 <code class=\"language-text\">value</code> 时，用 <code class=\"language-text\">d.get(k)</code> 相比直接用 <code class=\"language-text\">d[k]</code> 算是更为优雅的一种方法<sup id=\"fnref-5\"><a href=\"#fn-5\" class=\"footnote-ref\">5</a></sup>：</p>\n<ul>\n<li>我们如果直接用 <code class=\"language-text\">d[k]</code> 访问一个不存在的 <code class=\"language-text\">k</code>，那么运行时 Python 会 raise 一个 <code class=\"language-text\">KeyError</code> 的错误，而 <code class=\"language-text\">d.get(k)</code> 则会优雅的返回 <code class=\"language-text\">None</code>；</li>\n<li>我们可以通过 <code class=\"language-text\">d.get(k, default_value)</code> 的语法来设定一个默认值，当 <code class=\"language-text\">k</code> 不存在时返回这一值即可；</li>\n</ul>\n<p>习惯于「优雅的解决方法一定更好」的我，在算法题里面同样用了 <code class=\"language-text\">d.get(k)</code> 来获取字典中的 value，但是我发现这样的方法要比同样的 <code class=\"language-text\">d[k]</code> 慢很多（提交顺序自下而上）：</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/08/200820_010904.png\" alt=\"80ms 的提交使用的是 .get(k)，而 48ms 的提交使用的是传统方法 d[k]\"><figcaption>80ms 的提交使用的是 .get(k)，而 48ms 的提交使用的是传统方法 d[k]</figcaption></figure>\n<p>当然，不用说我们也知道主要因为 Python 的 <code class=\"language-text\">d.get(k)</code> 实现中需要处理更多的事情，同时 <code class=\"language-text\">get()</code> 还是一个函数调用，需要入栈出栈，肯定会消耗更多的时间。因此，这里更需要我们注意，如果我们希望编写效率最高的代码，那么一定需要考虑这些会触发性能瓶颈的问题。</p>\n<div class=\"admonition admonition-warning\"><div class=\"admonition-heading\"><h5><div class=\"admonition-icon\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"12\" height=\"16\" viewBox=\"0 0 12 16\"><path fill-rule=\"evenodd\" d=\"M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z\"></path></svg></div>🍫 注意</h5></div><div class=\"admonition-content\"><p>但是我这里并不是在说 <code class=\"language-text\">d.get(k)</code> 方法不好，只是在「时间敏感」的地方，我们可以通过优化这种调用来大幅度提高我们程序的运行效率。</p></div></div>\n<h2 id=\"小结\"><a href=\"#%E5%B0%8F%E7%BB%93\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>小结</h2>\n<p>最初的时候我做算法题大部分都是用 C++ 编写的，从来都没尝试过用像 Python 这种抽象程度这么高的语言来做算法题。因此如果想要追求高性能，除了对数据结构有充分的了解，还需要对自己所使用语言的内部实现有所认知。我们在使用高级语言实现某些算法中，使用很多封装好的方法时，都需要对「算法本身」和「所使用的方法实现」这二者更深刻的认识才能最大化的发挥他们的功力。当然，使用 Python 来写算法题更多的还是快乐，比如：「哎！这也能直接用！那也能直接用！快排都不用我手写了！」开心 ~ 好啦，文章就到这里，感谢大家的阅读！</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">\n<p><a href=\"https://wiki.python.org/moin/TimeComplexity\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Python.org Wiki - TimeComplexity</a></p>\n<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-2\">\n<p><a href=\"https://stackoverflow.com/questions/3917574/how-is-pythons-list-implemented\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">StackOverflow - How is Python's List implemented?</a></p>\n<a href=\"#fnref-2\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-3\">\n<p><a href=\"https://github.com/python/cpython/blob/master/Objects/dictobject.c\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">GitHub - python/cpython - dictobject.c</a></p>\n<a href=\"#fnref-3\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-4\">\n<p><a href=\"https://morepypy.blogspot.com/2015/01/faster-more-memory-efficient-and-more.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Faster, more memory efficient and more ordered dictionaries on PyPy</a></p>\n<a href=\"#fnref-4\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-5\">\n<p><a href=\"https://stackoverflow.com/questions/11041405/why-dict-getkey-instead-of-dictkey\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">StackOverflow - Why dict.get(key) instead of dict[key]?</a></p>\n<a href=\"#fnref-5\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-6\">\n<p><a href=\"https://www.ics.uci.edu/~pattis/ICS-33/lectures/complexitypython.txt\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Complexity of Python Operations</a></p>\n<a href=\"#fnref-6\" class=\"footnote-backref\">↩</a>\n</li>\n</ol>\n</div>\n"}}]}}},"context":{}}