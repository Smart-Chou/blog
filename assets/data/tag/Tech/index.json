{"hash":"1a485f6dceb298c3ce36b831edab4aa62783906c","data":{"tag":{"title":"Tech","belongsTo":{"edges":[{"node":{"title":"VS Code Math to Image：在不支持 LaTeX 的地方插入数学公式","path":"/2020/08/vscode-math-to-image/","date":"August 4. 2020","timeToRead":9,"cjkWordCount":2040,"cjkReadTime":9,"description":"为了解决 GitHub 无法渲染 LaTeX 数学公式的问题，我们编写了一个 VS Code 插件。","content":"<div class=\"admonition admonition-note\"><div class=\"admonition-heading\"><h5><div class=\"admonition-icon\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"14\" height=\"16\" viewBox=\"0 0 14 16\"><path fill-rule=\"evenodd\" d=\"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z\"></path></svg></div>🛹 同步发布</h5></div><div class=\"admonition-content\"><ul>\n<li><strong>在少数派上阅读本文</strong> — <a href=\"https://sspai.com/post/61877\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">不支持 LaTeX 也能插入数学公式，这个小插件帮你实现「徒手渲染」</a>。</li>\n<li><strong>Read the English version on Medium</strong> — <a href=\"https://medium.com/spencerweekly/vs-code-math-to-image-write-latex-math-equations-in-github-markdown-the-easy-way-9fa8b81dc910?source=friends_link&#x26;sk=cff035b443fb81f5b20a47370f23aed3\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">VS Code Math to Image: Write LaTeX Math Equations in GitHub Markdown the Easy Way!</a></li>\n</ul></div></div>\n<p>作为每天都在跟数学公式打交道的工程师、数学家，如果我们想要将自己的学术成果开源并发布在网络平台上，那么这个平台至少要支持在 Markdown 里面用 LaTeX 撰写公式。可惜，想要直接在 Markdown 里面撰写数学公式就必须借助第三方库的帮助：比如 MathJax 和 KaTeX。</p>\n<p>因此很多常见的平台都尚未支持 LaTeX 数学公式的渲染，GitHub 就是其中一员——作为可能是世界上最大、最受欢迎的代码开源平台，GitHub 是很多研究人员开源自己学术成果的首选。如果我们想要在 GitHub 的 README 等 Markdown 文件里面撰写数学公式，就必须寻找别的办法。</p>\n<p>非常幸运的是：GitHub 允许我们在 Markdown 里面直接插入 SVG 图片（以及 HTML）。这也就意味着，我们可以先将手上的 LaTeX 数学公式渲染成 SVG，再手动将原来的数学公式替换成 SVG 图片，<strong>达成「徒手渲染 LaTeX 公式」的成就。</strong>💪</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/08/200804_132840.png\" alt=\"将 LaTeX 公式渲染为 SVG 后在 GitHub 上面的显示效果\"><figcaption>将 LaTeX 公式渲染为 SVG 后在 GitHub 上面的显示效果</figcaption></figure>\n<p>如何才能实现并自动化整个过程呢？为了尽量减少各位的麻烦，提升工作效率，我和同学专门编写了一个 VS Code 插件，用来自动将我们在 VS Code 里面选择的数学公式转换成 SVG 图片，并自动嵌入原位置 —— <strong>VS Code Math to Image：</strong></p>\n<ul>\n<li>目前，项目已经开源在 GitHub 上面：<a href=\"https://github.com/TeamMeow/vscode-math-to-image\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">GitHub — vscode-math-to-image</a>；</li>\n<li>同时 VS Code 插件也发布到了 Visual Studio Marketplace：<a href=\"https://marketplace.visualstudio.com/items?itemName=MeowTeam.vscode-math-to-image\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">VS Marketplace — Math to Image</a>；</li>\n</ul>\n<h2 id=\"插件安装\"><a href=\"#%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>插件安装</h2>\n<p>我们在 VS Code 的插件市场搜索 <code class=\"language-text\">vscode-math-to-image</code>，找到 Math to Image 点击安装即可。直接访问 <a href=\"https://marketplace.visualstudio.com/items?itemName=MeowTeam.vscode-math-to-image\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Visual Studio Marketplace</a> 点击 Install 也可以安装。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/08/200804_134114.png\" alt=\"VS Code 插件市场搜索：vscode-math-to-image\"><figcaption>VS Code 插件市场搜索：vscode-math-to-image</figcaption></figure>\n<h2 id=\"插件使用\"><a href=\"#%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>插件使用</h2>\n<p>我们成功安装插件之后，就可以直接非常方便地用插件将公式转换成可以显示在 GitHub 里面的 SVG 图片啦：</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/08/200804_133321.gif\" alt=\"使用 VSCode Math to Image 插件将公式渲染为 SVG\"><figcaption>使用 VSCode Math to Image 插件将公式渲染为 SVG</figcaption></figure>\n<p>具体来讲，比如上面演示动画里面的公式：</p>\n<pre class=\"language-latex\"><code class=\"language-latex\"><span class=\"token equation string\">$$\n<span class=\"token equation-command regex\">\\ell</span> = <span class=\"token equation-command regex\">\\sum</span>_{i}^{N}(y_i - <span class=\"token equation-command regex\">\\hat</span>{y}_i)^2 - ||w||_2^2\n$$</span></code></pre>\n<span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">ℓ</mi><mo>=</mo><munderover><mo>∑</mo><mi>i</mi><mi>N</mi></munderover><mo stretchy=\"false\">(</mo><msub><mi>y</mi><mi>i</mi></msub><mo>−</mo><msub><mover accent=\"true\"><mi>y</mi><mo>^</mo></mover><mi>i</mi></msub><msup><mo stretchy=\"false\">)</mo><mn>2</mn></msup><mo>−</mo><mi mathvariant=\"normal\">∣</mi><mi mathvariant=\"normal\">∣</mi><mi>w</mi><mi mathvariant=\"normal\">∣</mi><msubsup><mi mathvariant=\"normal\">∣</mi><mn>2</mn><mn>2</mn></msubsup></mrow><annotation encoding=\"application/x-tex\">\\ell = \\sum_{i}^{N}(y_i - \\hat{y}_i)^2 - ||w||_2^2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord\">ℓ</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:3.106005em;vertical-align:-1.277669em;\"></span><span class=\"mop op-limits\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.8283360000000002em;\"><span style=\"top:-1.872331em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span style=\"top:-3.050005em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span><span class=\"mop op-symbol large-op\">∑</span></span></span><span style=\"top:-4.3000050000000005em;margin-left:0em;\"><span class=\"pstrut\" style=\"height:3.05em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.10903em;\">N</span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.277669em;\"><span></span></span></span></span></span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1141079999999999em;vertical-align:-0.25em;\"></span><span class=\"mord\"><span class=\"mord accent\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.69444em;\"><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">y</span></span></span><span style=\"top:-3em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"accent-body\" style=\"left:-0.19444em;\"><span class=\"mord\">^</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.19444em;\"><span></span></span></span></span></span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.31166399999999994em;\"><span style=\"top:-2.5500000000000003em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">i</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mclose\"><span class=\"mclose\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641079999999999em;\"><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">−</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.1141079999999999em;vertical-align:-0.25em;\"></span><span class=\"mord\">∣</span><span class=\"mord\">∣</span><span class=\"mord mathdefault\" style=\"margin-right:0.02691em;\">w</span><span class=\"mord\">∣</span><span class=\"mord\"><span class=\"mord\">∣</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8641079999999999em;\"><span style=\"top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span><span style=\"top:-3.113em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">2</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.247em;\"><span></span></span></span></span></span></span></span></span></span></span>\n<p>正常在 Markdown 中我们是会直接用上面的语法让支持渲染 LaTeX 的编辑器渲染公式的，比如 VS Code 默认的 Markdown 预览视图就支持 LaTeX 数学公式的渲染。如果这一 Markdown 文件里面的公式需要在 GitHub 上显示，那么我们就需要用插件将公式渲染成 SVG。我们直接选择这三行 LaTeX 公式代码（包含第一行和第三行的 <code class=\"language-text\">$$</code>），右键并在菜单中选择「Math » Image: Insert rendered equation (local)」或者「Math » Image: Insert rendered equation (remote)」，之后插件就会将我们选中的公式自动注释掉，并在下方添加相应的 SVG 图片引用。（插件里面 <code class=\"language-text\">local</code> 和 <code class=\"language-text\">remote</code> 两个选项工作原理不同，请见后文。）</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/08/200804_133228.png\" alt=\"选择公式右键后在菜单中选择渲染选项\"><figcaption>选择公式右键后在菜单中选择渲染选项</figcaption></figure>\n<p>此时，我们可以发现在 VS Code 的 Markdown 预览界面里面，SVG 图片形式的 LaTeX 公式依旧能够成功渲染，同时这一公式在 GitHub 等仍然不支持 LaTeX 的平台也能正常展现，nice！</p>\n<h2 id=\"工作原理\"><a href=\"#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>工作原理</h2>\n<p>所以，我们插件是如何将一个纯文本格式的 LaTeX 数学公式渲染为 SVG 图片的呢？前面提到的 <code class=\"language-text\">remote</code> 和 <code class=\"language-text\">local</code> 又有怎样的区别呢？这里，我就简单讲解一下插件的渲染和工作原理。</p>\n<p>首先，插件的工作原理非常简单、极易理解，我们实际上就是通过某种方式，解析 LaTeX 撰写的数学公式并将之渲染为 SVG， <code class=\"language-text\">remote</code> 和 <code class=\"language-text\">local</code> 的不同之处就在于：</p>\n<ul>\n<li>前者是借助服务器渲染公式，生成的 SVG 存在于云端；</li>\n<li>后者是直接在本地渲染公式，生成的 SVG 当然也保存于本地；</li>\n</ul>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/08/200804_133452.png\" alt=\"VSCode Math to Image 插件的简单工作原理\"><figcaption>VSCode Math to Image 插件的简单工作原理</figcaption></figure>\n<h3 id=\"将公式借助服务器渲染为云端-svg-图片\"><a href=\"#%E5%B0%86%E5%85%AC%E5%BC%8F%E5%80%9F%E5%8A%A9%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%B8%B2%E6%9F%93%E4%B8%BA%E4%BA%91%E7%AB%AF-svg-%E5%9B%BE%E7%89%87\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>将公式借助服务器渲染为云端 SVG 图片</h3>\n<p>虽然 GitHub 的 README 等 Markdown 文件里面并不支持 LaTeX 数学公式的渲染，但是：<strong>GitHub 确实会在 Jupyter notebook 里面解析并正常渲染 LaTeX 数学公式！</strong>那既然 GitHub 并没有引用第三方的渲染服务，它们究竟是怎样渲染数学公式的呢？答案是：GitHub 有自己的 LaTeX 渲染服务器，我们给这一服务器一个格式正确的 LaTeX 公式，服务器会直接给我们返回渲染好的 SVG 图片。</p>\n<p>嚯，我们要的正好就是这个服务啊！所以，我们插件的 <code class=\"language-text\">remote</code> 选项，就是借助 GitHub 官方的 LaTeX 渲染服务器，将我们的 LaTeX 数学公式转换为云端 SVG 图片。简单来说，比如下面这个标准正态分布公式：</p>\n<pre class=\"language-latex\"><code class=\"language-latex\"><span class=\"token equation string\">$$\nP(x) = <span class=\"token equation-command regex\">\\frac</span>{1}{<span class=\"token equation-command regex\">\\sigma</span><span class=\"token equation-command regex\">\\sqrt</span>{2<span class=\"token equation-command regex\">\\pi</span>}} e^{<span class=\"token equation-command regex\">\\frac</span>{-(x-<span class=\"token equation-command regex\">\\mu</span>)^2}{2<span class=\"token equation-command regex\">\\sigma</span>^2}}\n$$</span></code></pre>\n<span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mstyle mathsize=\"1.44em\"><mi>P</mi><mo stretchy=\"false\">(</mo><mi>x</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mi>σ</mi><msqrt><mrow><mn>2</mn><mi>π</mi></mrow></msqrt></mrow></mfrac><msup><mi>e</mi><mfrac><mrow><mo>−</mo><mo stretchy=\"false\">(</mo><mi>x</mi><mo>−</mo><mi>μ</mi><msup><mo stretchy=\"false\">)</mo><mn>2</mn></msup></mrow><mrow><mn>2</mn><msup><mi>σ</mi><mn>2</mn></msup></mrow></mfrac></msup></mstyle></mrow><annotation encoding=\"application/x-tex\">\\Large P(x) = \\frac{1}{\\sigma\\sqrt{2\\pi}} e^{\\frac{-(x-\\mu)^2}{2\\sigma^2}}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.44em;vertical-align:-0.36em;\"></span><span class=\"mord mathdefault sizing reset-size6 size8\" style=\"margin-right:0.13889em;\">P</span><span class=\"mopen sizing reset-size6 size8\">(</span><span class=\"mord mathdefault sizing reset-size6 size8\">x</span><span class=\"mclose sizing reset-size6 size8\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel sizing reset-size6 size8\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:3.2420736em;vertical-align:-1.3392em;\"></span><span class=\"mord sizing reset-size6 size8\"><span class=\"mopen nulldelimiter sizing reset-size8 size6\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.32144em;\"><span style=\"top:-2.6427799999999997em;\"><span class=\"pstrut\" style=\"height:3.44em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">σ</span><span class=\"mord sqrt\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.90722em;\"><span class=\"svg-align\" style=\"top:-3.44em;\"><span class=\"pstrut\" style=\"height:3.44em;\"></span><span class=\"mord\" style=\"padding-left:0.833em;\"><span class=\"mord\">2</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">π</span></span></span><span style=\"top:-3.30722em;\"><span class=\"pstrut\" style=\"height:3.44em;\"></span><span class=\"hide-tail\" style=\"min-width:0.853em;height:1.08em;\"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl0 -0\nc5.3,-9.3,12,-14,20,-14\nH400000v40H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM834 80h400000v40h-400000z'/></svg></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.13278em;\"><span></span></span></span></span></span></span></span><span style=\"top:-3.67em;\"><span class=\"pstrut\" style=\"height:3.44em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-4.117em;\"><span class=\"pstrut\" style=\"height:3.44em;\"></span><span class=\"mord\"><span class=\"mord\">1</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.93em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter sizing reset-size8 size6\"></span></span><span class=\"mord sizing reset-size6 size8\"><span class=\"mord mathdefault\">e</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.2876916666666667em;\"><span style=\"top:-3.428102777777778em;margin-right:0.034722222222222224em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size8 size6 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.237808em;\"><span style=\"top:-2.538692em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">2</span><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03588em;\">σ</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.9304399999999999em;\"><span style=\"top:-2.986em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line mtight\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.485em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">−</span><span class=\"mopen mtight\">(</span><span class=\"mord mathdefault mtight\">x</span><span class=\"mbin mtight\">−</span><span class=\"mord mathdefault mtight\">μ</span><span class=\"mclose mtight\"><span class=\"mclose mtight\">)</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:1.07544em;\"><span style=\"top:-3.1310000000000002em;margin-right:0.07142857142857144em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"mord mtight\">2</span></span></span></span></span></span></span></span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.4613079999999999em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span></span></span></span></span></span></span></span></span></span>\n<p>我们可以借助插件直接将其转换为用 GitHub 服务器渲染的 SVG 图片，并用 <code class=\"language-text\">&lt;img&gt;</code> 标签插入 Markdown 之中：</p>\n<pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">align</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>center<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>img</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>https://render.githubusercontent.com/render/math?math=P(x)%20%3D%20%5Cfrac%7B1%7D%7B%5Csigma%5Csqrt%7B2%5Cpi%7D%7D%20e%5E%7B%5Cfrac%7B-(x-%5Cmu)%5E2%7D%7B2%5Csigma%5E2%7D%7D%0D<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span></code></pre>\n<p>这样，我们原公式就被替换为用 GitHub 服务器渲染好的 SVG 图片：</p>\n<figure>\n  <img src=\"https://cdn.spencer.felinae98.cn/blog/2020/08/200804_134758.png\" alt=\"标准正态分布公式（GitHub LaTeX 渲染服务器渲染得到的 SVG 图片）\" width=\"300px\" >\n  <figcaption>标准正态分布公式（GitHub LaTeX 渲染服务器渲染得到的 SVG 图片）</figcaption>\n</figure>\n<p>同时，由于渲染服务器正好是 GitHub 自己的，所以肯定不会出现被屏蔽、无法访问的现象，非常靠谱。</p>\n<h3 id=\"将公式在本地渲染并直接保存为-svg-图片\"><a href=\"#%E5%B0%86%E5%85%AC%E5%BC%8F%E5%9C%A8%E6%9C%AC%E5%9C%B0%E6%B8%B2%E6%9F%93%E5%B9%B6%E7%9B%B4%E6%8E%A5%E4%BF%9D%E5%AD%98%E4%B8%BA-svg-%E5%9B%BE%E7%89%87\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>将公式在本地渲染并直接保存为 SVG 图片</h3>\n<p>SVG 这一格式非常强大，不仅是矢量图的格式标准，我们还可以在其中添加动画等高级功能。所以实际上，SVG 格式的图片会给网站带来一些安全隐患，也正因为 SVG 的这一特点，导致并非所有的地方都支持外部 SVG 的引用。为了规避这一问题，也为了让 SVG 文件的存在更可控（服务器还是有宕机的风险），我们也实现了 LaTeX 公式「本地渲染」的功能。</p>\n<p>我们插件的 <code class=\"language-text\">local</code> 功能实际上就是借助 MathJax 在本地直接将 LaTeX 公式渲染为本地 SVG 图片。这样，我们就可以将这个保存于本地的 SVG 直接在 Markdown 文件里面引用显示，同样方便。</p>\n<p>继续用上面标准正态分布的公式，我们可以将公式渲染为存储于本地的 SVG：<code class=\"language-text\">svg/e40qQ5G9jw.svg</code>，并直接保存在 Markdown 文件相邻的一个 <code class=\"language-text\">svg</code> 文件夹中。这样，我们就可以继续用 <code class=\"language-text\">&lt;img&gt;</code> 标签将这个本地 SVG 插入我们的 Markdown 之中：</p>\n<pre class=\"language-html\"><code class=\"language-html\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>div</span> <span class=\"token attr-name\">align</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>center<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>img</span> <span class=\"token attr-name\">src</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>svg/e40qQ5G9jw.svg<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">/></span></span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>div</span><span class=\"token punctuation\">></span></span></code></pre>\n<figure>\n  <img src=\"https://cdn.spencer.felinae98.cn/blog/2020/08/200804_134658.png\" alt=\"标准正态分布（本地使用 MathJax 渲染得到的 SVG 图片）\" width=\"300px\" >\n  <figcaption>标准正态分布（本地使用 MathJax 渲染得到的 SVG 图片）</figcaption>\n</figure>\n<h2 id=\"小结\"><a href=\"#%E5%B0%8F%E7%BB%93\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>小结</h2>\n<p>以上就是 VS Code Math to Image 这个 VS Code 插件的简单介绍，两种方法（<code class=\"language-text\">remote</code> 和 <code class=\"language-text\">local</code>）都可以帮我们渲染出高质量的 SVG 公式图片，这样我们就可以解决 GitHub 等平台不支持数学公式渲染的一大难题啦！如果你觉得我们的插件非常有用，那么 <a href=\"https://github.com/TeamMeow/vscode-math-to-image\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">一定要去 GitHub 给我们点上一个 Star</a>，如果 <a href=\"https://marketplace.visualstudio.com/items?itemName=MeowTeam.vscode-math-to-image&#x26;ssr=false#review-details\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">能去 VS Marketplace 给我们个五星好评</a> 那就更棒啦。</p>\n"}},{"node":{"title":"Hit count：用 Google Analytics + Vercel Serverless 为文章添加浏览量统计","path":"/2020/06/serverless-ga-hit-count-api/","date":"June 25. 2020","timeToRead":10,"cjkWordCount":2571,"cjkReadTime":12,"description":"借助 Google Analytics 为数据支撑，使用 Vercel Serverless 为静态博客添加文章阅读数量统计 API。","content":"<div class=\"admonition admonition-note\"><div class=\"admonition-heading\"><h5><div class=\"admonition-icon\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"14\" height=\"16\" viewBox=\"0 0 14 16\"><path fill-rule=\"evenodd\" d=\"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z\"></path></svg></div>🍍 编者按</h5></div><div class=\"admonition-content\"><p>本文灵感和部分方法极大程度来源于 @printempw 的文章：<a href=\"https://printempw.github.io/google-analytics-api-page-views-counter/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">使用 Google Analytics API 实现博客阅读量统计</a>，感谢。(　o=^•ェ•)o</p></div></div>\n<p>静态网站是没有后端服务的，仅有一个前端页面用来渲染网站的全部内容。虽然从部署、管理和访问速度的角度来说，静态网站还是有点优势的，但是没有后端就意味着没有「评论系统」、「浏览量统计」、「登录鉴权」等等功能。如果想要实现这些功能，就必须依赖第三方的服务，才能实现类似的需要。许多同学都像我一样：在自己的博客网站里使用 Google Analytics 用来统计访问量和阅读数，因此对于「浏览量统计」这个功能来说，我们其实可以借助 Google Analytics API 来将我们在管理后台看到的部分数据显示在网站前端里面，从而实现「文章访问、阅读数量」显示的功能。</p>\n<h2 id=\"工作原理\"><a href=\"#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>工作原理</h2>\n<p>Google Analytics 非常强大，能够从非常多的维度来解读你网站的访客来源、浏览量、浏览设备等多种数据。这里当我们进入 Google Analytics 管理后台，在首页我们就可以看到我们网站每个路径在特定时间段之中的浏览数量。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-213128.png\" alt=\"Google Analytics 管理后台中我的博客上周 7 天的每个路径浏览数\"><figcaption>Google Analytics 管理后台中我的博客上周 7 天的每个路径浏览数</figcaption></figure>\n<p>实际上我们需要的就是这个数据。幸好，Google Analytics 提供了类似的 API，可以让我们根据页面路径、时间起止等参数来查询浏览数量。不过 Google Analytics 的原始 API 其实还是比较复杂的，而且其本身在国内访问还是不太顺畅，所以为了减轻我们静态网站前端的负担，<strong>我们可以在 Vercel 上面用 Serverless 方案部署一个 API 中转站</strong>，方便我们静态网站调用，从而实现「文章浏览量显示」的功能。</p>\n<h2 id=\"开启-google-analytics-api\"><a href=\"#%E5%BC%80%E5%90%AF-google-analytics-api\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>开启 Google Analytics API</h2>\n<p>我们在 Google Analytics 中调用自己网站的分析数据时，需要首先开启 Google Analytics API，获取到鉴权密钥，才可以正常调用 API。我们可以根据 Google 官方教程：<a href=\"https://developers.google.com/analytics/devguides/reporting/core/v4/quickstart/service-py#1_enable_the_api\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Analytics Reporting API v4 - Enable the API</a>，或按照下面的办法来开启我们账户的 Google Analytics API：</p>\n<ul>\n<li>首先，前往官方 API 的 <a href=\"https://console.developers.google.com/start/api?id=analyticsreporting.googleapis.com&#x26;credential=client_key\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">setup tools</a> 并根据提示进行设置，选择一个项目（或创建新的项目，比如 <code class=\"language-text\">ga-hit-count</code>），之后选择 Continue，就可以为我们这一项目开启 Google API 了；\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-213128-1.png\" alt=\"为我们的项目开启 Google API\"><figcaption>为我们的项目开启 Google API</figcaption></figure></li>\n<li>接下来，我们会进入 Google API 的 Credentials 设置页面，这里我们首先设置 API 为 Analytics Reporting API，并选择 API 调用方为 Web server，再选择调用数据类型为 Application data，最后选择「不会使用 App Engine 或 Compute Engine」即可；\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-213128-2.png\" alt=\"设置 Google API 类型\"><figcaption>设置 Google API 类型</figcaption></figure></li>\n<li>最后，我们设置基本信息，获取 Credentials 文件。我们设置 Service account name 的名字（比如 <code class=\"language-text\">blog-analytics</code>），设置 Role 为 <code class=\"language-text\">Service Account User</code>，选择 Key type 为 JSON，即可获取 API 凭证，点击 Continue 之后你就可以下载到这一 JSON 格式的 API 凭证文件了。 <figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-213128-3.png\" alt=\"设置 API 凭证信息\"><figcaption>设置 API 凭证信息</figcaption></figure></li>\n</ul>\n<p>我们获取到的 JSON 文件里面应该包含有以下的重要信息：</p>\n<pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n  <span class=\"token property\">\"project_id\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"ga-hit-count\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"private_key\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"-----BEGIN PRIVATE KEY-----\\nxxx-----END PRIVATE KEY-----\\n\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"client_email\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"blog-hit-count@ga-hit-count.iam.gserviceaccount.com\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>其中，我们重点关注的就是这三个 API 凭证信息：项目 ID <code class=\"language-text\">project_id</code>、凭证私钥 <code class=\"language-text\">private_key</code> 以及客户邮箱 <code class=\"language-text\">client_email</code>。其中 <code class=\"language-text\">private_key</code> 是我们 API 访问的重要凭证，需要妥善保管，也一定不能签入 <code class=\"language-text\">git</code>。另外，我们需要将 <code class=\"language-text\">client_email</code> 定义的邮箱<strong>作为新用户加入 Google Analytics 后台</strong>，从而让这一邮箱访问到我们 Google Analytics 的数据。详见：<a href=\"https://support.google.com/analytics/answer/1009702\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Add, edit, and delete users and user groups</a>。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-213128-4.png\" alt=\"将 client_email 的邮箱加入 Google Analytics 后台\"><figcaption>将 client_email 的邮箱加入 Google Analytics 后台</figcaption></figure>\n<h2 id=\"使用-vercel-自己部署-serverless-api-用于前端显示\"><a href=\"#%E4%BD%BF%E7%94%A8-vercel-%E8%87%AA%E5%B7%B1%E9%83%A8%E7%BD%B2-serverless-api-%E7%94%A8%E4%BA%8E%E5%89%8D%E7%AB%AF%E6%98%BE%E7%A4%BA\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>使用 Vercel 自己部署 Serverless API 用于前端显示</h2>\n<p>最后，我们就可以借助 Google Analytics API 在 Vercel 上部署中转 API 用于前端静态网站的调用。这里我使用 Node.js 和 Typescript 写好了一个非常简单的基础 Serverless API 项目，位于：<a href=\"https://github.com/spencerwooo/ga-hit-count-serverless\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">spencerwooo/ga-hit-count-serverless</a>，同学们可以直接 Fork 我的这一项目用来自己部署。其中，如果自己没有特殊需要，那么 Fork 项目之后我们仅需要修改 <code class=\"language-text\">api/config.ts</code> 里面的配置即可导入 Vercel 一键部署。</p>\n<h3 id=\"修改-ga-hit-count-serverless-的配置\"><a href=\"#%E4%BF%AE%E6%94%B9-ga-hit-count-serverless-%E7%9A%84%E9%85%8D%E7%BD%AE\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>修改 <code class=\"language-text\">ga-hit-count-serverless</code> 的配置</h3>\n<p>同学们将这一项目 Fork 至自己的 GitHub 账户上后，进入 <code class=\"language-text\">api/config.ts</code> 即可看到我自己的 API 配置，大致如下：</p>\n<pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token punctuation\">{</span>\n  viewId<span class=\"token operator\">:</span> <span class=\"token string\">'{Google Analytics view ID}'</span><span class=\"token punctuation\">,</span>\n  auth<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    projectId<span class=\"token operator\">:</span> <span class=\"token string\">'{Google API project ID}'</span><span class=\"token punctuation\">,</span>\n    privateKey<span class=\"token operator\">:</span> process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span><span class=\"token constant\">PRIVATE_KEY</span><span class=\"token punctuation\">,</span>\n    clientEmail<span class=\"token operator\">:</span> <span class=\"token string\">'{Google API client email}'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  allFilter<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'{Post path filter}'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  startDate<span class=\"token operator\">:</span> <span class=\"token string\">'{Google API query start date}'</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>其中，这些内容我们都需要一一进行设置：</p>\n<ul>\n<li><code class=\"language-text\">viewId</code>：是你的 Google Analytics 视图 ID，可以在 Google Analytics 后台的 Admin » View » View Settings 中找到；\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-213128-5.png\" alt=\"Google Analytics 视图 ID 的设定位置\"><figcaption>Google Analytics 视图 ID 的设定位置</figcaption></figure></li>\n<li><code class=\"language-text\">projectId</code>：是刚刚凭证 JSON 文件中的 <code class=\"language-text\">project_id</code>，直接按照刚刚的凭证填写即可；</li>\n<li><code class=\"language-text\">privateKey</code>：是通过 Vercel 环境变量获取到的 API 凭证私钥，<strong>这里不要更改</strong>；</li>\n<li><code class=\"language-text\">clientEmail</code>：是刚刚凭证 JSON 文件中的 <code class=\"language-text\">client_email</code>，直接按照刚刚的凭证填写即可；</li>\n<li><code class=\"language-text\">allFilter</code>：是通过 Google API 查询时的前缀过滤器，比如你的网站中文章路径以 <code class=\"language-text\">/post</code> 开头，那么就可以设置为 <code class=\"language-text\">[&#39;/post&#39;]</code>。默认为 <code class=\"language-text\">[&#39;/20&#39;]</code>（因为我的文章路径是以 <code class=\"language-text\">/2020</code> 或 <code class=\"language-text\">/2019</code> 开头的）；</li>\n<li><code class=\"language-text\">startDate</code>：是通过 Google API 查询时设定时间段的开始时间，设定一个比较久远的时间即可，默认为 <code class=\"language-text\">2010-01-01</code>。</li>\n</ul>\n<div class=\"admonition admonition-warning\"><div class=\"admonition-heading\"><h5><div class=\"admonition-icon\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"12\" height=\"16\" viewBox=\"0 0 12 16\"><path fill-rule=\"evenodd\" d=\"M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z\"></path></svg></div>🚨 请注意！</h5></div><div class=\"admonition-content\"><p>这里千万千万不要直接将刚刚凭证中获取到的私钥直接粘贴进入 <code class=\"language-text\">privateKey</code> 一项之中，因为这样当我们将 <code class=\"language-text\">config.ts</code> 签入 <code class=\"language-text\">git</code> 之后，<code class=\"language-text\">privateKey</code> 将以明文形式保存，非常危险。</p></div></div>\n<h3 id=\"将项目导入-vercel\"><a href=\"#%E5%B0%86%E9%A1%B9%E7%9B%AE%E5%AF%BC%E5%85%A5-vercel\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>将项目导入 Vercel</h3>\n<p>Vercel（曾经的 ZEIT Now）是一个专注于部署 Jamstack 静态网页和 Serverless API 的服务，其官网位于 <a href=\"https://vercel.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Develop. Preview. Ship. - Vercel</a>。我们使用 GitHub 注册登录 Vercel 之后，仅需将刚刚 Fork 并修改好配置文件版本的 <code class=\"language-text\">ga-hit-count-serverless</code> 导入 Vercel 即可。Vercel 会自动的识别我们项目的环境，生成合适的编译、部署命令，自动将我们的 API 部署到 Vercel 的全球 CDN 上面，方便全世界随时随地的访问。</p>\n<p>但是此时我们并不能正常的使用我们自己部署的 API，因为 <code class=\"language-text\">privateKey</code> 尚未设置。我们需要进入刚刚在 Vercel 上部署好的项目设置中，选择 General » Environment Variables，向其中新增一个环境变量 <code class=\"language-text\">PRIVATE_KEY</code>。之后，我们将刚刚的 Google API JSON 凭证文件里面的私钥，<strong>复制其中的字符串部分，将 <code class=\"language-text\">\\n</code> 全部删掉并更换为换行</strong>，得到类似如下的多行私钥形式：</p>\n<pre class=\"language-text\"><code class=\"language-text\">-----BEGIN PRIVATE KEY-----\ndageWvAIBADANBAokdP8WgkqhkiGkk\n...\nafROdsafbliOjPA==1Hk3mdsafEdBa\n-----END PRIVATE KEY-----</code></pre>\n<p>我们复制这一私钥，再粘贴进入刚刚新建的 <code class=\"language-text\">PRIVATE_KEY</code> 的值。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-213128-6.png\" alt=\"在 Vercel 项目的设置中添加环境变量 PRIVATE_KEY，并存入我们的私钥凭证\"><figcaption>在 Vercel 项目的设置中添加环境变量 PRIVATE_KEY，并存入我们的私钥凭证</figcaption></figure>\n<p>之后，我们需要重新触发一次部署（比如随便向 GitHub 仓库中 commit 并 push 一些东西），完成后我们即可通过 Vercel 给我们提供的域名 <code class=\"language-text\">https://{VERCEL_DOMAIN_NAME}.vercel.app</code> 访问我们的 API。</p>\n<h3 id=\"使用-vercel-serverless-版-api\"><a href=\"#%E4%BD%BF%E7%94%A8-vercel-serverless-%E7%89%88-api\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>使用 Vercel Serverless 版 API</h3>\n<p>默认情况下，当我们直接访问 <code class=\"language-text\">https://{VERCEL_DOMAIN_NAME}.vercel.app</code> 时，因为没有设定 <code class=\"language-text\">index.html</code>，所以 Vercel 会将当前列表下的文件列出。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-213128-7.png\" alt=\"默认情况下直接访问 Vercel 上部署的 Serverless API 域名\"><figcaption>默认情况下直接访问 Vercel 上部署的 Serverless API 域名</figcaption></figure>\n<p>我们 API 的根域名实际上就是 <code class=\"language-text\">https://{VERCEL_DOMAIN_NAME}.vercel.app</code>。我们可以通过下面的默认请求（添加在 API 根域名后面）来访问 API：</p>\n<pre class=\"language-text\"><code class=\"language-text\">/api/ga</code></pre>\n<p>没有添加任何参数的情况下，默认这一 API 会将你的 Google Analytics 里面全部路径与访问量拉取并给出。以我自己博客为例，访问这一 API 会得到类似下面的 JSON response：</p>\n<pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">[</span>\n  <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"page\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"/2019/11/tiny-tiny-rss/\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"hit\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"698\"</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"page\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"/2019/11/weibo-to-twitter/\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"hit\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"531\"</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"page\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"/2020/03/ttrss-noteworthy/\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"hit\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"357\"</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">]</span></code></pre>\n<p>其中，我们可以看到返回的 response 中包含有我们网站中所有路径的 <code class=\"language-text\">hit</code> 阅读量数据，并且数据是按照阅读量递减来排列的。</p>\n<p>当我们需要直接请求网站中某一页面或某个特定路径的数据时，我们可以用这样的语法构造我们的请求：</p>\n<pre class=\"language-text\"><code class=\"language-text\">/api/ga?page={WEBSITE_PAGE_PATH}</code></pre>\n<p>其中请求的 field 为 <code class=\"language-text\">page</code>，参数为目标路径。比如这样的请求：</p>\n<pre class=\"language-text\"><code class=\"language-text\">/api/ga?page=/2020/03/substats/</code></pre>\n<p>将直接返回路径 <code class=\"language-text\">/2020/03/substats/</code> 的阅读量：</p>\n<pre class=\"language-text\"><code class=\"language-text\">[\n  {\n    &quot;page&quot;: &quot;/2020/03/substats/&quot;,\n    &quot;hit&quot;: &quot;311&quot;\n  }\n]</code></pre>\n<p>那么在此基础上，我们即可借助自己在 Vercel 上面部署的 API，来请求 Google Analytics 给我们当前路径的浏览量记录了。利用 <code class=\"language-text\">axios</code> 或者类似的前端 HTTP 请求库，我们可以非常轻松的请求我们部署的 Serverless API，并将结果进行处理，显示在我们的网站里面。你正在浏览的我的博客，就是利用这样的原理实现访问数据的显示。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-213128-8.png\" alt=\"用这样的方法在我自己博客上面显示文章的浏览量\"><figcaption>用这样的方法在我自己博客上面显示文章的浏览量</figcaption></figure>\n<p>到此，我们借助 Google Analytics 和 Vercel Serverless 为文章添加浏览量统计的功能就大功告成了。希望大家能用上本文的办法，为自己的静态博客网站快速添加上文章阅读量统计。感谢阅读 🍒</p>\n"}},{"node":{"title":"Substats：快速统计你在各个平台的关注者！","path":"/2020/03/substats/","date":"March 16. 2020","timeToRead":8,"cjkWordCount":1795,"cjkReadTime":8,"description":"Subscriber statistics：专注提供各个网站和社区里用户的订阅者、关注者、粉丝数量的 Serverless API","content":"<div class=\"admonition admonition-important\"><div class=\"admonition-heading\"><h5><div class=\"admonition-icon\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"14\" height=\"16\" viewBox=\"0 0 14 16\"><path fill-rule=\"evenodd\" d=\"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z\"></path></svg></div>SUBSTATS</h5></div><div class=\"admonition-content\"><p>Serverless Function to Count How Many People are Subscribed to You in Your Favorite Services.\n<strong>你只管调用，我们来帮你找订阅者！</strong></p></div></div>\n<p>在 <a href=\"https://blog.spencerwoo.com/2020/03/ttrss-noteworthy/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">上一篇文章</a> 里面，我在开头用 Feedly 的 API 和 Shields.io 制作了显示我 RSS 订阅数量的 Badge。这个 Badge 不仅是实时更新、动态加载的，还能轻松嵌入各个网页里面。</p>\n<p><a href=\"https://feedly.com/i/subscription/feed%2Fhttps%3A%2F%2Fblog.spencerwoo.com%2Fposts%2Findex.xml\"><img src=\"https://img.shields.io/badge/dynamic/json?color=2bb24c&amp;label=subscribers&amp;query=%24.source.subscribers&amp;url=https%3A%2F%2Ffeedly.com%2Fv3%2Frecommendations%2Ffeeds%2Ffeed%252Fhttps%253A%252F%252Fblog.spencerwoo.com%252Fposts%252Findex.xml&amp;logo=feedly&style=for-the-badge\" alt=\"\" style=\"display: inline; margin: 0 0.1rem 0 0; width: auto;\"></a></p>\n<p>但是，RSS 订阅服务不仅仅有 Feedly 一家，还有 Inoreader 和 NewsBlur 等等。单一个 Feedly 提供的数据并不能真正显示我们 RSS 链接的订阅人数，于是，我就准备用 Serverless 技术搭建一个「API 中转站」，<strong>提供多个服务商的订阅人数整合的工作。</strong></p>\n<p>其实，最初的 Substats 实际上叫做 RSS-stats，也就是集合多个 RSS 服务商提供的订阅人数数据得到的一个 API 服务。但是后来经过我一番思考，既然都是调用 API，那么为什么不把其他的平台和服务，比如微博粉丝、知乎、少数派、以及 GitHub 和 Twitter 的关注者等等，一起支持一下呢？💡 可行！于是 Substats 就这样诞生啦。(≧∇≦)ﾉ</p>\n<div class=\"admonition admonition-tip\"><div class=\"admonition-heading\"><h5><div class=\"admonition-icon\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"12\" height=\"16\" viewBox=\"0 0 12 16\"><path fill-rule=\"evenodd\" d=\"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z\"></path></svg></div>相关链接</h5></div><div class=\"admonition-content\"><ul>\n<li><strong>Substats API 地址</strong>：<a href=\"https://api.spencerwoo.com/substats/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">API - Substats</a></li>\n<li><strong>Substats GitHub 项目地址</strong>：<a href=\"https://github.com/spencerwooo/Substats\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">spencerwooo/Substats</a></li>\n</ul></div></div>\n<h2 id=\"功能特性\"><a href=\"#%E5%8A%9F%E8%83%BD%E7%89%B9%E6%80%A7\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>功能特性</h2>\n<p>Substats 是一个非常方便易用的<strong>请求订阅者、粉丝、关注用户数量 API 服务</strong>。目前，Substats 平台支持了包括 Feedly、GitHub、Twitter、知乎和少数派在内的五个平台和网站，并使用 Serverless 技术部署到了 Cloudflare 的 CDN 上，全球部署，飞速响应。Substats 将复杂的原平台 API 请求进行了隐藏、简化和集成，让用 Substats 的你只需要关注<strong>两个参数：平台名称、用户名称</strong>，一波访问，即可得到对应的关注数量。</p>\n<p>得益于强大的 Cloudflare 全球 CDN 网络，Substats 不仅部署方便、维护轻松，<strong>还有着极强的可拓展性、极快的访问速度和极小的请求时延</strong>。甚至在你懂得的地方，你都可以轻松访问到 Twitter 的粉丝数量！🥂</p>\n<h3 id=\"api-endpoint\"><a href=\"#api-endpoint\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>API Endpoint</h3>\n<p>Substats 的请求非常简单，基础 API Endpoint 位于：</p>\n<pre class=\"language-text\"><code class=\"language-text\">https://api.spencerwoo.com/substats/</code></pre>\n<p>接下来，我们只需要关注前文提到的平台名 <code class=\"language-text\">source</code> 和用户名称（或 RSS 链接、用户 slug 等标识）<code class=\"language-text\">queryKey</code> 即可构造一个基本的请求。为了更好的和 Shields.io 整合，Substats 仅支持 <code class=\"language-text\">GET</code> 请求，并使用查询字符串（Query String）来添加请求参数。</p>\n<h3 id=\"基础请求\"><a href=\"#%E5%9F%BA%E7%A1%80%E8%AF%B7%E6%B1%82\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>基础请求</h3>\n<p>一个最基础的请求参数类似：</p>\n<pre class=\"language-http\"><code class=\"language-http\">GET /?source={SOURCE}&amp;queryKey={QUERY}</code></pre>\n<p>其中，我们只需要填入平台名称 <code class=\"language-text\">{SOURCE}</code> 和请求参数 <code class=\"language-text\">{QUERY}</code> 即可。</p>\n<h3 id=\"平台串联请求\"><a href=\"#%E5%B9%B3%E5%8F%B0%E4%B8%B2%E8%81%94%E8%AF%B7%E6%B1%82\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>平台串联请求</h3>\n<p>我们可以用下面的语法构建单个请求 query 并列请求多个平台的 API，只需要将平台之间用 <code class=\"language-text\">|</code> 分隔即可：</p>\n<pre class=\"language-http\"><code class=\"language-http\">GET /?source={SOURCE_1}|{SOURCE_2}|{SOURCE_3}&amp;queryKey={QUERY}</code></pre>\n<p>其中，这一请求格式特别适合 RSS 订阅的请求，比如当我们想统计同一个 RSS 链接在 Feedly、Inoreader 以及 NewsBlur 三个平台的订阅者数量，即可使用这一语法进行 API 请求。（详见下文例子）</p>\n<h3 id=\"多个平台和用户名的串联请求\"><a href=\"#%E5%A4%9A%E4%B8%AA%E5%B9%B3%E5%8F%B0%E5%92%8C%E7%94%A8%E6%88%B7%E5%90%8D%E7%9A%84%E4%B8%B2%E8%81%94%E8%AF%B7%E6%B1%82\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>多个平台和用户名的串联请求</h3>\n<pre class=\"language-http\"><code class=\"language-http\">GET /?source={SOURCE}&amp;queryKey={QUERY}&amp;source={SOURCE}&amp;queryKey={QUERY} ....</code></pre>\n<p>如果我们每个平台的请求参数（也就是用户名）不一样，没关系，我们也可以用上面的语法组织各个 <code class=\"language-text\">[平台, 参数]</code> 二元组，依次请求，得到最终数据。在这一过程中，平台、参数的顺序在请求和内部 API 处理的过程中是完全一致的。（你也就不必担心请求的错位。）</p>\n<h2 id=\"一些例子\"><a href=\"#%E4%B8%80%E4%BA%9B%E4%BE%8B%E5%AD%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>一些例子</h2>\n<p>将 Substats 和 <a href=\"https://shields.io/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Shields.io</a> 配合起来，我们可以构造稳定可用的关注者数量实时显示 Badge，嵌入包括 GitHub README、博客文章等等网站的各个位置。我来举个栗子。🌰</p>\n<h3 id=\"单个请求\"><a href=\"#%E5%8D%95%E4%B8%AA%E8%AF%B7%E6%B1%82\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>单个请求</h3>\n<p>Substats 最初就是为了请求 RSS 订阅者数量，我们先来请求一波 Feedly 的订阅数量。我自己博客（也就是本博客）的 RSS 订阅链接是 <code class=\"language-text\">https://blog.spencerwoo.com/feed.xml</code>，那么，我们就可以用下面的 URL 构造请求：</p>\n<pre class=\"language-http\"><code class=\"language-http\">GET /?source=feedly&amp;queryKey=https://blog.spencerwoo.com/feed.xml</code></pre>\n<p>这一请求会返回如下的数据：</p>\n<pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"status\"</span><span class=\"token operator\">:</span> <span class=\"token number\">200</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"data\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"totalSubs\"</span><span class=\"token operator\">:</span> <span class=\"token number\">14</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"subsInEachSource\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token property\">\"feedly\"</span><span class=\"token operator\">:</span> <span class=\"token number\">14</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"failedSources\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>我们所需要的数据即位于：<code class=\"language-text\">data.totalSubs</code>。在 <a href=\"https://shields.io/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Shields.io</a> 官网，我们即可借助 Dynamic Badge 构建一个自定义的 Badge：</p>\n<ul>\n<li><code class=\"language-text\">data type</code> 选择：<code class=\"language-text\">json</code></li>\n<li><code class=\"language-text\">label</code> 填入：Feedly RSS Subscribes</li>\n<li><code class=\"language-text\">data url</code> 填入：<code class=\"language-text\">https://api.spencerwoo.com/substats/?source=feedly&amp;queryKey=https://blog.spencerwoo.com/feed.xml</code></li>\n<li><code class=\"language-text\">query</code> 填入：<code class=\"language-text\">$.data.totalSubs</code></li>\n<li><code class=\"language-text\">color</code> 填入：<code class=\"language-text\">2bb24c</code>（Feedly 的强调色）</li>\n</ul>\n<p>点击 Make badge，即可生成如下的 Feedly RSS 订阅 Badge：</p>\n<p><a href=\"https://feedly.com/i/subscription/feed%2Fhttps%3A%2F%2Fblog.spencerwoo.com%2Fposts%2Findex.xml\"><img src=\"https://img.shields.io/badge/dynamic/json?color=2bb24c&label=Feedly%20RSS%20Subscribes&query=%24.data.totalSubs&url=https%3A%2F%2Fapi.spencerwoo.com%2Fsubstats%2F%3Fsource%3Dfeedly%26queryKey%3Dhttps%3A%2F%2Fblog.spencerwoo.com%2Fposts%2Findex.xml\" alt=\"\" style=\"display: inline; margin: 0 0.1rem 0 0; width: auto;\"></a></p>\n<pre class=\"language-text\"><code class=\"language-text\">https://img.shields.io/badge/dynamic/json?color=2bb24c&amp;label=Feedly%20RSS%20Subscribes&amp;query=%24.data.totalSubs&amp;url=https%3A%2F%2Fapi.spencerwoo.com%2Fsubstats%2F%3Fsource%3Dfeedly%26queryKey%3Dhttps%3A%2F%2Fblog.spencerwoo.com%2Fposts%2Findex.xml</code></pre>\n<p>在这一请求链接的结尾，再手动添加上 Feedly 的 logo 请求参数 <code class=\"language-text\">&amp;logo=feedly</code>，即可将 Badge 添加上图标：</p>\n<p><a href=\"https://feedly.com/i/subscription/feed%2Fhttps%3A%2F%2Fblog.spencerwoo.com%2Fposts%2Findex.xml\"><img src=\"https://img.shields.io/badge/dynamic/json?color=2bb24c&label=Feedly%20RSS%20Subscribes&query=%24.data.totalSubs&url=https%3A%2F%2Fapi.spencerwoo.com%2Fsubstats%2F%3Fsource%3Dfeedly%26queryKey%3Dhttps%3A%2F%2Fblog.spencerwoo.com%2Fposts%2Findex.xml&logo=feedly\" alt=\"\" style=\"display: inline; margin: 0 0.1rem 0 0; width: auto;\"></a></p>\n<pre class=\"language-text\"><code class=\"language-text\">https://img.shields.io/badge/dynamic/json?color=2bb24c&amp;label=Feedly%20RSS%20Subscribes&amp;query=%24.data.totalSubs&amp;url=https%3A%2F%2Fapi.spencerwoo.com%2Fsubstats%2F%3Fsource%3Dfeedly%26queryKey%3Dhttps%3A%2F%2Fblog.spencerwoo.com%2Fposts%2Findex.xml&amp;logo=feedly</code></pre>\n<p>另外，我们还可以指定生成超大 For The Badge 风格的 Badge，在上面请求末尾再手动添加参数 <code class=\"language-text\">&amp;style=for-the-badge</code> 即可：</p>\n<p><a href=\"https://feedly.com/i/subscription/feed%2Fhttps%3A%2F%2Fblog.spencerwoo.com%2Fposts%2Findex.xml\"><img src=\"https://img.shields.io/badge/dynamic/json?color=2bb24c&label=Feedly%20RSS%20Subscribes&query=%24.data.totalSubs&url=https%3A%2F%2Fapi.spencerwoo.com%2Fsubstats%2F%3Fsource%3Dfeedly%26queryKey%3Dhttps%3A%2F%2Fblog.spencerwoo.com%2Fposts%2Findex.xml&logo=feedly&style=for-the-badge\" alt=\"\" style=\"display: inline; margin: 0 0.1rem 0 0; width: auto;\"></a></p>\n<pre class=\"language-text\"><code class=\"language-text\">https://img.shields.io/badge/dynamic/json?color=2bb24c&amp;label=Feedly%20RSS%20Subscribes&amp;query=%24.data.totalSubs&amp;url=https%3A%2F%2Fapi.spencerwoo.com%2Fsubstats%2F%3Fsource%3Dfeedly%26queryKey%3Dhttps%3A%2F%2Fblog.spencerwoo.com%2Fposts%2Findex.xml&amp;logo=feedly&amp;style=for-the-badge</code></pre>\n<h3 id=\"多个平台串联请求\"><a href=\"#%E5%A4%9A%E4%B8%AA%E5%B9%B3%E5%8F%B0%E4%B8%B2%E8%81%94%E8%AF%B7%E6%B1%82\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>多个平台串联请求</h3>\n<p>当然，我们可以用 <code class=\"language-text\">|</code> 串联多个请求，比如我同时请求 Feedly、Inoreader 中订阅我 RSS 链接的用户数量：</p>\n<pre class=\"language-http\"><code class=\"language-http\">GET /?source=feedly|inoreader&amp;queryKey=https://blog.spencerwoo.com/feed.xml</code></pre>\n<p>我们会得到如下数据（截至发文 Inoreader 的 API 尚未实现，我正在咨询 Inoreader 平台方是否提供 API 接口）：</p>\n<pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"status\"</span><span class=\"token operator\">:</span> <span class=\"token number\">200</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"data\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"totalSubs\"</span><span class=\"token operator\">:</span> <span class=\"token number\">14</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"subsInEachSource\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token property\">\"feedly\"</span><span class=\"token operator\">:</span> <span class=\"token number\">14</span><span class=\"token punctuation\">,</span> <span class=\"token property\">\"inoreader\"</span><span class=\"token operator\">:</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"failedSources\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token property\">\"inoreader\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Not implemented\"</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><a href=\"https://feedly.com/i/subscription/feed%2Fhttps%3A%2F%2Fblog.spencerwoo.com%2Fposts%2Findex.xml\"><img src=\"https://img.shields.io/badge/dynamic/json?label=RSS%20subs&query=%24.data.totalSubs&url=https%3A%2F%2Fapi.spencerwoo.com%2Fsubstats%2F%3Fsource%3Dfeedly%257Cinoreader%26queryKey%3Dhttps%3A%2F%2Fblog.spencerwoo.com%2Fposts%2Findex.xml&color=ffa500&logo=rss&style=for-the-badge\" alt=\"\" style=\"display: inline; margin: 0 0.1rem 0 0; width: auto;\"></a></p>\n<h3 id=\"多平台多请求参数串联请求\"><a href=\"#%E5%A4%9A%E5%B9%B3%E5%8F%B0%E5%A4%9A%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E4%B8%B2%E8%81%94%E8%AF%B7%E6%B1%82\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>多平台多请求参数串联请求</h3>\n<p>当每个平台的请求参数（用户名）不一样时，我们可以串联多个请求参数并行请求，比如我希望统计「少数派」平台和「Twitter」平台的粉丝，但是我在这两个平台上面的用户名分别是 <code class=\"language-text\">spencerwoo</code> 和 <code class=\"language-text\">realSpencerWoo</code>，我们即可用下面的方法构造请求：</p>\n<pre class=\"language-http\"><code class=\"language-http\">GET /?source=sspai&amp;queryKey=spencerwoo&amp;source=twitter&amp;queryKey=realSpencerWoo</code></pre>\n<p>我们会得到如下数据：</p>\n<pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"status\"</span><span class=\"token operator\">:</span> <span class=\"token number\">200</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"data\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"totalSubs\"</span><span class=\"token operator\">:</span> <span class=\"token number\">756</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"subsInEachSource\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token property\">\"sspai\"</span><span class=\"token operator\">:</span> <span class=\"token number\">636</span><span class=\"token punctuation\">,</span> <span class=\"token property\">\"twitter\"</span><span class=\"token operator\">:</span> <span class=\"token number\">120</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"failedSources\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>这样，我们即可非常轻松的构造这样的三个 Badge：</p>\n<p><a href=\"https://api.spencerwoo.com/substats/?source=sspai&queryKey=spencerwoo&source=twitter&queryKey=realSpencerWoo\"><img src=\"https://img.shields.io/badge/dynamic/json?label=Social%20media&query=%24.data.totalSubs&url=https%3A%2F%2Fapi.spencerwoo.com%2Fsubstats%2F%3Fsource%3Dsspai%26queryKey%3Dspencerwoo%26source%3Dtwitter%26queryKey%3DrealSpencerWoo&color=brightgreen&style=for-the-badge\" alt=\"\" style=\"display: inline; margin: 0 0.1rem 0 0; width: auto;\"></a>\n<a href=\"https://api.spencerwoo.com/substats/?source=sspai&queryKey=spencerwoo&source=twitter&queryKey=realSpencerWoo\"><img src=\"https://img.shields.io/badge/dynamic/json?label=%E5%B0%91%E6%95%B0%E6%B4%BE&query=%24.data.subsInEachSource.sspai&url=https%3A%2F%2Fapi.spencerwoo.com%2Fsubstats%2F%3Fsource%3Dsspai%26queryKey%3Dspencerwoo%26source%3Dtwitter%26queryKey%3DrealSpencerWoo&color=d71a1b&style=for-the-badge\" alt=\"\" style=\"display: inline; margin: 0 0.1rem 0 0; width: auto;\"></a>\n<a href=\"https://api.spencerwoo.com/substats/?source=sspai&queryKey=spencerwoo&source=twitter&queryKey=realSpencerWoo\"><img src=\"https://img.shields.io/badge/dynamic/json?label=Twitter&query=%24.data.subsInEachSource.twitter&url=https%3A%2F%2Fapi.spencerwoo.com%2Fsubstats%2F%3Fsource%3Dsspai%26queryKey%3Dspencerwoo%26source%3Dtwitter%26queryKey%3DrealSpencerWoo&color=1da1f2&logo=twitter&style=for-the-badge\" alt=\"\" style=\"display: inline; margin: 0 0.1rem 0 0; width: auto;\"></a></p>\n<h2 id=\"小结\"><a href=\"#%E5%B0%8F%E7%BB%93\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>小结</h2>\n<p>这些就是 Substats 的特别之处，Substats 不仅整合了原服务复杂的 API，还拥有方便的请求构建方法。与 <a href=\"https://shields.io/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Shields.io</a> 配合，我们可以及其方便的构造自定义 Badge。虽然当前 Substats 支持的服务平台还比较少，但是整合其他服务 API 的方法还是相当方便的，欢迎同学们帮我来共同整合其他平台，一起将 Substats 发扬壮大 ( •̀ ω •́ )✧</p>\n<p><strong>最后，如果你觉得 Substats 非常棒，请不要吝啬你的 Star！你们的支持是我输出的最大动力 φ(*￣0￣)</strong></p>\n<p><a href=\"https://github.com/spencerwooo/Substats\"><img src=\"https://img.shields.io/github/stars/spencerwooo/Substats?logo=github&style=social\" alt=\"\" style=\"display: inline; margin: 0 0.1rem 0 0; width: auto;\"></a></p>\n"}},{"node":{"title":"Tiny Tiny RSS：部署中的普遍问题与注意事项总结","path":"/2020/03/ttrss-noteworthy/","date":"March 13. 2020","timeToRead":7,"cjkWordCount":1844,"cjkReadTime":9,"description":"Tiny Tiny RSS 部署踩坑","content":"<p>最近一直在折腾 Tiny Tiny RSS，包括升级、添加样式和持久化。由于我是直接使用了 Awesome TTRSS 项目提供的 <code class=\"language-text\">docker-compose.yml</code> 部署的 Docker 版本 Tiny Tiny RSS，所以一些经验还是具有普遍性、值得分享的。这里我总结一下我在部署 Tiny Tiny RSS 过程中遇到的一些「普遍问题」和「注意事项」。</p>\n<p>关于如何在自己的服务器上面部署 Tiny Tiny RSS：</p>\n<ul>\n<li><a href=\"https://blog.spencerwoo.com/2019/11/tiny-tiny-rss/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Tiny Tiny RSS | 最速部署私有 RSS 服务器</a>：我的博客</li>\n<li><a href=\"https://sspai.com/post/57498\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">找不到满意的 RSS 服务？你可以自己搭建一个</a>：我的少数派文章</li>\n</ul>\n<div class=\"admonition admonition-warning\"><div class=\"admonition-heading\"><h5><div class=\"admonition-icon\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"12\" height=\"16\" viewBox=\"0 0 12 16\"><path fill-rule=\"evenodd\" d=\"M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z\"></path></svg></div>RSS 订阅</h5></div><div class=\"admonition-content\"><p>另外，订阅我博客 RSS 的同学（来自 Feedly 的数据）已经达到了惊人的 10 个！谢谢各位的关注，没有用 RSS 订阅的同学可以点击下方徽章直接在 Feedly 中订阅。🙇‍♂️</p><p><a href=\"https://blog.spencerwoo.com/feed.xml\"><img src=\"https://img.shields.io/badge/subscribe%20via-RSS-ffa500?logo=rss&style=for-the-badge\" alt=\"\" style=\"display: inline; margin: 0 0.1rem 0 0; width: auto;\"></a>\n<a href=\"https://feedly.com/i/subscription/feed%2Fhttps%3A%2F%2Fblog.spencerwoo.com%2Fposts%2Findex.xml\"><img src=\"https://img.shields.io/badge/dynamic/json?color=2bb24c&amp;label=subscribers&amp;query=%24.source.subscribers&amp;url=https%3A%2F%2Ffeedly.com%2Fv3%2Frecommendations%2Ffeeds%2Ffeed%252Fhttps%253A%252F%252Fblog.spencerwoo.com%252Fposts%252Findex.xml&amp;logo=feedly&style=for-the-badge\" alt=\"\" style=\"display: inline; margin: 0 0.1rem 0 0; width: auto;\"></a></p></div></div>\n<h2 id=\"如何直接更新最新版本的-tiny-tiny-rss\"><a href=\"#%E5%A6%82%E4%BD%95%E7%9B%B4%E6%8E%A5%E6%9B%B4%E6%96%B0%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84-tiny-tiny-rss\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>如何直接更新最新版本的 Tiny Tiny RSS</h2>\n<p>首先明确一下，更新 Awesome TTRSS 至最新版时，实际上更新了全部组件，包括 Tiny Tiny RSS 本体、主题、插件等等。比如这次更新（2020 年 2 月更新）就将 <a href=\"https://github.com/levito/tt-rss-feedly-theme\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Feedly 主题</a> 最新的更新中加入的 <code class=\"language-text\">feedly-cozy.css</code>、<code class=\"language-text\">feedly-sepia.css</code> 等等主题全部加入了。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220455.png\" alt=\"更新之后加入的最新的 Feedly 主题\"><figcaption>更新之后加入的最新的 Feedly 主题</figcaption></figure>\n<p>我推荐大家手动执行更新。更新 Tiny Tiny RSS 本体：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> pull wangqiru/ttrss:latest</code></pre>\n<p>更新 Mercury 和 OpenCC 服务：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> pull wangqiru/mercury-parser-api:latest\n<span class=\"token function\">docker</span> pull wangqiru/opencc-api-server:latest</code></pre>\n<p>之后，重启 Tiny Tiny RSS 服务即可：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker-compose</span> up <span class=\"token parameter variable\">-d</span></code></pre>\n<p>Awesome TTRSS 项目中提供了 Watch Tower 项目，但是我并不推荐大家通过这一工具进行自动更新，因为 Watch Tower 会将你的全部 Docker 容器更新，可能会导致其他环境的不兼容。</p>\n<h2 id=\"如何在编辑-docker-compose-文件之后重启-tiny-tiny-rss\"><a href=\"#%E5%A6%82%E4%BD%95%E5%9C%A8%E7%BC%96%E8%BE%91-docker-compose-%E6%96%87%E4%BB%B6%E4%B9%8B%E5%90%8E%E9%87%8D%E5%90%AF-tiny-tiny-rss\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>如何在编辑 docker-compose 文件之后重启 Tiny Tiny RSS</h2>\n<p>无论是重新配置了何种环境，是重新映射的 Volume 还是添加了 <code class=\"language-text\">docker-compose.yml</code> 设置，我都推荐直接用这一命令重启 Tiny Tiny RSS 服务：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker-compose</span> up <span class=\"token parameter variable\">-d</span></code></pre>\n<p>如果你先运行停止 Docker 容器（<code class=\"language-text\">docker-compose down</code>、<code class=\"language-text\">docker-compose rm</code>）的命令，我都遇到过数据库丢失的情况，因此只要没有特殊需要，<strong>我们都可以只使用上面的命令重启 Tiny Tiny RSS 服务。</strong></p>\n<h2 id=\"如何正确的配置-fever-emulation-api\"><a href=\"#%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E9%85%8D%E7%BD%AE-fever-emulation-api\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>如何正确的配置 Fever Emulation API</h2>\n<p>通常，为了适配第三方 RSS 阅读器比如 Reeder，我们需要使用 Fever Emulation API 进行「登录」。首先我们必须开启 Tiny Tiny RSS 外部 API 访问的权限。在 Preference » General » Enable API 处开启：</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220455-1.png\" alt=\"设置允许通过外部 API 访问 Tiny Tiny RSS\"><figcaption>设置允许通过外部 API 访问 Tiny Tiny RSS</figcaption></figure>\n<p>Fever Emulation 的 API 包含有三个部分：</p>\n<ul>\n<li>你的 Fever API 地址（通常是你的服务器域名 + <code class=\"language-text\">/plugins/fever/</code>）</li>\n<li>你的登录用户名</li>\n<li>你的 Fever API 密码</li>\n</ul>\n<p>在 Preferences » Personal data / Authentication » Personal data » Full name 处设置的用户名就是你 <strong>Fever API 的用户名</strong>：</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220455-2.png\" alt=\"找到你的用户名\"><figcaption>找到你的用户名</figcaption></figure>\n<p>在 Preferences » Fever Emulation 处你可以找到：</p>\n<ol>\n<li>Fever API 地址</li>\n<li>设置 Fever API 密码的地方</li>\n</ol>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220455-3.png\" alt=\"获取 Fever API 地址并设置 Fever Emulation 密码\"><figcaption>获取 Fever API 地址并设置 Fever Emulation 密码</figcaption></figure>\n<p>要知道，设置 Fever API 的密码时点击 Set Password 并不会提示「成功」，不过你可以从 XHR 请求中看到 Password saved 的 response，<strong>所以其实你的密码已经保存啦</strong>。用这里设置的 API 地址、用户名和密码，我们就能成功登录 Reeder 等 RSS 阅读器了。</p>\n<h2 id=\"如何设置分栏视图\"><a href=\"#%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E5%88%86%E6%A0%8F%E8%A7%86%E5%9B%BE\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>如何设置分栏视图</h2>\n<p>「分栏视图」就是类似笔记应用的一个侧边栏显示订阅文章列表，另一侧显示文章内容的视图。你可以：</p>\n<ol>\n<li>\n<p>在 Preferences » Preferences » Articles 中关闭 Combined mode 的设置：</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220455-4.png\" alt=\"关闭 Combined mode\"><figcaption>关闭 Combined mode</figcaption></figure>\n</li>\n<li>\n<p>回到主界面，在右上角的汉堡键 » Toggle widescreen mode 处点击打开宽屏模式：</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220455-5.png\" alt=\"打开宽屏模式\"><figcaption>打开宽屏模式</figcaption></figure>\n</li>\n</ol>\n<p>这样 Tiny Tiny RSS 就会以分栏视图显示文章列表和文章内容了。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220455-6.png\" alt=\"Tiny Tiny RSS 分栏视图\"><figcaption>Tiny Tiny RSS 分栏视图</figcaption></figure>\n<p>另外，我的基于 Feedly 修改的主题配置文件：<a href=\"https://gist.github.com/spencerwooo/7a373a3c921a50953ec12f329452ee27\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">GitHub - Gist</a></p>\n<h2 id=\"如何正确设置-mercury-全文抓取和-opencc-繁简转换-api\"><a href=\"#%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E8%AE%BE%E7%BD%AE-mercury-%E5%85%A8%E6%96%87%E6%8A%93%E5%8F%96%E5%92%8C-opencc-%E7%B9%81%E7%AE%80%E8%BD%AC%E6%8D%A2-api\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>如何正确设置 Mercury 全文抓取和 OpenCC 繁简转换 API</h2>\n<p>如果你使用了 Awesome TTRSS 中包含的 Mercury 全文抓取和 OpenCC 繁简转换 API，那么你应该在 <code class=\"language-text\">docker ps</code> 的输出中看到这两个服务的身影：</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220455-7.png\" alt=\"docker ps 的输出\"><figcaption>docker ps 的输出</figcaption></figure>\n<p>如果你这两个服务的配置和原配置一致：</p>\n<pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">service.mercury</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> wangqiru/mercury<span class=\"token punctuation\">-</span>parser<span class=\"token punctuation\">-</span>api<span class=\"token punctuation\">:</span>latest\n  <span class=\"token key atrule\">container_name</span><span class=\"token punctuation\">:</span> mercury\n  <span class=\"token key atrule\">expose</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> <span class=\"token number\">3000</span>\n  <span class=\"token key atrule\">restart</span><span class=\"token punctuation\">:</span> always\n\n<span class=\"token key atrule\">service.opencc</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> wangqiru/opencc<span class=\"token punctuation\">-</span>api<span class=\"token punctuation\">-</span>server<span class=\"token punctuation\">:</span>latest\n  <span class=\"token key atrule\">container_name</span><span class=\"token punctuation\">:</span> opencc\n  <span class=\"token key atrule\">environment</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">NODE_ENV</span><span class=\"token punctuation\">:</span> production\n  <span class=\"token key atrule\">expose</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> <span class=\"token number\">3000</span>\n  <span class=\"token key atrule\">restart</span><span class=\"token punctuation\">:</span> always</code></pre>\n<p>那么，你只需要在 Tiny Tiny RSS 的 Preferences 中开启这两个插件，并将 API 地址依次设置为如下即可。（Docker 会自动探索相应的服务 API 地址。）</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Mercury</th>\n<th align=\"center\">OpenCC</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\"><code class=\"language-text\">service.mercury:3000</code></td>\n<td align=\"center\"><code class=\"language-text\">service.opencc:3000</code></td>\n</tr>\n<tr>\n<td align=\"center\"><figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/Snipaste_2020-07-22_22-13-39.png\" alt=\"Mercury 全文抓取\"><figcaption>Mercury 全文抓取</figcaption></figure></td>\n<td align=\"center\"><figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/Snipaste_2020-07-22_22-14-10.png\" alt=\"OpenCC 繁简转换\"><figcaption>OpenCC 繁简转换</figcaption></figure></td>\n</tr>\n</tbody>\n</table>\n<p>注意，你需要在每一个订阅源中明确指定使用 Mercury 或 OpenCC 服务（右键编辑），才可以真正保证服务的准确运行。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220455-9.png\" alt=\"编辑订阅源，开启 Mercury 或 OpenCC 服务\"><figcaption>编辑订阅源，开启 Mercury 或 OpenCC 服务</figcaption></figure>\n<h2 id=\"如何调试查看-tiny-tiny-rss-与其他容器服务的-log\"><a href=\"#%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E6%9F%A5%E7%9C%8B-tiny-tiny-rss-%E4%B8%8E%E5%85%B6%E4%BB%96%E5%AE%B9%E5%99%A8%E6%9C%8D%E5%8A%A1%E7%9A%84-log\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>如何调试、查看 Tiny Tiny RSS 与其他容器服务的 log</h2>\n<p>Docker 容器的 log 查看非常简单。如果我们想用 <code class=\"language-text\">docker-compose</code> 查看整个 Awesome TTRSS 的 log：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># 查看 docker-compose 的 log 后 5 条</span>\n<span class=\"token function\">docker-compose</span> logs <span class=\"token parameter variable\">--tail</span> <span class=\"token number\">5</span></code></pre>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220455-10.png\" alt=\"查看 docker-compose 启动的全部服务的 log\"><figcaption>查看 docker-compose 启动的全部服务的 log</figcaption></figure>\n<p>我们可以用下面的命令查看单个服务的 log：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># 查看 Mercury 服务后 5 条</span>\n<span class=\"token function\">docker</span> logs mercury <span class=\"token parameter variable\">--tail</span> <span class=\"token number\">5</span></code></pre>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220455-11.png\" alt=\"查看 Mercury 全文抓取的 log\"><figcaption>查看 Mercury 全文抓取的 log</figcaption></figure>\n<p>另外，我们也可以用下面的命令查看实时更新的 log：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># 查看实时更新的 Mercury 服务（显示 10 条）</span>\n<span class=\"token function\">docker</span> logs mercury <span class=\"token parameter variable\">--tail</span> <span class=\"token number\">10</span> <span class=\"token parameter variable\">-f</span></code></pre>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220455-12.png\" alt=\"查看实时更新的 Mercury 服务\"><figcaption>查看实时更新的 Mercury 服务</figcaption></figure>\n<h2 id=\"如何持久化-tiny-tiny-rss-图标\"><a href=\"#%E5%A6%82%E4%BD%95%E6%8C%81%E4%B9%85%E5%8C%96-tiny-tiny-rss-%E5%9B%BE%E6%A0%87\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>如何持久化 Tiny Tiny RSS 图标</h2>\n<p>升级更新了 Tiny Tiny RSS 服务之后，每次订阅源的图标都会丢失。我们可以通过将 Tiny Tiny RSS 的图标文件夹挂载到 Docker 容器之外来「持久化」图标存储。</p>\n<p>在 <code class=\"language-text\">docker-compose.yml</code> 中，将 Tiny Tiny RSS 的 Docker 容器配置 <code class=\"language-text\">service.rss</code> 中添加如下的配置：</p>\n<pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">-</span> ~/awesome<span class=\"token punctuation\">-</span>ttrss/feed<span class=\"token punctuation\">-</span>icons/<span class=\"token punctuation\">:</span>/var/www/feed<span class=\"token punctuation\">-</span>icons/ <span class=\"token comment\"># mount feed icons to local machine</span></code></pre>\n<p>这样即可将 Docker 容器里面 <code class=\"language-text\">/var/www/feed-icons/</code> 文件夹里面的内容挂载到外面服务器上的 <code class=\"language-text\">~/awesome-ttrss/feed-icons/</code> 文件夹。</p>\n<p>另外，我们还需要给 <code class=\"language-text\">~/awesome-ttrss/feed-icons/</code> 文件赋予合适的权限：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">chmod</span> <span class=\"token parameter variable\">-R</span> <span class=\"token number\">777</span> feed-icons</code></pre>\n<p>这样，Tiny Tiny RSS 下载的 favicon 就全部挂载到本机，更新 Docker 容器也不会对这些内容造成任何影响了。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220455-13.png\" alt=\"将订阅源的 icon 挂载到容器外部\"><figcaption>将订阅源的 icon 挂载到容器外部</figcaption></figure>\n<p>感谢阅读。🙇‍♂️</p>\n"}},{"node":{"title":"「输出」开销：为什么我们向 stdout 输出时那么慢？","path":"/2020/02/stdout-overhead/","date":"February 22. 2020","timeToRead":7,"cjkWordCount":1230,"cjkReadTime":6,"description":"Console output overhead: why is writing to stdout so slow?","content":"<blockquote>\n<p>本文发布于 Medium: <a href=\"https://medium.com/spencerweekly/console-output-overhead-why-is-writing-to-stdout-so-slow-b0cc7c88704c\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Console output overhead: why is writing to stdout so slow?</a></p>\n</blockquote>\n<p>Generally, when we code through our projects, we need to output certain values in order to understand what the program is currently doing and what results it shows. Normally we do this with a simple print function:</p>\n<pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Hey look, this is the result.'</span><span class=\"token punctuation\">)</span></code></pre>\n<p>And for most of our use cases, this would be more than enough. However, when we are outputting a huge amount of data, like printing a file with 10k lines of text onto the terminal, we will eventually suffer from IO bottlenecks. This is something I discovered when trying to find a nice progress bar library for PyTorch in order to monitor the model’s training progress. Let me explain.</p>\n<h2 id=\"what-did-i-discover\"><a href=\"#what-did-i-discover\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>What did I discover?</h2>\n<p>Now, if you are familiar with modern neural network libraries, you may have heard of Keras. Keras is a highly encapsulated library that takes care of data output, model compilation, backward propaganda and more for you under the hood, meaning that it offers less agility than other low-level libraries like PyTorch. The one feature I really appreciate about Keras is its nice little training progress bar that shows the current training progress, iteration duration, ETA, loss and other relevant statistics. Below is an example.</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215810.png\" alt=\"Visualizing training progress with Keras\"><figcaption>Visualizing training progress with Keras</figcaption></figure>\n<p>However, PyTorch offers far more customizable features when it comes to designing, compiling and training your model, but it also means you have to take care of outputting progress, training details and others by yourself. This is when I discovered IO bottlenecks when outputting directly to <code class=\"language-text\">stdout</code>, that is, your terminal.</p>\n<p>The library I first tried is called <a href=\"https://github.com/yueyericardo/pkbar\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><strong>pkbar</strong> — a progress bar library intended to bring Keras style progress monitoring to the PyTorch ecosystem</a>. <strong>(Don’t use it!)</strong> It’s outputs are like this:</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215810-1.png\" alt=\"pkbar: Keras style progress bar for PyTorch\"><figcaption>pkbar: Keras style progress bar for PyTorch</figcaption></figure>\n<p>Most progress bar libraries are implemented by wrapping itself around an iterative object, in our case, a PyTorch Data Loader. When building a progress bar, we need to refresh our progress, statistics and other parameters on each iteration. This means every time we come to the end of an iteration, we need to output to our terminal with a delay when the program waits for the writing to return. This delay is often unnoticed when we are simply writing a single message, but when we are iterating through thousands of images, we need to write the latest status on each iteration. A small delay multiplied by a thousand iterations gives us a huge time difference, and results in bottlenecks we encounter now.</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215810-2.png\" alt=\"Each iteration comes with a time cost that adds up to be a huge delay\"><figcaption>Each iteration comes with a time cost that adds up to be a huge delay</figcaption></figure>\n<p>What happened to me when I was using pkbar was exactly what I described above: <strong>each iteration was accompanied with a delay which eventually builds up into a time difference I simply can’t ignore.</strong> To put numbers into perspective, I was applying a DeepFool adversarial attack on a pre-trained ResNet18 CNN. It took about 5 minutes on my laptop running on GPU without pkbar, and when I added pkbar to visualize progress, it gave me an ETA of nearly 20 minutes! Holy crap, I removed pkbar almost immediately.</p>\n<h2 id=\"so-why-were-there-delays\"><a href=\"#so-why-were-there-delays\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>So why were there delays?</h2>\n<p>In order to find out what was causing this huge delay and how we could avoid it, I turned for help on Stack Overflow. A particular question gave me the answer: <a href=\"https://stackoverflow.com/questions/3857052/why-is-printing-to-stdout-so-slow-can-it-be-sped-up\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Why is printing to stdout so slow? Can it be sped up?</a></p>\n<p>In this question, the author compared the following speeds:</p>\n<ul>\n<li>Writing output to the terminal, which is <code class=\"language-text\">stdout</code></li>\n<li>Writing output to a file</li>\n<li>Writing output to <code class=\"language-text\">stdout</code>, but with <code class=\"language-text\">stdout</code> redirected to <code class=\"language-text\">/dev/null</code></li>\n</ul>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215810-3.png\" alt=\"Time cost for printing to stdout, file and /dev/null\"><figcaption>Time cost for printing to stdout, file and /dev/null</figcaption></figure>\n<p>Wow, that shows a huge difference for printing to <code class=\"language-text\">stdout</code> and redirecting <code class=\"language-text\">stdout</code> to <code class=\"language-text\">/dev/null</code>. Even writing output to file is faster than directly writing to the terminal. So…, why?</p>\n<blockquote>\n<p>Congratulations, you have just discovered the importance of I/O buffering. :-)</p>\n</blockquote>\n<p>So it turns out that I/O buffering is what made even “writing to file” faster than “writing to <code class=\"language-text\">stdout</code>”. When we are directly writing outputs to our terminal, each writing operation is being done “synchronously”, which means our programs waits for the “write” to complete before it continues to the next commands.</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215810-4.png\" alt=\"Synchronous writing to stdout\"><figcaption>Synchronous writing to stdout</figcaption></figure>\n<p>Each time our programs writes something to <code class=\"language-text\">stdout</code>, we are met with this delay. However, writing to files are not of the same case. When we are writing to files, we have what is known as “I/O buffering”, which means the program outputs whatever it needs to write to the file, and the OS catches all these contents to write where it then stores in a file <strong>as a bulk</strong> afterwards. <strong>All our “write” functions return before anything is actually written to a file.</strong></p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215810-5.png\" alt=\"Buffered writing output to file\"><figcaption>Buffered writing output to file</figcaption></figure>\n<p>So what should we do here? Well, in order to avoid I/O overhead, we either have to do training and update output in parallel or asynchronously like we do in GUIs when we have an UI thread and a controller, or we will need to write in bulks to <code class=\"language-text\">stdout</code> like what we are doing when writing to files. <strong>It’s a trade-off: interactivity versus bulk efficiency.</strong></p>\n<h2 id=\"what-i-did-to-visualize-pytorch-training-with-minimum-overhead\"><a href=\"#what-i-did-to-visualize-pytorch-training-with-minimum-overhead\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>What I did to visualize PyTorch training with minimum overhead?</h2>\n<p>After I ditched pkbar, I found a perfect progress bar library: <a href=\"https://github.com/tqdm/tqdm\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">tqdm — A Fast, Extensible Progress Bar for Python and CLI</a>. With over 13.4k+ stars, <code class=\"language-text\">tqdm</code> is easily the best Python library for us to implement training progress visualization.</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215810-6.png\" alt=\"tqdm in action\"><figcaption>tqdm in action</figcaption></figure>\n<p><code class=\"language-text\">tqdm</code> is simple, efficient and comes with minimal overhead. The author claims that <code class=\"language-text\">tqdm</code> only delays output for a minimum of 60ns per iteration. That’s impressive. In addition to its low overhead, <code class=\"language-text\">tqdm</code> uses smart algorithms to predict the remaining time and to skip unnecessary iteration displays, which allows for a negligible overhead in most cases.</p>\n<h3 id=\"installation\"><a href=\"#installation\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Installation</h3>\n<p>Either install <code class=\"language-text\">tqdm</code> using conda directly:</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">conda <span class=\"token function\">install</span> <span class=\"token parameter variable\">-c</span> conda-forge tqdm</code></pre>\n<p>And install <code class=\"language-text\">ipywidgets</code> with pip to enable Jupyter Notebook integration:</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">pip <span class=\"token function\">install</span> ipywidgets</code></pre>\n<p>Or integrate the following code to your <code class=\"language-text\">environment.yml</code>:</p>\n<pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">channels</span><span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">-</span> conda<span class=\"token punctuation\">-</span>forge\n  <span class=\"token punctuation\">-</span> defaults\n<span class=\"token key atrule\">dependencies</span><span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">-</span> tqdm\n  <span class=\"token punctuation\">-</span> <span class=\"token key atrule\">pip</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> ipywidgets</code></pre>\n<p>Then run:</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">conda <span class=\"token function\">env</span> update</code></pre>\n<h3 id=\"integration\"><a href=\"#integration\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Integration</h3>\n<p>We can easily integrate <code class=\"language-text\">tqdm</code> into our PyTorch project. Basically what you need to do is just to wrap <code class=\"language-text\">tqdm</code> on an iterable object, and that’s it.</p>\n<pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">from</span> tqdm <span class=\"token keyword\">import</span> tqdm\n<span class=\"token keyword\">for</span> i <span class=\"token keyword\">in</span> tqdm<span class=\"token punctuation\">(</span><span class=\"token builtin\">range</span><span class=\"token punctuation\">(</span><span class=\"token number\">10000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span></code></pre>\n<pre class=\"language-text\"><code class=\"language-text\">76%|████████████████████████████ | 7568/10000 [00:33&lt;00:10, 229.00it/s]</code></pre>\n<p>For PyTorch <code class=\"language-text\">DataLoader</code>, we can first load our data like so:</p>\n<pre class=\"language-python\"><code class=\"language-python\">dataset_loader <span class=\"token operator\">=</span> torch<span class=\"token punctuation\">.</span>utils<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>DataLoader<span class=\"token punctuation\">(</span>dataset<span class=\"token punctuation\">,</span> batch_size<span class=\"token operator\">=</span><span class=\"token number\">4</span><span class=\"token punctuation\">)</span></code></pre>\n<p>Then initialize <code class=\"language-text\">tdqm</code>:</p>\n<pre class=\"language-python\"><code class=\"language-python\">pbar <span class=\"token operator\">=</span> tqdm<span class=\"token punctuation\">(</span>dataset_loader<span class=\"token punctuation\">)</span></code></pre>\n<p>Here, we can add the description of the progress bar:</p>\n<pre class=\"language-python\"><code class=\"language-python\">pbar<span class=\"token punctuation\">.</span>set_description<span class=\"token punctuation\">(</span><span class=\"token string\">'Validate predictions'</span><span class=\"token punctuation\">)</span></code></pre>\n<p>Also, we can initialize the post-fix dict for the progress bar, so that we can update the post-fix on the fly:</p>\n<pre class=\"language-python\"><code class=\"language-python\">pbar<span class=\"token punctuation\">.</span>set_postfix<span class=\"token punctuation\">(</span>loss<span class=\"token operator\">=</span><span class=\"token string\">'0.0%'</span><span class=\"token punctuation\">,</span> acc<span class=\"token operator\">=</span><span class=\"token string\">'0.0%'</span><span class=\"token punctuation\">)</span></code></pre>\n<p>And Voilà! We can directly iterate through <code class=\"language-text\">tdqm</code>, just like we did with PyTorch <code class=\"language-text\">DataLoader</code>. (My model is wrapped with Foolbox, so I can make predictions with the <code class=\"language-text\">.forward()</code> function.)</p>\n<pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">for</span> image<span class=\"token punctuation\">,</span> label <span class=\"token keyword\">in</span> pbar<span class=\"token punctuation\">:</span>\n  <span class=\"token comment\"># make a prediction</span>\n  prob <span class=\"token operator\">=</span> model<span class=\"token punctuation\">.</span>forward<span class=\"token punctuation\">(</span>image<span class=\"token punctuation\">.</span>numpy<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span><span class=\"token punctuation\">.</span>  <span class=\"token comment\"># calculate and update loss</span>\n  pbar<span class=\"token punctuation\">.</span>set_postfix<span class=\"token punctuation\">(</span>loss<span class=\"token operator\">=</span><span class=\"token string\">'{:.2f}%'</span><span class=\"token punctuation\">.</span><span class=\"token builtin\">format</span><span class=\"token punctuation\">(</span>loss<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\n  <span class=\"token comment\"># calculate and update accuracy</span>\n  pbar<span class=\"token punctuation\">.</span>set_postfix<span class=\"token punctuation\">(</span>acc<span class=\"token operator\">=</span><span class=\"token string\">'{:.2f}%'</span><span class=\"token punctuation\">.</span><span class=\"token builtin\">format</span><span class=\"token punctuation\">(</span>acc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre>\n<h3 id=\"features\"><a href=\"#features\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Features</h3>\n<p><code class=\"language-text\">tqdm</code> can be used directly in a CLI environment with no special configuration whatsoever.</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215810-7.gif\" alt=\"tqdm in a CLI enviroment\"><figcaption>tqdm in a CLI enviroment</figcaption></figure>\n<p>Also, we can run <code class=\"language-text\">tqdm</code> in VS Code’s Python Interactive console, or Jupyter Notebook. In this case, <code class=\"language-text\">tqdm</code> will output progress asynchronously according to the <a href=\"https://jupyter-notebook.readthedocs.io/en/stable/examples/Notebook/Running%20Code.html#Output-is-asynchronous\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Notebook API</a>.</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215810-8.gif\" alt=\"tqdm outputting inside Jupyter Notebook / VS Code Python Interactive\"><figcaption>tqdm outputting inside Jupyter Notebook / VS Code Python Interactive</figcaption></figure>\n<p>To kick it up a notch, we can actually output “real” progress bars. Utilizing <code class=\"language-text\">ipywidget</code>, we can directly draw interactive progress bars inside Jupyter Notebook. <a href=\"https://ipywidgets.readthedocs.io/en/latest/user_install.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">See here for instructions on how to enable </a><code class=\"language-text\">ipywidgets</code><a href=\"https://ipywidgets.readthedocs.io/en/latest/user_install.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">.</a></p>\n<p>After enabling these widgets inside Jupyter Notebook, all we have to do is change the way on how we imported <code class=\"language-text\">tqdm</code>. Change:</p>\n<pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> tqdm <span class=\"token keyword\">as</span> tqdm</code></pre>\n<p>To:</p>\n<pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">import</span> tqdm<span class=\"token punctuation\">.</span>notebook <span class=\"token keyword\">as</span> tqdm</code></pre>\n<p>Now, run the code once more, if everything goes well, we should be able to see a neat progress bar with colors indicating the current task’s state: pending, success or failure.</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215810-9.gif\" alt=\"tqdm integrating directly into Jupyter Notebook with ipywidgets - https://ipywidgets.readthedocs.io/en/latest\"><figcaption>tqdm integrating directly into Jupyter Notebook with ipywidgets - https://ipywidgets.readthedocs.io/en/latest</figcaption></figure>\n<hr>\n<p>This is the end of the article, for more information on how to utilize <code class=\"language-text\">tqdm</code>, I recommend this article: <a href=\"https://medium.com/better-programming/python-progress-bars-with-tqdm-by-example-ce98dbbc9697\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Python Progress Bars with tqdm by Example</a>. Also, the official documentation of <code class=\"language-text\">tqdm</code> is quite thorough, covering most cases when using <code class=\"language-text\">tqdm</code>.</p>\n<p>There’s one thing to note, and that is: you should not use “print” to output anything when a <code class=\"language-text\">tqdm</code> progress bar is running, as this behavior will mess up the <code class=\"language-text\">tqdm</code> output. If you have to write something, do remember to use:</p>\n<pre class=\"language-python\"><code class=\"language-python\">tqdm<span class=\"token punctuation\">.</span>write<span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span>context<span class=\"token operator\">></span><span class=\"token punctuation\">)</span></code></pre>\n<p>That’s all, thanks for reading.</p>\n"}},{"node":{"title":"cwim 背后的故事：Rust 与 Ownership","path":"/2020/01/cli-app-in-rust/","date":"January 23. 2020","timeToRead":14,"cjkWordCount":3472,"cjkReadTime":16,"description":"Rust 是如何保证「内存安全」的","content":"<p>前几天 Stack Overflow 博客上面有一篇文章<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup>，里面提到了 Rust 已经连续四年位列 Stack Overflow 社区最爱编程语言榜首。的确，Rust 是一门神奇又美丽的语言。Rust 是一门标榜 safe 与 zero-cost abstraction 的语言<sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup>，意味着只要你编写的 Rust 代码符合官方标准 —— 能够通过编译 —— 那么你的项目几乎可以肯定地说是内存安全的。</p>\n<h2 id=\"初衷\"><a href=\"#%E5%88%9D%E8%A1%B7\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>初衷</h2>\n<p>偏向底层的 Rust 让我在之前一直没有机会尝试，毕竟我相信国内高校没有一所是敢直接抛弃 C、C++ 而使用 Rust 作为其主语言进行授课的。最近我重构了 <a href=\"https://dowww.spencerwoo.com\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Dev on Windows with WSL</a>：一个近 2w 字的 WSL 开发配置文档。我前后用了大概半个月的时间，增加了许多内容，因此我在结束编写工作之后，试图找到一个类似 <code class=\"language-text\">cloc</code>，能帮我统计一个目录下全部 Markdown 文件的命令行工具。很失望，没找到。</p>\n<p>我决定自己尝试实现这个命令行工具，当然，我也相信 Python、Node.js、Ruby 等脚本语言一定适合做这些事情，毕竟 <code class=\"language-text\">cloc</code> 本身就是使用 Perl 实现的。不过，Rust 作为一门高效的、静态的、可以直接编译到三个操作系统的底层语言，还是很有吸引力的。因此我才决定使用 Rust 开新坑。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215236.png\" alt=\"使用 Rust 实现的 cwim - Count words in Markdown\"><figcaption>使用 Rust 实现的 cwim - Count words in Markdown</figcaption></figure>\n<p>另外：cwim 的第一个小版本我已经编译并发布 Release 版本，有兴趣的同学可以前往 GitHub 查看：<a href=\"https://github.com/spencerwooo/cwim\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">spencerwooo/cwim</a>.</p>\n<h2 id=\"开始一个-rust-项目\"><a href=\"#%E5%BC%80%E5%A7%8B%E4%B8%80%E4%B8%AA-rust-%E9%A1%B9%E7%9B%AE\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>开始一个 Rust 项目</h2>\n<p>Rust 最 beginner friendly 的地方我觉得在于其<a href=\"https://www.rust-lang.org/zh-CN/learn/get-started\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">官方入门文档</a>的简洁易懂。从安装、编译到包管理、打包项目 …… Rust 的官方文档讲解的都比任何其他语言的文档讲解的要易懂不少。我这里简单记录一下 Rust 环境的安装搭建的基本过程。</p>\n<h3 id=\"安装-rust-环境\"><a href=\"#%E5%AE%89%E8%A3%85-rust-%E7%8E%AF%E5%A2%83\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>安装 Rust 环境</h3>\n<p>Rust 语言虽然小众，但是其生态相当完善。Rust 借鉴了其他语言的多种环境配置工具，官方直接提供了一整套完善的闭环 Toolkit，基本能满足我们在使用 Rust 时的安装、构建、编译、发布的整套流程：</p>\n<ul>\n<li>Rustup：Rust 版本管理（类似 Python 的 <code class=\"language-text\">pyenv</code>、Node.js 的 <code class=\"language-text\">nvm</code> 等）</li>\n<li>Cargo：Rust 构建工具与包管理（类似 Python 的 <code class=\"language-text\">pip</code>、Node.js 的 <code class=\"language-text\">yarn</code> 等）</li>\n<li>crates.io：Rust 的 Package Registry</li>\n</ul>\n<p>首先，我们安装 Rustup：Rust 安装器与 Rust 版本控制器。使用 Arch Linux（以及 WSL 的 Arch Linux）的同学可以直接在 AUR 中安装 <code class=\"language-text\">rustup</code>：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">yay rustup</code></pre>\n<p>如果使用 WSL 其他 Linux 发行版，我们也可以用下面的命令安装 <code class=\"language-text\">rustup</code>：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">curl</span> <span class=\"token parameter variable\">--proto</span> <span class=\"token string\">'=https'</span> <span class=\"token parameter variable\">--tlsv1.2</span> <span class=\"token parameter variable\">-sSf</span> https://sh.rustup.rs <span class=\"token operator\">|</span> <span class=\"token function\">sh</span></code></pre>\n<p>其他安装方法请参考：<a href=\"https://www.rust-lang.org/zh-CN/tools/install\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Rust | 安装 Rust</a></p>\n<p>安装了 <code class=\"language-text\">rustup</code> 之后，我们就应该已经安装完成了 Cargo：Rust 的构建工具与包管理工具。Cargo 可以做很多事情：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">cargo</span> build     <span class=\"token comment\"># 可以构建项目</span>\n<span class=\"token function\">cargo</span> run       <span class=\"token comment\"># 可以运行项目</span>\n<span class=\"token function\">cargo</span> <span class=\"token builtin class-name\">test</span>      <span class=\"token comment\"># 可以测试项目</span>\n<span class=\"token function\">cargo</span> doc       <span class=\"token comment\"># 可以为项目构建文档</span>\n<span class=\"token function\">cargo</span> publish   <span class=\"token comment\"># 可以将库发布到 crates.io</span></code></pre>\n<p>要检查是否安装了 Rust 和 Cargo，可以在终端中运行：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">cargo</span> <span class=\"token parameter variable\">--version</span></code></pre>\n<p>接下来我们就可以使用 Cargo 来创建一个 Rust 项目，并用它来安装我们必须的 Rust 库等内容。</p>\n<h3 id=\"rust--vs-code\"><a href=\"#rust--vs-code\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Rust / VS Code</h3>\n<p>VS Code 是一个通用的文本 / 代码编辑器，能够通过插件支持多种语言环境下代码的编写任务。我们下载 Rust 官方提供的 VS Code 插件：<a href=\"https://marketplace.visualstudio.com/items?itemName=rust-lang.rust\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Visual Studio Code Marketplace | Rust (rls)</a></p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215236-1.png\" alt=\"Visual Studio Code Marketplace | Rust (rls)\"><figcaption>Visual Studio Code Marketplace | Rust (rls)</figcaption></figure>\n<p>之后，我们用 Cargo 创建一个新的项目 <code class=\"language-text\">hello-rust</code>：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">cargo</span> new hello-rust</code></pre>\n<p>或者在已有文件夹 <code class=\"language-text\">hello-rust</code> 下，生成新 Rust 项目：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">cd</span> hello-rust\n<span class=\"token function\">cargo</span> init</code></pre>\n<p>新的 Rust 项目目录下应该拥有以下内容：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\">hello-rust      <span class=\"token comment\"># 根目录</span>\n<span class=\"token operator\">|</span>- Cargo.toml   <span class=\"token comment\"># Rust 的清单文件，其中包含项目的元数据和依赖库</span>\n<span class=\"token operator\">|</span>- src\n  <span class=\"token operator\">|</span>- main.rs    <span class=\"token comment\"># 主程序入口</span></code></pre>\n<p>用 VS Code 打开这一目录，我们即可开始 Rust 项目的编写。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215236-2.png\" alt=\"使用 VS Code 撰写 Rust 项目\"><figcaption>使用 VS Code 撰写 Rust 项目</figcaption></figure>\n<p>使用下面命令即可运行项目：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">cargo</span> run</code></pre>\n<h2 id=\"rust-语言特性\"><a href=\"#rust-%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Rust 语言特性</h2>\n<p>在用 Rust 编写 <code class=\"language-text\">cwim</code> 的时候，有两个令我印象深刻的地方：一个是 Rust 语言实际上非常清晰易懂，有 C、C++ 等强类型语言的严谨，也有脚本语言的易读；另一个就是 Rust 编译器非常严格，但给我们的问题提示也非常清晰，方便追溯问题所在，容易 debug。严苛的 Rust 编译器让我们必须考虑「内存分配」，也正因如此，使得 <strong>Rust 在并未实现「垃圾回收」的前提下，确保了任何 Rust 程序都生来具有「内存安全」特性。</strong></p>\n<blockquote>\n<p>🧲 <strong>Rust Playground</strong></p>\n<p>下面涉及到的代码内容可以在 Rust 在线 Playground 中自己尝试。链接位于：<a href=\"https://play.rust-lang.org\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Rust Playground</a></p>\n</blockquote>\n<h3 id=\"ownership\"><a href=\"#ownership\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Ownership</h3>\n<p>Rust 的 Ownership（所有权）是保证 Rust 程序「内存安全」的重点特性。什么是「内存安全」？保证「内存安全」就是指或语言本身，或使用语言的开发者，在其程序运行时管理系统的「内存分配」的过程中保证内存没有浪费、没有泄露。我们一般的程序都需要实施「静态」与「动态」两种形式的内存分配，其中前者指已知变量所需空间，直接在内存中划分一部分不变的区域给变量；后者为在程序运行过程中动态地给变量分配内存空间，使得变量能够在程序运行时变化地占用内存大小。</p>\n<h3 id=\"数据存储方式\"><a href=\"#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>数据存储方式</h3>\n<p>Rust 是使用「栈」和「堆」这两种数据结构来对这两种内存分配形式进行划分的。为了更好的理解 Rust 的 Ownership 的工作机制，我们首先看看 Rust 是如何利用「栈」和「堆」进行内存分配。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215236-3.png\" alt=\"使用「栈」和「堆」进行内存分配\"><figcaption>使用「栈」和「堆」进行内存分配</figcaption></figure>\n<p>首先，「栈」从实现上来说是一种效率非常高的数据结构，因为「栈」拥有「后进先出」的数据存储特点（LIFO），使得最后压入栈顶的元素会被最先从栈顶移出。这种数据结构的优势在于：当我们用「栈」来维护内存数据时，<strong>我们只需要维护「栈顶」元素的信息即可</strong>。同时，Rust 内存管理的「栈」在编译时即可知道其具体大小，静态分配内存空间即可<sup id=\"fnref-3\"><a href=\"#fn-3\" class=\"footnote-ref\">3</a></sup>。</p>\n<p>而 Rust 的「堆」则不一样，「堆」是一个动态分配内存空间的数据结构。当我们使用「堆」分配内存空间时，我们实际上是在「堆」上寻找对应的内存地址，将之标记，并返回与之相对映的指针。这一过程跟我们 C、C++ 中的 allocate memory 的原理是一致的。</p>\n<h3 id=\"所有权如何保证内存安全\"><a href=\"#%E6%89%80%E6%9C%89%E6%9D%83%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>所有权如何保证内存安全</h3>\n<p>为什么 Rust 需要引入「所有权」的机制？因为 Rust 保证「内存安全」的方法是：追踪第二种「堆」结构中哪部分数据被哪部分代码使用，从而尽量减少「堆」中的重复数据，保证「堆」中不出现有未使用的数据等问题。</p>\n<blockquote>\n<p>Keeping track of what parts of code are using what data on the heap, minimizing the amount of duplicate data on the heap, and cleaning up unused data on the heap so you don’t run out of space are all problems that ownership addresses. —— <a href=\"https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">The Rust Book</a></p>\n</blockquote>\n<p>Rust 正是使用基于「所有权」理念的一系列规定来保证 Rust 程序的「内存安全」。这其中的机制包括：</p>\n<ul>\n<li>Rust 中的每个「值」都有一个被叫做 owner 的变量（所有者）</li>\n<li>同一时间只能有一个 owner</li>\n<li>当 owner 离开我们程序段的 scope 之后，这一「值」就会被释放掉</li>\n</ul>\n<p>我们来看下面的几个例子，来具体看看 Rust 如何保证「内存安全」的。</p>\n<p>我们以 Rust 中字符串（String Literal）为例子，Rust 中字符串有 <code class=\"language-text\">&amp;str</code> 的静态字符串变量，以及 <code class=\"language-text\">String</code> 的动态字符串变量。我们来看看 Rust 是如何分别利用「栈」来存储 <code class=\"language-text\">&amp;str</code>、用「堆」来存储 <code class=\"language-text\">String</code> 的。</p>\n<p>首先来看一个 <code class=\"language-text\">&amp;str</code> 的例子：</p>\n<pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// &amp;str 用「栈」存储</span>\n  <span class=\"token keyword\">let</span> s1 <span class=\"token operator\">=</span> <span class=\"token string\">\"Hello\"</span><span class=\"token punctuation\">;</span>    <span class=\"token comment\">// 字符串 \"Hello\" 赋值给变量 s1</span>\n  <span class=\"token keyword\">let</span> s2 <span class=\"token operator\">=</span> s1<span class=\"token punctuation\">;</span>         <span class=\"token comment\">// 将变量 s1 复制并赋值给 s2</span>\n  <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}\"</span><span class=\"token punctuation\">,</span> s1<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// 这样做没有问题！</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>可以发现，当我们直接使用 <code class=\"language-text\">&amp;str</code> 存储字符串时，Rust 是将前一个变量 <code class=\"language-text\">s1</code> 的值<strong>直接复制</strong>给后一个变量 <code class=\"language-text\">s2</code>，前一个变量 <code class=\"language-text\">s1</code> 并没有变化。此时我们访问前一个变量 <code class=\"language-text\">s1</code> 没有任何问题。</p>\n<p>接下来，我们来看一个 <code class=\"language-text\">String</code> 的例子：</p>\n<pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// String 用「堆」存储</span>\n  <span class=\"token keyword\">let</span> s1 <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Hello again\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// String 变量 \"Hello again\" 赋值给 s1</span>\n  <span class=\"token keyword\">let</span> s2 <span class=\"token operator\">=</span> foo<span class=\"token punctuation\">;</span>                         <span class=\"token comment\">// 将 s1 变量中的内容「移动」到 s2 中</span>\n  <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{}, {}\"</span><span class=\"token punctuation\">,</span> s1<span class=\"token punctuation\">,</span> s2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>           <span class=\"token comment\">// 出错了！s1 中内容被 moved，无法被 reference</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>此时，编译器会报出 <code class=\"language-text\">error[E0382]: borrow of moved value: &#39;s1&#39;</code> 的错误。可以发现，当我们使用 String 存储字符串时，Rust 不会将变量的值「复制」，而是会将变量「移动」到目标变量中。这种情况下，Rust 会认为前一个变量 <code class=\"language-text\">s1</code> 已经不再有效（no longer valid），因此，当我们在之后试图访问 <code class=\"language-text\">s1</code> 时，Rust 就会报出这一错误。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215236-4.png\" alt=\"error[E0382] 报错\"><figcaption>error[E0382] 报错</figcaption></figure>\n<p>为什么 Rust 在使用「堆」进行动态内存分配时，会 move 而不 copy 呢？一方面是因为 copy 的消耗是比 move 大得多的；另一方面，Rust 这一设计恰好帮助我们避免了 C 语言中非常可能遇到的一种内存泄露的问题：<strong>double free 异常</strong><sup id=\"fnref-4\"><a href=\"#fn-4\" class=\"footnote-ref\">4</a></sup>。</p>\n<p>Double free 异常是如何发生的？当我们使用 <code class=\"language-text\">String</code> 类型来存储字符串时，我们实际上存储了以下三个 field 的值：<code class=\"language-text\">ptr</code>、<code class=\"language-text\">len</code>、<code class=\"language-text\">capacity</code>。<code class=\"language-text\">ptr</code> 指向存储字符串内容的内存空间。比如 <code class=\"language-text\">let s1 = String::from(&quot;Hello&quot;);</code> 即声明了如下的存储方式：</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215236-5.png\" alt=\"String 的存储方式\"><figcaption>String 的存储方式</figcaption></figure>\n<p>我们如果使用 <code class=\"language-text\">copy</code> 将 String <code class=\"language-text\">s1</code> 复制给 <code class=\"language-text\">s2</code>，我们实际上就将三个 field 的值 <code class=\"language-text\">ptr</code>、<code class=\"language-text\">len</code> 和 <code class=\"language-text\">capacity</code> 全部复制，也就是我们的 <code class=\"language-text\">ptr</code> 指针实际上指向上一块地址空间，如下图所示：</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215236-6.png\" alt=\"使用 copy 将 s1 复制给 s2\"><figcaption>使用 copy 将 s1 复制给 s2</figcaption></figure>\n<p>前面我们提到了，<em>对于一个「值」来说，当程序离开「值」的 owner 所在的 scope 之后，这一「值」就会被释放掉</em>，那么当我们离开 <code class=\"language-text\">s1</code> 和 <code class=\"language-text\">s2</code> 所在的 scope 之后，程序则会试图将这两个「值」的内存空间全部释放，而此时 <code class=\"language-text\">s1</code> 和 <code class=\"language-text\">s2</code> 指向同一块地址空间，<strong>这种情况下就会出现 double free 异常的情况</strong>。</p>\n<blockquote>\n<p>Freeing memory twice can lead to memory corruption, which can potentially lead to security vulnerabilities.</p>\n</blockquote>\n<p>而我们 Rust 就通过「所有权」规避了这一问题，如下图所示，Rust 在上述过程中，实际上是将 <code class=\"language-text\">s1</code> 的值移动到了 <code class=\"language-text\">s2</code> 上，在 <code class=\"language-text\">s2</code> 的指针指向对应的内存空间时，Rust 会认为 <code class=\"language-text\">s1</code> 此时已经无用了，从而直接 invalidate 掉 <code class=\"language-text\">s1</code>，那么当我们程序离开当前 scope 后，valid 的「值」只有 <code class=\"language-text\">s2</code>，Rust 就只会将 <code class=\"language-text\">s2</code> 释放，从而避免出现 double free 异常的情况。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215236-7.png\" alt=\"Rust 中 s1 move 给 s2 之后，s1 被认为 invalid\"><figcaption>Rust 中 s1 move 给 s2 之后，s1 被认为 invalid</figcaption></figure>\n<p>不过，如果我们此时一定要访问 <code class=\"language-text\">s1</code> 的内容怎么办？Rust 有一个专门的方法，让 <code class=\"language-text\">s2</code> 创建时，不 move 而是深度拷贝 <code class=\"language-text\">s1</code> 的全部内容，如下图所示：</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-215236-8.png\" alt=\"Rust 中将 s1 deep copy 给 s2\"><figcaption>Rust 中将 s1 deep copy 给 s2</figcaption></figure>\n<p>这里 Rust 所做的事情类似于其他语言中的 deep copy —— 花费更大的开销，将 <code class=\"language-text\">s1</code> 字符串对应的「堆」复制一个，再分配内存空间存储复制出来的 <code class=\"language-text\">s1</code> 并将之赋给 <code class=\"language-text\">s2</code>。在 Rust 中我们可以用 <code class=\"language-text\">&lt;VARIABLE&gt;.clone()</code> 来表示这一功能：</p>\n<pre class=\"language-rust\"><code class=\"language-rust\"><span class=\"token keyword\">fn</span> <span class=\"token function-definition function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> s1 <span class=\"token operator\">=</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">::</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> s2 <span class=\"token operator\">=</span> s1<span class=\"token punctuation\">.</span><span class=\"token function\">clone</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token macro property\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"s1 = {}, s2 = {}\"</span><span class=\"token punctuation\">,</span> s1<span class=\"token punctuation\">,</span> s2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>上面的代码就不会出现类似的错误了。Rust 语言<strong>对「动态」数据结构</strong>都有类似的功能安排：利用 Ownership 的设计思想，在没有垃圾回收的基础之上，避免内存错误。</p>\n<h2 id=\"小结\"><a href=\"#%E5%B0%8F%E7%BB%93\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>小结</h2>\n<p>Rust 的确是一门神奇的语言，不仅拥有 C、C++ 等系统级别语言的高效迅速，还利用 Ownership 的设计思想保证了内存安全。上面仅仅是 Rust 语言中一个小小的独特之处，由于这一特性所保证的功能我在其他语言中也有过类似的体验（比如 Python 的 deep copy 与 shallow copy<sup id=\"fnref-5\"><a href=\"#fn-5\" class=\"footnote-ref\">5</a></sup>），因此拿来和大家分享。Rust 还有更多有趣的设计与内容等待大家发掘。感谢阅读。</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">\n<p><a href=\"https://stackoverflow.blog/2020/01/20/what-is-rust-and-why-is-it-so-popular/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">What is Rust and why is it so popular? - Stack Overflow Blog</a></p>\n<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-2\">\n<p><a href=\"https://www.reddit.com/r/rust/comments/5lg3ih/what_do_rusts_buzzwords_like_safe_and_zerocost/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">What do Rust's buzzwords like \"safe\" and \"zero-cost abstraction\" mean?</a></p>\n<a href=\"#fnref-2\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-3\">\n<p><a href=\"https://medium.com/@thomascountz/ownership-in-rust-part-1-112036b1126b\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Ownership in Rust, Part 1 - Medium</a></p>\n<a href=\"#fnref-3\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-4\">\n<p><a href=\"https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">The Rust Programming Language - Understanding Ownership</a></p>\n<a href=\"#fnref-4\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-5\">\n<p><a href=\"https://www.geeksforgeeks.org/copy-python-deep-copy-shallow-copy/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">copy in Python (Deep Copy and Shallow Copy) - GeeksforGeeks</a></p>\n<a href=\"#fnref-5\" class=\"footnote-backref\">↩</a>\n</li>\n</ol>\n</div>\n"}},{"node":{"title":"Reverse Proxy | 反向代理是什么？","path":"/2019/11/reverse-proxy/","date":"November 22. 2019","timeToRead":11,"cjkWordCount":2619,"cjkReadTime":12,"description":"Nginx 反向代理的工作原理","content":"<p><a href=\"https://blog.spencerwoo.com/2019/11/tiny-tiny-rss/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Tiny Tiny RSS | 最速部署私有 RSS 服务器</a> 这篇文章里面，我们提到了「利用 Nginx 作为反向代理」来为 Tiny Tiny RSS 服务加上 SSL 支持。事实上，我经常都能在各个和 Nginx、Apache Server 等相关文档里面看到「反向代理」这个术语。今天我们就来看看，到底什么是反向代理？「反向代理」的工作原理，以及我们都可以用「反向代理」来干什么？</p>\n<h2 id=\"proxy什么是代理\"><a href=\"#proxy%E4%BB%80%E4%B9%88%E6%98%AF%E4%BB%A3%E7%90%86\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Proxy：什么是代理？</h2>\n<p>首先，反向代理（Reverse Proxy）是一种代理（Proxy）服务。为了搞清楚「反向代理」，我们首先来说一说「代理 - Proxy」。</p>\n<p>相信阅读这篇文章的同学一定对 Proxy 这个名词不陌生，<del>Mainland China 互联网现状让大部分同学的计算机网络知识突飞猛进</del>😂。简单来说，Proxy 服务器的主要功能就是在客户端 Client 和服务端 Server 之间搭建一个桥梁，从客户端访问服务端的网络流量、以及从服务端返回客户端的网络流量都会经由这一 Proxy 服务器的转发。<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup></p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-214045.png\" alt=\"功能示意\"><figcaption>功能示意</figcaption></figure>\n<p>为了方便表述，我们就叫我们的 Proxy 服务器：咕咕，一只鸽子。🐦</p>\n<h2 id=\"正向代理和反向代理\"><a href=\"#%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>正向代理和反向代理</h2>\n<h3 id=\"forward-proxy正向代理\"><a href=\"#forward-proxy%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Forward Proxy：正向代理</h3>\n<p>飞鸽传书嘛，信鸽主要功能就是通风报信，我们这里的咕咕也不例外。咕咕在正常情况下是我们自己（客户端）的，也就意味着：咕咕会在 Client 前面等待送信。当 Client 准备发送一个请求的时候，咕咕会拿着这个请求，在公共互联网上面，将请求准确送达至对应的 Server。同理，Server 返回 response 给 Client，response 也会先被咕咕拿到，之后再转交给 Client。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-214045-1.png\" alt=\"Forward Proxy 的工作原理\"><figcaption>Forward Proxy 的工作原理</figcaption></figure>\n<p>上面就是「正向代理」的基本工作流程，咕咕就是我们这个例子里面的正向代理服务器，负责转发和接受从 Client 发出或收到的网络请求。我们用正向代理（Forward Proxy），<del>除了大家人尽皆知的目的以外</del>😂，还可以：</p>\n<ul>\n<li>有效屏蔽广告、追踪脚本等有害请求。咕咕可以选择性的将 Server 发来的内容进行屏蔽，也就是：咕咕知道这次发来的是个广告，不给我们看也无妨大碍，那为了让我们浏览体验更加纯净，咕咕就非常体贴的丢掉了这一广告。爱了 ❤️ <sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup></li>\n<li>有效的隐藏我们的身份。因为咕咕在你没有用到它的时候，可以并行的为其他同学传递请求。这时候，Server 是无从知道请求的真正来源的，只知道是由咕咕转手的，从而保证我们身份匿名性。</li>\n</ul>\n<h3 id=\"reverse-proxy反向代理\"><a href=\"#reverse-proxy%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Reverse Proxy：反向代理</h3>\n<p>那么反向代理是怎样工作的呢？在反向代理中，我们的咕咕现在由服务器 Server 养活（部署），也就是说，咕咕在服务器端通风报信。每个从 Client 经由互联网发过来的请求会先到达咕咕这里，咕咕再将每个请求分发给相应的服务器。反之亦然。这就是「反向代理」的基本工作原理，我们在这个例子里面的「咕咕」，就是我们的反向代理服务器。（Reverse Proxy Server）</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-214045-2.png\" alt=\"Reverse Proxy 的工作原理\"><figcaption>Reverse Proxy 的工作原理</figcaption></figure>\n<p>为什么我们服务端也需要一个这样的咕咕呢？因为我们的咕咕不仅勤劳，还很坚强。要知道，不是所有的目标服务器都像我们咕咕那么坚强，目标服务器很多时候会因为直接收到的信件过多（收到过多的请求）而被淹没，甚至宕机。如果有咕咕的帮助，目标服务器就不会因为请求过多而无法处理，同时如果咕咕发现一个服务的请求太多，我们可以将这一服务增加多个服务器共同处理，咕咕这时候就可以将服务的请求进行分流，从而减轻单个服务器的处理负担。<strong>这也就是「反向代理」在「负载均衡」方面的应用。</strong></p>\n<p>事实上，反向代理服务器有更多的应用，我们接下来就具体说一说我在服务器上面都利用 Nginx 反向代理服务器做了哪些有用的事情。</p>\n<h2 id=\"nginx-反向代理的实际应用\"><a href=\"#nginx-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Nginx 反向代理的实际应用</h2>\n<p>在我的（<a href=\"https://blog.tenkeyseven.com\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">@TenkeySeven</a> 的）服务器上面，有这样的几个服务：</p>\n<ul>\n<li><a href=\"https://tt-rss.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Tiny Tiny RSS 服务</a></li>\n<li><a href=\"https://github.com/netdata/netdata\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Netdata 服务器监控服务</a></li>\n<li>Nginx 直接 serve 的一个默认静态页面</li>\n</ul>\n<p>事实上，这三个服务都运行在这样的一个服务器上面，但是绑定了不同的域名。比如：</p>\n<ul>\n<li>Tiny Tiny RSS 服务对应域名：<a href=\"https://ttrss.tenkeyseven.com\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://ttrss.tenkeyseven.com</a>（需要登录）</li>\n<li>Netdata 服务对应域名：<a href=\"https://stats.tenkeyseven.com\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://stats.tenkeyseven.com</a>（可以公开访问）</li>\n<li>Nginx 测试静态页面对应域名：<a href=\"https://tenkeyseven.com\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://tenkeyseven.com</a>（可以公开访问）</li>\n</ul>\n<p>我们连接到服务器上面，执行下面的命令来查看端口占用情况：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">netstat</span> <span class=\"token parameter variable\">-tulpn</span> <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> LISTEN</code></pre>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-214045-3.png\" alt=\"端口占用情况\"><figcaption>端口占用情况</figcaption></figure>\n<p>通过查看端口占用情况，我们可以非常清晰的看到：</p>\n<ul>\n<li>Tiny Tiny RSS 运行于 Docker 容器中，对外的 exposed 端口是 181</li>\n<li>Netdata 前端服务直接监听的端口是 19999</li>\n<li>Nginx 默认 serve 的静态页面直接监听 80 端口（HTTP）</li>\n</ul>\n<p><a href=\"https://blog.tenkeyseven.com\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">@TenkeySeven</a> 将主域名和上面提到的两个子域名的 DNS 解析均设置为我们的服务器，因此，当我们访问上面任意一个域名的时候，请求均直接发给服务器上面运行的 Nginx 反向代理服务。</p>\n<p>对 Nginx 来说，只需要识别这些域名对应的请求应该转发给具体哪个服务，就可以让请求被正确处理，这样也就实现了我们多个域名对应一个服务器上的多个服务的需求。</p>\n<p>Nginx 全部功能均由配置文件 <code class=\"language-text\">nginx.conf</code> 来设置，这一配置文件通常位于 <code class=\"language-text\">/etc/nginx/nginx.conf</code>，我们仔细看一下 Nginx 的配置文件。</p>\n<h3 id=\"对-upstream-服务器的定义\"><a href=\"#%E5%AF%B9-upstream-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%AE%9A%E4%B9%89\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>对 upstream 服务器的定义</h3>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-214045-4.png\" alt=\"对 upstream 服务器的声明\"><figcaption>对 upstream 服务器的声明</figcaption></figure>\n<p>首先，我们在 Nginx 的 <code class=\"language-text\">http</code> 项目下，定义了我们可能需要用到的 upstream 服务器。比如，对 Tiny Tiny RSS 来说，就是 181 端口的服务，用下面的语法进行声明：</p>\n<pre class=\"language-nginx\"><code class=\"language-nginx\"><span class=\"token directive\"><span class=\"token keyword\">upstream</span> ttrssdev</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token directive\"><span class=\"token keyword\">server</span> 127.0.0.1:181</span><span class=\"token punctuation\">;</span>\n    <span class=\"token directive\"><span class=\"token keyword\">keepalive</span> <span class=\"token number\">64</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>这样，下面 <code class=\"language-text\">ttrss.tenkeyseven.com</code> 域名的 Proxy 转发规则就可以直接用 <code class=\"language-text\">http://ttrssdev</code> 的格式进行声明了。</p>\n<h3 id=\"默认-web-root-的定义\"><a href=\"#%E9%BB%98%E8%AE%A4-web-root-%E7%9A%84%E5%AE%9A%E4%B9%89\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>默认 Web Root 的定义</h3>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-214045-5.png\" alt=\"默认访问 Web Root 的配置\"><figcaption>默认访问 Web Root 的配置</figcaption></figure>\n<p>可以发现，当我们服务并不绑定任何上游服务器，而是直接由 Nginx 来提供服务的时候，Nginx 可以直接 serve 一个目标路径里面的 HTML 文件，比如这里的 <code class=\"language-text\">/usr/share/nginx/html</code>。此时，直接访问默认主域名 <code class=\"language-text\">tenkeyseven.com</code>，我们就能直接看到一个默认的静态网页。具体来说，Nginx 就是下面这部分内容的配置，知道当请求匹配到 <code class=\"language-text\">server_name</code> 定义的域名时，serve <code class=\"language-text\">root</code> 处定义的 HTML 静态网站。</p>\n<pre class=\"language-nginx\"><code class=\"language-nginx\"><span class=\"token directive\"><span class=\"token keyword\">server</span></span> <span class=\"token punctuation\">{</span>\n   <span class=\"token directive\"><span class=\"token keyword\">server_name</span> tenkeyseven.com</span><span class=\"token punctuation\">;</span> <span class=\"token comment\"># managed by Certbot</span>\n       <span class=\"token directive\"><span class=\"token keyword\">root</span>         /usr/share/nginx/html</span><span class=\"token punctuation\">;</span>\n       <span class=\"token comment\"># ...</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"proxy-转发规则的定义\"><a href=\"#proxy-%E8%BD%AC%E5%8F%91%E8%A7%84%E5%88%99%E7%9A%84%E5%AE%9A%E4%B9%89\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Proxy 转发规则的定义</h3>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-214045-6.png\" alt=\"反向代理 Tiny Tiny RSS 转发规则的定义\"><figcaption>反向代理 Tiny Tiny RSS 转发规则的定义</figcaption></figure>\n<p>当我们需要让 Nginx 反向代理转发我们的请求至 upstream 服务的时候，就是类似这样的配置。此时，当请求匹配到 <code class=\"language-text\">server_name</code> 定义的 <code class=\"language-text\">ttrss.tenkeyseven.com</code> 时，Nginx 不 serve <code class=\"language-text\">root</code> 处定义的页面，而是在 <code class=\"language-text\">location / { ... }</code> 处找到 <code class=\"language-text\">proxy_pass</code> 的定义，将请求对应的转发到目标服务那里。可以看到，这里我们直接声明了 <code class=\"language-text\">proxy_pass http://ttrssdev;</code>，于是，当我们访问 <code class=\"language-text\">https://ttrss.tenkeyseven.com</code> 的时候，Nginx 反向代理服务会直接将请求转发至我们部署的 Tiny Tiny RSS 服务，在服务器上就是 <code class=\"language-text\">localhost:181</code> 的服务。</p>\n<p>Nginx 反向代理具体的配置如下 <code class=\"language-text\">location / { ... }</code> 里面的配置：</p>\n<pre class=\"language-nginx\"><code class=\"language-nginx\"><span class=\"token directive\"><span class=\"token keyword\">server</span></span> <span class=\"token punctuation\">{</span>\n   <span class=\"token directive\"><span class=\"token keyword\">server_name</span> ttrss.tenkeyseven.com</span><span class=\"token punctuation\">;</span> <span class=\"token comment\"># managed by Certbot</span>\n       <span class=\"token comment\"># root         /usr/share/nginx/html;</span>\n\n       <span class=\"token comment\"># Load configuration files for the default server block.</span>\n       <span class=\"token directive\"><span class=\"token keyword\">include</span> /etc/nginx/default.d/*.conf</span><span class=\"token punctuation\">;</span>\n\n       <span class=\"token directive\"><span class=\"token keyword\">location</span> /</span> <span class=\"token punctuation\">{</span>\n           <span class=\"token directive\"><span class=\"token keyword\">proxy_redirect</span> <span class=\"token boolean\">off</span></span><span class=\"token punctuation\">;</span>\n           <span class=\"token directive\"><span class=\"token keyword\">proxy_pass</span> http://ttrssdev</span><span class=\"token punctuation\">;</span>\n\n           <span class=\"token directive\"><span class=\"token keyword\">proxy_set_header</span>  Host                <span class=\"token variable\">$http_host</span></span><span class=\"token punctuation\">;</span>\n           <span class=\"token directive\"><span class=\"token keyword\">proxy_set_header</span>  X-Real-IP           <span class=\"token variable\">$remote_addr</span></span><span class=\"token punctuation\">;</span>\n           <span class=\"token directive\"><span class=\"token keyword\">proxy_set_header</span>  X-Forwarded-Ssl     <span class=\"token boolean\">on</span></span><span class=\"token punctuation\">;</span>\n           <span class=\"token directive\"><span class=\"token keyword\">proxy_set_header</span>  X-Forwarded-For     <span class=\"token variable\">$proxy_add_x_forwarded_for</span></span><span class=\"token punctuation\">;</span>\n           <span class=\"token directive\"><span class=\"token keyword\">proxy_set_header</span>  X-Forwarded-Proto   <span class=\"token variable\">$scheme</span></span><span class=\"token punctuation\">;</span>\n           <span class=\"token directive\"><span class=\"token keyword\">proxy_set_header</span>  X-Frame-Options     SAMEORIGIN</span><span class=\"token punctuation\">;</span>\n\n           <span class=\"token directive\"><span class=\"token keyword\">client_max_body_size</span>        <span class=\"token number\">100m</span></span><span class=\"token punctuation\">;</span>\n           <span class=\"token directive\"><span class=\"token keyword\">client_body_buffer_size</span>     <span class=\"token number\">128k</span></span><span class=\"token punctuation\">;</span>\n\n           <span class=\"token directive\"><span class=\"token keyword\">proxy_buffer_size</span>           <span class=\"token number\">4k</span></span><span class=\"token punctuation\">;</span>\n           <span class=\"token directive\"><span class=\"token keyword\">proxy_buffers</span>               <span class=\"token number\">4</span> <span class=\"token number\">32k</span></span><span class=\"token punctuation\">;</span>\n           <span class=\"token directive\"><span class=\"token keyword\">proxy_busy_buffers_size</span>     <span class=\"token number\">64k</span></span><span class=\"token punctuation\">;</span>\n           <span class=\"token directive\"><span class=\"token keyword\">proxy_temp_file_write_size</span>  <span class=\"token number\">64k</span></span><span class=\"token punctuation\">;</span>\n       <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\"># ...</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>事实上，这部分的配置非常简单。得益于 Let's Encrypt 的存在，我们可以利用 Certbot 在签署每个域名的 SSL 证书时，自动生成对应服务的转发配置。因此，事实上我们只需要声明前面介绍的 upstream 服务，并在 Certbot 生成的对应域名下的 location 子项处将服务器对应到反向代理的配置项处即可。</p>\n<h2 id=\"小结\"><a href=\"#%E5%B0%8F%E7%BB%93\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>小结</h2>\n<p>最后，我们可以看到，经过这样的配置，我们从外界互联网访问我们服务器的请求，就被 Nginx 反向代理分别导向了对应的服务器，从而实现了多个域名对应多个服务，并部署在同一个服务器上面的功能。同时，Nginx 反向代理服务统一帮我们管理了 SSL 证书的签署，因此无论是从外界来访问我们服务器的请求，还是我们服务器里面某个服务返回给外界的请求，都是经过加密的 HTTPS 请求。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-214045-7.png\" alt=\"Nginx 反向代理在上文中的功能\"><figcaption>Nginx 反向代理在上文中的功能</figcaption></figure>\n<p>Nginx 反向代理服务器还有更多的功能，比如：</p>\n<ul>\n<li>前文提到的负载均衡（Load balance）</li>\n<li>用反向代理来作为 CDN，cache 一部分资源，加快访问速度</li>\n<li>在请求到达目标服务器之前，反向代理服务器事先过滤掉一部分恶意请求，保证提供服务的目标服务器的稳定工作</li>\n<li>……</li>\n</ul>\n<p>抛砖引玉，感谢阅读。</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">\n<p><a href=\"https://www.cloudflare.com/learning/cdn/glossary/reverse-proxy/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">What Is A Reverse Proxy? | Proxy Servers Explained - Cloudflare</a></p>\n<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-2\">\n<p><a href=\"https://www.youtube.com/watch?v=KBXTnrD_Zs4\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Block EVERY Online Ad with THIS / Linus Tech Tips</a></p>\n<a href=\"#fnref-2\" class=\"footnote-backref\">↩</a>\n</li>\n</ol>\n</div>\n"}},{"node":{"title":"Tiny Tiny RSS | 最速部署私有 RSS 服务器","path":"/2019/11/tiny-tiny-rss/","date":"November 18. 2019","timeToRead":12,"cjkWordCount":3039,"cjkReadTime":14,"description":"使用 Awesome TTRSS 部署 Tiny Tiny RSS 的 Docker 镜像","content":"<p>9012 年了，别的小朋友们服务器上面跑着各式各样的东西：博客、云盘、监控脚本……再看看我们那台闲（bai）置（piao）很久的阿里云 Server，里面的 Git 竟然还是 1.8 的上古版本。🤦‍♂️ 不如把那台服务器拿出来，部署一个属于自己的 RSS 服务器，甚至可以跟同学们一起用呢～</p>\n<h2 id=\"rss\"><a href=\"#rss\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>RSS</h2>\n<p>首先我们来说一说 RSS。RSS 的全称是 Really Simple Syndication（简易信息聚合），它是一种消息来源的格式规范，网站可以按照这种格式规范提供文章的标题、摘要、全文等信息给订阅用户，用户可以通过订阅不同网站 RSS 链接的方式将不同的信息源进行聚合，在一个工具里阅读这些内容。</p>\n<p>对于第一次接触 RSS 的同学，推荐大家阅读：<a href=\"https://sspai.com/post/56391\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">高效获取信息，你需要这份 RSS 入门指南</a>，进行扫盲。</p>\n<p>市面上有非常多的 RSS 聚合服务，来帮助我们统一管理、订阅、更新、筛选 RSS 源推送给我们的更新信息，避免我们被海量的文章淹没，也能保证我们多个设备上 RSS 的阅读进度一致。Feedly、Inoreader 等等都是非常不错的 RSS 服务，但是它们的免费版本都有着一定的限制，有时候无法满足我们的全部功能需求，而动辄一个月数十刀的订阅费用又让人望而却步。不慌，开源的 RSS 服务：Tiny Tiny RSS 可以满足我们 RSS 订阅的全部需求！</p>\n<h2 id=\"tiny-tiny-rss-的搭建\"><a href=\"#tiny-tiny-rss-%E7%9A%84%E6%90%AD%E5%BB%BA\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Tiny Tiny RSS 的搭建</h2>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220309.jpg\" alt=\"使用 Feedly 主题的 Tiny Tiny RSS 服务端\"><figcaption>使用 Feedly 主题的 Tiny Tiny RSS 服务端</figcaption></figure>\n<p>Tiny Tiny RSS 是一个非常优秀的开源免费 RSS 服务引擎，可以直接部署在我们自己的服务器上面，借助于 Docker 优秀方便的容器技术和 Let’s Encrypt 异常简单的 SSL 证书签署机器人 <code class=\"language-text\">certbot</code>，我们几分钟之内就可以部署上线属于我们自己的 RSS 服务，运行在我们可控的服务器上，环境稳定，刷新及时，并且完全免费。👍（当然，除了服务器需要一定的费用。）</p>\n<p>在容器、HTTPS 证书自动签署和虚拟化技术极度发达的今天，整个部署过程非常方便简单。我接下来只利用 iPad 进行讲解演示我们的部署过程。请大家坐和放宽，我们立刻开始。</p>\n<h2 id=\"准备工作\"><a href=\"#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>准备工作</h2>\n<p>在开始之前，首先我们需要准备一个位于公网的服务器，以及一个可以通过 SSH 连接到服务器上的本地设备。这里我使用我同（bai）学（piao）的已经备案的阿里云服务器作为运行 Tiny Tiny RSS 的服务器，并使用 iPad 和 Blink Shell（一个支持 SSH 协议的 iOS 终端 App）作为我的操作设备。Blink Shell 是 iPad 上面最好用的 SSH/Mosh 工具，推荐大家使用。我们在 Blink Shell 中配置好服务器私钥，通过 SSH 登录服务器。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220309-1.jpg\" alt=\"利用 Blink Shell 登录至服务器\"><figcaption>利用 Blink Shell 登录至服务器</figcaption></figure>\n<h2 id=\"利用-docker-部署-tiny-tiny-rss\"><a href=\"#%E5%88%A9%E7%94%A8-docker-%E9%83%A8%E7%BD%B2-tiny-tiny-rss\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>利用 Docker 部署 Tiny Tiny RSS</h2>\n<h3 id=\"安装-docker\"><a href=\"#%E5%AE%89%E8%A3%85-docker\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>安装 Docker</h3>\n<p>Docker 是非常优秀的虚拟化容器，借助于 Docker 我们可以方便的部署 Tiny Tiny RSS，首先我们在服务器上安装 Docker 本体。在服务器上面执行下面命令来安装 Docker：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">curl</span> <span class=\"token parameter variable\">-fsSL</span> https://get.docker.com/ <span class=\"token operator\">|</span> <span class=\"token function\">sh</span></code></pre>\n<p>然后启动 Docker 服务：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> systemctl start <span class=\"token function\">docker</span></code></pre>\n<p>然后，我们检查一下 Docker 是否启动成功。我们执行命令：<code class=\"language-text\">sudo systemctl status docker</code>：</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220309-2.jpg\" alt=\"检查 Docker 服务状态\"><figcaption>检查 Docker 服务状态</figcaption></figure>\n<p>看到如上的输出，说明我们 Docker 服务启动成功。</p>\n<p><em>参考资料：<a href=\"https://docs.docker.com/install/linux/docker-ce/centos/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Get Docker Engine - Community for CentOS | Docker Documentation</a></em></p>\n<h3 id=\"安装-docker-compose\"><a href=\"#%E5%AE%89%E8%A3%85-docker-compose\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>安装 docker-compose</h3>\n<p>接下来我们安装 <code class=\"language-text\">docker-compose</code>：一个管理和启动多个 Docker 容器的工具。由于 Tiny Tiny RSS 依赖有 PostgreSQL 的数据库服务以及 <a href=\"https://github.com/HenryQW/mercury_fulltext\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">mercury_fulltext</a> 的全文抓取服务等等，这些服务我们都借助于 Docker 部署，因此利用 <code class=\"language-text\">docker-compose</code> 就会大大降低我们的部署难度。</p>\n<p>我们继续，在服务器上面执行下面的命令来安装 <code class=\"language-text\">docker-compose</code>：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">curl</span> <span class=\"token parameter variable\">-L</span> https://github.com/docker/compose/releases/download/1.25.0/docker-compose-<span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">uname</span> <span class=\"token parameter variable\">-s</span><span class=\"token variable\">`</span></span>-<span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">uname</span> <span class=\"token parameter variable\">-m</span><span class=\"token variable\">`</span></span> <span class=\"token parameter variable\">-o</span> /usr/local/bin/docker-compose</code></pre>\n<p>之后给予安装好的 <code class=\"language-text\">docker-compose</code> 可执行权限：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">chmod</span> +x /usr/local/bin/docker-compose</code></pre>\n<p><em>参考资料：<a href=\"https://docs.docker.com/compose/install/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Install Docker Compose | Docker Documentation</a></em></p>\n<p>最后我们运行 <code class=\"language-text\">docker-compose --version</code> 来检查安装是否成功。如果有如下输出，说明我们的 <code class=\"language-text\">docker-compose</code> 安装成功：</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220309-3.jpg\" alt=\"检查 docker-compose 安装情况\"><figcaption>检查 docker-compose 安装情况</figcaption></figure>\n<h3 id=\"安装-tiny-tiny-rss-及其周边服务\"><a href=\"#%E5%AE%89%E8%A3%85-tiny-tiny-rss-%E5%8F%8A%E5%85%B6%E5%91%A8%E8%BE%B9%E6%9C%8D%E5%8A%A1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>安装 Tiny Tiny RSS 及其周边服务</h3>\n<p>准备工作已经全部完成，接下来我们下载由 Awesome-TTRSS 配置的 Tiny Tiny RSS 服务的 docker-compose 配置文件：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># 创建 ttrss 目录并进入</span>\n<span class=\"token function\">mkdir</span> ttrss <span class=\"token operator\">&amp;&amp;</span> <span class=\"token builtin class-name\">cd</span> ttrss\n\n<span class=\"token comment\"># 利用 curl 下载 ttrss 的 docker-compose 配置文件至服务器</span>\n<span class=\"token function\">curl</span> <span class=\"token parameter variable\">-fLo</span> docker-compose.yml https://github.com/HenryQW/Awesome-TTRSS/raw/master/docker-compose.yml</code></pre>\n<p>修改 docker-compose.yml 里面的内容：</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220309-4.png\" alt=\"修改 docker-compose 配置文件\"><figcaption>修改 docker-compose 配置文件</figcaption></figure>\n<ul>\n<li>在配置文件的第 7 行和第 23 行，将 PostgreSQL 数据库的默认密码进行修改。暴露在公网的数据库使用默认密码非常危险。</li>\n<li>在配置文件的第 18 行，将 Tiny Tiny RSS 服务的部署网址修改。比如我的部署网址是 <code class=\"language-text\">https://ttrss.tenkeyseven.com/</code>\n- 注意，如果你的部署 URL 包含端口（比如默认部署端口为 181 端口），那么这里的 URL 也需要加上端口号，格式为 <code class=\"language-text\">{网址}:{端口}</code>\n- 不过不必担心，如果你这里的 URL 配置不正确，那么访问 Tiny Tiny RSS 的时候，Tiny Tiny RSS 会提醒你修改这里的值为正确的 URL，按照提醒进行配置即可</li>\n</ul>\n<p>之后，我们保存配置文件，启动 Tiny Tiny RSS 服务。在刚刚的 <code class=\"language-text\">ttrss</code> 目录下执行：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker-compose</span> up <span class=\"token parameter variable\">-d</span></code></pre>\n<p>等待脚本执行完成，如果一切没有问题，那么接下来输入 <code class=\"language-text\">docker ps</code>，我们应该看到类似下面的结果：</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220309-5.jpg\" alt=\"查看正在运行的 Docker 容器\"><figcaption>查看正在运行的 Docker 容器</figcaption></figure>\n<p>上面内容表示我们开启了四个 Docker 容器，分别是：</p>\n<ul>\n<li>Tiny Tiny RSS 本身，监听端口为 <code class=\"language-text\">0.0.0.0:181 -&gt; 80</code>，同时暴露给外网</li>\n<li>PostgreSQL 数据库，仅供内部使用</li>\n<li>Mercury 全文抓取服务，仅供内部使用</li>\n<li>OpenCC 简体、繁体中文转换服务，仅供内部使用</li>\n</ul>\n<p>如果发现问题，修改 docker-compose 配置文件后，需要执行下面的命令重启 Docker 容器们：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># 关闭 Docker 容器们</span>\n<span class=\"token function\">docker-compose</span> down\n\n<span class=\"token comment\"># 删除已停止的 Docker 容器</span>\n<span class=\"token function\">docker-compose</span> <span class=\"token function\">rm</span>\n\n<span class=\"token comment\"># ……</span>\n<span class=\"token comment\"># 修改 docker-compose 配置文件</span>\n<span class=\"token comment\"># ……</span>\n\n<span class=\"token comment\"># 再次开启 Docker 服务</span>\n<span class=\"token function\">docker-compose</span> up <span class=\"token parameter variable\">-d</span></code></pre>\n<h2 id=\"安装-nginx-作为-docker-容器的反向代理\"><a href=\"#%E5%AE%89%E8%A3%85-nginx-%E4%BD%9C%E4%B8%BA-docker-%E5%AE%B9%E5%99%A8%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>安装 Nginx 作为 Docker 容器的反向代理</h2>\n<p>事实上，到上一步，如果我们访问 <code class=\"language-text\">{服务器 IP}:181</code>，应该可以直接看到 Tiny Tiny RSS 的 Web 前端，但是 Tiny Tiny RSS 并不能直接配置 SSL 证书，也就没法添加 HTTPS 支持。我们利用 Nginx 作为反向代理服务器，即可方便的给 Tiny Tiny RSS 单独绑定一个我们希望的域名，并利用 Let’s Encrypt 来部署 HTTPS。</p>\n<h3 id=\"安装-nginx\"><a href=\"#%E5%AE%89%E8%A3%85-nginx\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>安装 Nginx</h3>\n<p>首先我们来安装 Nginx，以 CentOS 为例，我们直接执行下面命令即可：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> yum <span class=\"token function\">install</span> nginx</code></pre>\n<p>之后开启 Nginx 服务：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> systemctl start nginx</code></pre>\n<p>检查 Nginx 是否启动成功：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> systemctl status nginx</code></pre>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220309-6.jpg\" alt=\"检查 Nginx 运行状态\"><figcaption>检查 Nginx 运行状态</figcaption></figure>\n<h3 id=\"签署-ssl-证书部署-https\"><a href=\"#%E7%AD%BE%E7%BD%B2-ssl-%E8%AF%81%E4%B9%A6%E9%83%A8%E7%BD%B2-https\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>签署 SSL 证书，部署 HTTPS</h3>\n<p>之后，我们利用 Let’s Encrypt 提供的 <code class=\"language-text\">certbot</code> 直接为 Nginx 配置 SSL 证书。首先，我们执行下面的命令安装 <code class=\"language-text\">certbot</code>：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> yum <span class=\"token function\">install</span> certbot python2-certbot-nginx</code></pre>\n<p>然后运行 <code class=\"language-text\">certbot</code> 来签署 SSL 证书并自动配置 Nginx 服务：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> certbot <span class=\"token parameter variable\">--nginx</span></code></pre>\n<p><em>参考资料：<a href=\"https://certbot.eff.org/lets-encrypt/centosrhel7-nginx\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Certbot | Nginx on CentOS/RHEL 7</a></em></p>\n<p>在这里，certbot 会要求我们输入我们希望签署 SSL 证书的域名，我们选择为 Tiny Tiny RSS 分配的域名（比如我的就是 <code class=\"language-text\">ttrss.tenkeyseven.com</code>）即可。另外，如果 certbot 询问是否需要将访问该网址的全部流量重定向至 HTTPS，那么选择「是」即可。我们等待脚本执行签署任务完毕，然后重启 Nginx 服务：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> systemctl restart nginx</code></pre>\n<p>此时我们如果直接访问这一域名，应该就可以看到带有 HTTPS 的 Nginx 默认网站：</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220309-7.jpg\" alt=\"HTTPS 配置成功的 Nginx 默认网站\"><figcaption>HTTPS 配置成功的 Nginx 默认网站</figcaption></figure>\n<p>接下来，我们修改 Nginx 的配置文件，配置 Nginx 反向代理，将访问 <code class=\"language-text\">https://ttrss.tenkeyseven.com</code> 的请求指向我们刚刚部署好的 Tiny Tiny RSS 服务，对服务器来说，也就是 <code class=\"language-text\">127.0.0.1:181</code> 这一地址。（如果你没有更改 Tiny Tiny RSS 的端口号的话。）</p>\n<p>Nginx 的配置文件位于 <code class=\"language-text\">/etc/nginx/nginx.conf</code>，我们打开这一文件：</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220309-8.png\" alt=\"Nginx 配置文件\"><figcaption>Nginx 配置文件</figcaption></figure>\n<ul>\n<li>\n<p>在 <code class=\"language-text\">http</code> 项下，<code class=\"language-text\">server</code> 项前定义 <code class=\"language-text\">upstream</code> 服务：</p>\n<pre class=\"language-text\"><code class=\"language-text\">\t```\n\tupstream ttrssdev {\n\t\tserver 127.0.0.1:181;\n\t\tkeepalive 64;\n\t}\n\t```\n\n\t![Nginx upstream 服务声明](https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220309-9.jpg)</code></pre>\n</li>\n<li>\n<p>在刚刚 <code class=\"language-text\">certbot</code> 为我们生成好的响应域名 <code class=\"language-text\">server</code> 项下，注释掉第一行定义 <code class=\"language-text\">root</code> 的内容，并将 <code class=\"language-text\">location /</code> 项修改为：</p>\n<pre class=\"language-text\"><code class=\"language-text\">\t```\n\tlocation / {\n\t\tproxy_redirect off;\n\t\tproxy_pass http://ttrssdev;\n\n\t\tproxy_set_header  Host                $http_host;\n\t\tproxy_set_header  X-Real-IP           $remote_addr;\n\t\tproxy_set_header  X-Forwarded-Ssl     on;\n\t\tproxy_set_header  X-Forwarded-For     $proxy_add_x_forwarded_for;\n\t\tproxy_set_header  X-Forwarded-Proto   $scheme;\n\t\tproxy_set_header  X-Frame-Options     SAMEORIGIN;\n\n\t\tclient_max_body_size        100m;\n\t\tclient_body_buffer_size     128k;\n\n\t\tproxy_buffer_size           4k;\n\t\tproxy_buffers               4 32k;\n\t\tproxy_busy_buffers_size     64k;\n\t\tproxy_temp_file_write_size  64k;\n\t}\n\t```\n\n\t![Nginx 配置文件：反向代理配置](https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220309-10.jpg)</code></pre>\n</li>\n</ul>\n<p>这样，我们再次执行 <code class=\"language-text\">sudo systemctl restart nginx</code> 重启 Nginx 服务，一切顺利的话，我们就可以通过我们刚刚签署 SSL 证书的域名访问我们部署好的 Tiny Tiny RSS 服务了！鼓掌 👏</p>\n<p>Tiny Tiny RSS 的默认管理员账户密码是 admin 和 password，请在第一时间进行修改。</p>\n<h2 id=\"配置-tiny-tiny-rss\"><a href=\"#%E9%85%8D%E7%BD%AE-tiny-tiny-rss\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>配置 Tiny Tiny RSS</h2>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220309-11.jpg\" alt=\"Tiny Tiny RSS 配置、主题\"><figcaption>Tiny Tiny RSS 配置、主题</figcaption></figure>\n<p>如果上面步骤没有问题的话，我们在服务器上面所部署的 Tiny Tiny RSS 本身就已经包含了：</p>\n<ul>\n<li>Mercury 全文提取服务（默认未开启）</li>\n<li>OpenCC 繁简自动转换服务（默认未开启）</li>\n<li>Fever 格式输出插件（默认已开启，用来和 Reeder 等客户端进行连接）</li>\n<li>包括 Feedly、RSSHub 在内的多款主题</li>\n<li>等等……</li>\n</ul>\n<p>我们不需要多余的配置，开箱即可使用上面的主题和插件，根本不需要操心其他服务的部署和安装。我们登录自己的 Tiny Tiny RSS，在右上角「设置→ 插件」中即可启用上述插件，在「设置 → 主题」处就可以更改我们部署的 Tiny Tiny RSS 所用的主题。这些插件和主题在 <a href=\"https://sspai.com/post/41302\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">如何搭建属于自己的 RSS 服务，高效精准获取信息</a> 中已经介绍了使用方法，这里我就不再赘述了。</p>\n<p>如果有同学对上面的配置还有问题，请直接参考 <a href=\"https://ttrss.henry.wang/zh/#%E6%8F%92%E4%BB%B6\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Awesome TTRSS 的官方文档：🐋 Awesome TTRSS | 插件</a></p>\n<h2 id=\"小结\"><a href=\"#%E5%B0%8F%E7%BB%93\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>小结</h2>\n<p>Tiny Tiny RSS 的配置到这里就基本结束了，我相信你通过上面的配置一定已经在自己的服务器上部署成功了 Tiny Tiny RSS 服务，并为它添加了域名和 HTTPS 的支持。另外，Tiny Tiny RSS 还自带了账号系统，可以邀请其他志同道合的朋友们一起使用我们自己部署的 Tiny Tiny RSS。感谢阅读。</p>\n<p>📖 关联阅读：</p>\n<ul>\n<li><a href=\"https://ttrss.henry.wang/zh/#%E5%85%B3%E4%BA%8E\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">🐋 Awesome TTRSS</a></li>\n<li><a href=\"https://sspai.com/post/56893\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">少数派 sspai - Docker 的入门「指北」</a></li>\n<li><a href=\"https://sspai.com/post/41302\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">少数派 sspai - 如何搭建属于自己的 RSS 服务，高效精准获取信息</a></li>\n</ul>\n"}},{"node":{"title":"Batch Git Pull：分享一个维护多个 Git 仓库的小脚本","path":"/2019/11/batch-git-pull/","date":"November 13. 2019","timeToRead":4,"cjkWordCount":927,"cjkReadTime":5,"description":"如何一次更新多个 Git 仓库","content":"<p>不废话，放脚本：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">find</span> <span class=\"token builtin class-name\">.</span> <span class=\"token parameter variable\">-maxdepth</span> <span class=\"token number\">3</span> <span class=\"token parameter variable\">-name</span> .git <span class=\"token parameter variable\">-type</span> d <span class=\"token operator\">|</span> <span class=\"token function\">rev</span> <span class=\"token operator\">|</span> <span class=\"token function\">cut</span> <span class=\"token parameter variable\">-c</span> <span class=\"token number\">6</span>- <span class=\"token operator\">|</span> <span class=\"token function\">rev</span> <span class=\"token operator\">|</span> <span class=\"token function\">xargs</span> <span class=\"token parameter variable\">-I</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token function\">git</span> <span class=\"token parameter variable\">-C</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> pull</code></pre>\n<p>更为方便的，直接将这部分加入你的 <code class=\"language-text\">.zshrc</code> 或者 <code class=\"language-text\">.bash_profile</code>：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">alias</span> <span class=\"token assign-left variable\">gpall</span><span class=\"token operator\">=</span><span class=\"token string\">\"find . -maxdepth 3 -name .git -type d | rev | cut -c 6- | rev | xargs -I {} git -C {} pull\"</span></code></pre>\n<p>之后，直接执行 <code class=\"language-text\">gpall</code> 即可。</p>\n<p>好了，我们进入正题。</p>\n<h2 id=\"维护多个-git-仓库的需求\"><a href=\"#%E7%BB%B4%E6%8A%A4%E5%A4%9A%E4%B8%AA-git-%E4%BB%93%E5%BA%93%E7%9A%84%E9%9C%80%E6%B1%82\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>维护多个 Git 仓库的需求</h2>\n<p>维护多个 Git 仓库不容易。我在我存放 GitHub 仓库的目录下运行了一下 <code class=\"language-text\">tree</code>：</p>\n<pre class=\"language-text\"><code class=\"language-text\">.\n├── AIP_BackEnd\n├── Evaluation_BackEnd\n| ... ...\n├── SchoolProjects\n│   ├── Distance-Vector-Algorithm\n│   ├── cartoonize-images\n| ... ...\n│   ├── zanpress-blog\n│   └── zanpress-diagram\n| ... ...\n└── wechat-format\n\n103 directories</code></pre>\n<p>103 个目录……我自己 <code class=\"language-text\">Documents/GitHub</code> 文件夹下就有这么多 Git 仓库，一个一个去更新真的很费事情。如何批量更新 GitHub 本地仓库呢？其实就是一个遍历目录，对匹配到的 Git 仓库在其当前分支下执行 <code class=\"language-text\">git pull</code> 的需求嘛，很简单。</p>\n<h2 id=\"解决方法\"><a href=\"#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>解决方法</h2>\n<p>在 Medium 上面，我找到了一个相当优雅的脚本。前面这个脚本已经分享给各位了，我们重新看一下：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">find</span> <span class=\"token builtin class-name\">.</span> <span class=\"token parameter variable\">-maxdepth</span> <span class=\"token number\">3</span> <span class=\"token parameter variable\">-name</span> .git <span class=\"token parameter variable\">-type</span> d <span class=\"token operator\">|</span> <span class=\"token function\">rev</span> <span class=\"token operator\">|</span> <span class=\"token function\">cut</span> <span class=\"token parameter variable\">-c</span> <span class=\"token number\">6</span>- <span class=\"token operator\">|</span> <span class=\"token function\">rev</span> <span class=\"token operator\">|</span> <span class=\"token function\">xargs</span> <span class=\"token parameter variable\">-I</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token function\">git</span> <span class=\"token parameter variable\">-C</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> pull</code></pre>\n<p>可以发现，这一长串命令，事实上就是前面的命令执行结果通过「管道」输出至后面的命令作为输入，也就是命令中 <code class=\"language-text\">|</code> 的功能。我们一段一段看一下这个命令具体都干了什么。</p>\n<h3 id=\"用-find-搜索目录下全部-git-文件夹\"><a href=\"#%E7%94%A8-find-%E6%90%9C%E7%B4%A2%E7%9B%AE%E5%BD%95%E4%B8%8B%E5%85%A8%E9%83%A8-git-%E6%96%87%E4%BB%B6%E5%A4%B9\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>用 <code class=\"language-text\">find</code> 搜索目录下全部 <code class=\"language-text\">.git/</code> 文件夹</h3>\n<p>每个 Git 文件夹里面一定有 <code class=\"language-text\">.git</code> 的目录，我们只需要找到 <code class=\"language-text\">.git</code> 文件夹既可以找到 Git 目录。</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">find</span> <span class=\"token builtin class-name\">.</span> <span class=\"token parameter variable\">-maxdepth</span> <span class=\"token number\">3</span> <span class=\"token parameter variable\">-name</span> .git <span class=\"token parameter variable\">-type</span> d</code></pre>\n<p>这里，我们就使用了 <code class=\"language-text\">find</code> 的命令，详见：<a href=\"https://www.gnu.org/software/findutils/manual/html_mono/find.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">GNU - Finding Files</a>。我们将命令分解来看：</p>\n<ul>\n<li><code class=\"language-text\">.</code> 表示匹配命令执行路径下的全部文件与文件夹</li>\n<li><code class=\"language-text\">-maxdepth 3</code> 表示向下搜索最多三层级目录</li>\n<li><code class=\"language-text\">-name .git</code> 就是搜索名称为 <code class=\"language-text\">.git</code> 的内容</li>\n<li><code class=\"language-text\">-type d</code> 则指明了我们搜索的范畴：Directories（目录）</li>\n</ul>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-214839.png\" alt=\"搜索 .git 文件夹\"><figcaption>搜索 .git 文件夹</figcaption></figure>\n<p>一目了然，我们下面就这样对每个命令进行分解和解释。</p>\n<h3 id=\"裁剪出我们要的-git-文件夹所在路径\"><a href=\"#%E8%A3%81%E5%89%AA%E5%87%BA%E6%88%91%E4%BB%AC%E8%A6%81%E7%9A%84-git-%E6%96%87%E4%BB%B6%E5%A4%B9%E6%89%80%E5%9C%A8%E8%B7%AF%E5%BE%84\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>裁剪出我们要的 <code class=\"language-text\">.git</code> 文件夹所在路径</h3>\n<p>上面我们解析出来的路径，每个路径后面都包含一个 <code class=\"language-text\">.git</code>，我们需要统一将这个 <code class=\"language-text\">.git</code> 从字符串中删掉，这样才能一起对给定目录执行 <code class=\"language-text\">git pull</code>。第二步我们进行目录的裁剪。</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token punctuation\">..</span>. <span class=\"token operator\">|</span> <span class=\"token function\">rev</span> <span class=\"token operator\">|</span> <span class=\"token function\">cut</span> <span class=\"token parameter variable\">-c</span> <span class=\"token number\">6</span>- <span class=\"token operator\">|</span> <span class=\"token function\">rev</span> <span class=\"token operator\">|</span> <span class=\"token punctuation\">..</span>.</code></pre>\n<p>可以发现，这里我们有三部分命令。我们依次对命令进行解析：</p>\n<ol>\n<li><code class=\"language-text\">rev</code>：首先对搜索到的目录（字符串）进行反转</li>\n<li><code class=\"language-text\">cut -c 6-</code>：我们利用 <code class=\"language-text\">cut</code> 工具将路径进行裁剪，<code class=\"language-text\">-c</code> 表示删减的是字符（Characters），<code class=\"language-text\">6-</code> 表示我们删去路径的前 6 个字符（即：<code class=\"language-text\">.git</code>）</li>\n<li><code class=\"language-text\">rev</code>：将处理好的字符串反转回来</li>\n</ol>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-214839-1.png\" alt=\"裁剪路径\"><figcaption>裁剪路径</figcaption></figure>\n<h3 id=\"利用-xargs-执行带参数的-git-pull\"><a href=\"#%E5%88%A9%E7%94%A8-xargs-%E6%89%A7%E8%A1%8C%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84-git-pull\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>利用 <code class=\"language-text\">xargs</code> 执行带参数的 <code class=\"language-text\">git pull</code></h3>\n<p>上一步，我们已经提取出来所有包含 <code class=\"language-text\">.git</code> 的文件夹，现在我们需要批量的执行 <code class=\"language-text\">git pull</code> 来统一拉取仓库。</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">xargs</span> <span class=\"token parameter variable\">-I</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> <span class=\"token function\">git</span> <span class=\"token parameter variable\">-C</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span> pull</code></pre>\n<p>由于 <code class=\"language-text\">git</code> 并不支持传入目录等参数，因此我们需要借助于 <code class=\"language-text\">xargs</code> 来给 <code class=\"language-text\">git</code> 传入拉取路径。上面的命令简明易懂，就相当于 <code class=\"language-text\">xargs</code> 告诉 <code class=\"language-text\">git</code> 拉取以上目录下的全部 Git 仓库。我们来看一看效果：</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-214839-2.gif\" alt=\"脚本效果\"><figcaption>脚本效果</figcaption></figure>\n<p>b(￣▽￣)d 👍 成功~</p>\n<h2 id=\"-references\"><a href=\"#-references\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>📚 References</h2>\n<ul>\n<li><a href=\"https://medium.com/@codenameyau/updating-multiple-repos-with-one-command-9768c8cdfe46\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Updating Multiple Repos With One Command</a></li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2019/08/xargs-tutorial.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">xargs 命令教程</a></li>\n</ul>\n"}}]}}},"context":{}}