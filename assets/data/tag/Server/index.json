{"hash":"1a485f6dceb298c3ce36b831edab4aa62783906c","data":{"tag":{"title":"Server","belongsTo":{"edges":[{"node":{"title":"Hit count：用 Google Analytics + Vercel Serverless 为文章添加浏览量统计","path":"/2020/06/serverless-ga-hit-count-api/","date":"June 25. 2020","timeToRead":10,"cjkWordCount":2571,"cjkReadTime":12,"description":"借助 Google Analytics 为数据支撑，使用 Vercel Serverless 为静态博客添加文章阅读数量统计 API。","content":"<div class=\"admonition admonition-note\"><div class=\"admonition-heading\"><h5><div class=\"admonition-icon\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"14\" height=\"16\" viewBox=\"0 0 14 16\"><path fill-rule=\"evenodd\" d=\"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z\"></path></svg></div>🍍 编者按</h5></div><div class=\"admonition-content\"><p>本文灵感和部分方法极大程度来源于 @printempw 的文章：<a href=\"https://printempw.github.io/google-analytics-api-page-views-counter/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">使用 Google Analytics API 实现博客阅读量统计</a>，感谢。(　o=^•ェ•)o</p></div></div>\n<p>静态网站是没有后端服务的，仅有一个前端页面用来渲染网站的全部内容。虽然从部署、管理和访问速度的角度来说，静态网站还是有点优势的，但是没有后端就意味着没有「评论系统」、「浏览量统计」、「登录鉴权」等等功能。如果想要实现这些功能，就必须依赖第三方的服务，才能实现类似的需要。许多同学都像我一样：在自己的博客网站里使用 Google Analytics 用来统计访问量和阅读数，因此对于「浏览量统计」这个功能来说，我们其实可以借助 Google Analytics API 来将我们在管理后台看到的部分数据显示在网站前端里面，从而实现「文章访问、阅读数量」显示的功能。</p>\n<h2 id=\"工作原理\"><a href=\"#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>工作原理</h2>\n<p>Google Analytics 非常强大，能够从非常多的维度来解读你网站的访客来源、浏览量、浏览设备等多种数据。这里当我们进入 Google Analytics 管理后台，在首页我们就可以看到我们网站每个路径在特定时间段之中的浏览数量。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-213128.png\" alt=\"Google Analytics 管理后台中我的博客上周 7 天的每个路径浏览数\"><figcaption>Google Analytics 管理后台中我的博客上周 7 天的每个路径浏览数</figcaption></figure>\n<p>实际上我们需要的就是这个数据。幸好，Google Analytics 提供了类似的 API，可以让我们根据页面路径、时间起止等参数来查询浏览数量。不过 Google Analytics 的原始 API 其实还是比较复杂的，而且其本身在国内访问还是不太顺畅，所以为了减轻我们静态网站前端的负担，<strong>我们可以在 Vercel 上面用 Serverless 方案部署一个 API 中转站</strong>，方便我们静态网站调用，从而实现「文章浏览量显示」的功能。</p>\n<h2 id=\"开启-google-analytics-api\"><a href=\"#%E5%BC%80%E5%90%AF-google-analytics-api\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>开启 Google Analytics API</h2>\n<p>我们在 Google Analytics 中调用自己网站的分析数据时，需要首先开启 Google Analytics API，获取到鉴权密钥，才可以正常调用 API。我们可以根据 Google 官方教程：<a href=\"https://developers.google.com/analytics/devguides/reporting/core/v4/quickstart/service-py#1_enable_the_api\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Analytics Reporting API v4 - Enable the API</a>，或按照下面的办法来开启我们账户的 Google Analytics API：</p>\n<ul>\n<li>首先，前往官方 API 的 <a href=\"https://console.developers.google.com/start/api?id=analyticsreporting.googleapis.com&#x26;credential=client_key\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">setup tools</a> 并根据提示进行设置，选择一个项目（或创建新的项目，比如 <code class=\"language-text\">ga-hit-count</code>），之后选择 Continue，就可以为我们这一项目开启 Google API 了；\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-213128-1.png\" alt=\"为我们的项目开启 Google API\"><figcaption>为我们的项目开启 Google API</figcaption></figure></li>\n<li>接下来，我们会进入 Google API 的 Credentials 设置页面，这里我们首先设置 API 为 Analytics Reporting API，并选择 API 调用方为 Web server，再选择调用数据类型为 Application data，最后选择「不会使用 App Engine 或 Compute Engine」即可；\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-213128-2.png\" alt=\"设置 Google API 类型\"><figcaption>设置 Google API 类型</figcaption></figure></li>\n<li>最后，我们设置基本信息，获取 Credentials 文件。我们设置 Service account name 的名字（比如 <code class=\"language-text\">blog-analytics</code>），设置 Role 为 <code class=\"language-text\">Service Account User</code>，选择 Key type 为 JSON，即可获取 API 凭证，点击 Continue 之后你就可以下载到这一 JSON 格式的 API 凭证文件了。 <figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-213128-3.png\" alt=\"设置 API 凭证信息\"><figcaption>设置 API 凭证信息</figcaption></figure></li>\n</ul>\n<p>我们获取到的 JSON 文件里面应该包含有以下的重要信息：</p>\n<pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n  <span class=\"token property\">\"project_id\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"ga-hit-count\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"private_key\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"-----BEGIN PRIVATE KEY-----\\nxxx-----END PRIVATE KEY-----\\n\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"client_email\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"blog-hit-count@ga-hit-count.iam.gserviceaccount.com\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>其中，我们重点关注的就是这三个 API 凭证信息：项目 ID <code class=\"language-text\">project_id</code>、凭证私钥 <code class=\"language-text\">private_key</code> 以及客户邮箱 <code class=\"language-text\">client_email</code>。其中 <code class=\"language-text\">private_key</code> 是我们 API 访问的重要凭证，需要妥善保管，也一定不能签入 <code class=\"language-text\">git</code>。另外，我们需要将 <code class=\"language-text\">client_email</code> 定义的邮箱<strong>作为新用户加入 Google Analytics 后台</strong>，从而让这一邮箱访问到我们 Google Analytics 的数据。详见：<a href=\"https://support.google.com/analytics/answer/1009702\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Add, edit, and delete users and user groups</a>。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-213128-4.png\" alt=\"将 client_email 的邮箱加入 Google Analytics 后台\"><figcaption>将 client_email 的邮箱加入 Google Analytics 后台</figcaption></figure>\n<h2 id=\"使用-vercel-自己部署-serverless-api-用于前端显示\"><a href=\"#%E4%BD%BF%E7%94%A8-vercel-%E8%87%AA%E5%B7%B1%E9%83%A8%E7%BD%B2-serverless-api-%E7%94%A8%E4%BA%8E%E5%89%8D%E7%AB%AF%E6%98%BE%E7%A4%BA\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>使用 Vercel 自己部署 Serverless API 用于前端显示</h2>\n<p>最后，我们就可以借助 Google Analytics API 在 Vercel 上部署中转 API 用于前端静态网站的调用。这里我使用 Node.js 和 Typescript 写好了一个非常简单的基础 Serverless API 项目，位于：<a href=\"https://github.com/spencerwooo/ga-hit-count-serverless\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">spencerwooo/ga-hit-count-serverless</a>，同学们可以直接 Fork 我的这一项目用来自己部署。其中，如果自己没有特殊需要，那么 Fork 项目之后我们仅需要修改 <code class=\"language-text\">api/config.ts</code> 里面的配置即可导入 Vercel 一键部署。</p>\n<h3 id=\"修改-ga-hit-count-serverless-的配置\"><a href=\"#%E4%BF%AE%E6%94%B9-ga-hit-count-serverless-%E7%9A%84%E9%85%8D%E7%BD%AE\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>修改 <code class=\"language-text\">ga-hit-count-serverless</code> 的配置</h3>\n<p>同学们将这一项目 Fork 至自己的 GitHub 账户上后，进入 <code class=\"language-text\">api/config.ts</code> 即可看到我自己的 API 配置，大致如下：</p>\n<pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token punctuation\">{</span>\n  viewId<span class=\"token operator\">:</span> <span class=\"token string\">'{Google Analytics view ID}'</span><span class=\"token punctuation\">,</span>\n  auth<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    projectId<span class=\"token operator\">:</span> <span class=\"token string\">'{Google API project ID}'</span><span class=\"token punctuation\">,</span>\n    privateKey<span class=\"token operator\">:</span> process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span><span class=\"token constant\">PRIVATE_KEY</span><span class=\"token punctuation\">,</span>\n    clientEmail<span class=\"token operator\">:</span> <span class=\"token string\">'{Google API client email}'</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  allFilter<span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'{Post path filter}'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  startDate<span class=\"token operator\">:</span> <span class=\"token string\">'{Google API query start date}'</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>其中，这些内容我们都需要一一进行设置：</p>\n<ul>\n<li><code class=\"language-text\">viewId</code>：是你的 Google Analytics 视图 ID，可以在 Google Analytics 后台的 Admin » View » View Settings 中找到；\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-213128-5.png\" alt=\"Google Analytics 视图 ID 的设定位置\"><figcaption>Google Analytics 视图 ID 的设定位置</figcaption></figure></li>\n<li><code class=\"language-text\">projectId</code>：是刚刚凭证 JSON 文件中的 <code class=\"language-text\">project_id</code>，直接按照刚刚的凭证填写即可；</li>\n<li><code class=\"language-text\">privateKey</code>：是通过 Vercel 环境变量获取到的 API 凭证私钥，<strong>这里不要更改</strong>；</li>\n<li><code class=\"language-text\">clientEmail</code>：是刚刚凭证 JSON 文件中的 <code class=\"language-text\">client_email</code>，直接按照刚刚的凭证填写即可；</li>\n<li><code class=\"language-text\">allFilter</code>：是通过 Google API 查询时的前缀过滤器，比如你的网站中文章路径以 <code class=\"language-text\">/post</code> 开头，那么就可以设置为 <code class=\"language-text\">[&#39;/post&#39;]</code>。默认为 <code class=\"language-text\">[&#39;/20&#39;]</code>（因为我的文章路径是以 <code class=\"language-text\">/2020</code> 或 <code class=\"language-text\">/2019</code> 开头的）；</li>\n<li><code class=\"language-text\">startDate</code>：是通过 Google API 查询时设定时间段的开始时间，设定一个比较久远的时间即可，默认为 <code class=\"language-text\">2010-01-01</code>。</li>\n</ul>\n<div class=\"admonition admonition-warning\"><div class=\"admonition-heading\"><h5><div class=\"admonition-icon\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"12\" height=\"16\" viewBox=\"0 0 12 16\"><path fill-rule=\"evenodd\" d=\"M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z\"></path></svg></div>🚨 请注意！</h5></div><div class=\"admonition-content\"><p>这里千万千万不要直接将刚刚凭证中获取到的私钥直接粘贴进入 <code class=\"language-text\">privateKey</code> 一项之中，因为这样当我们将 <code class=\"language-text\">config.ts</code> 签入 <code class=\"language-text\">git</code> 之后，<code class=\"language-text\">privateKey</code> 将以明文形式保存，非常危险。</p></div></div>\n<h3 id=\"将项目导入-vercel\"><a href=\"#%E5%B0%86%E9%A1%B9%E7%9B%AE%E5%AF%BC%E5%85%A5-vercel\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>将项目导入 Vercel</h3>\n<p>Vercel（曾经的 ZEIT Now）是一个专注于部署 Jamstack 静态网页和 Serverless API 的服务，其官网位于 <a href=\"https://vercel.com/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Develop. Preview. Ship. - Vercel</a>。我们使用 GitHub 注册登录 Vercel 之后，仅需将刚刚 Fork 并修改好配置文件版本的 <code class=\"language-text\">ga-hit-count-serverless</code> 导入 Vercel 即可。Vercel 会自动的识别我们项目的环境，生成合适的编译、部署命令，自动将我们的 API 部署到 Vercel 的全球 CDN 上面，方便全世界随时随地的访问。</p>\n<p>但是此时我们并不能正常的使用我们自己部署的 API，因为 <code class=\"language-text\">privateKey</code> 尚未设置。我们需要进入刚刚在 Vercel 上部署好的项目设置中，选择 General » Environment Variables，向其中新增一个环境变量 <code class=\"language-text\">PRIVATE_KEY</code>。之后，我们将刚刚的 Google API JSON 凭证文件里面的私钥，<strong>复制其中的字符串部分，将 <code class=\"language-text\">\\n</code> 全部删掉并更换为换行</strong>，得到类似如下的多行私钥形式：</p>\n<pre class=\"language-text\"><code class=\"language-text\">-----BEGIN PRIVATE KEY-----\ndageWvAIBADANBAokdP8WgkqhkiGkk\n...\nafROdsafbliOjPA==1Hk3mdsafEdBa\n-----END PRIVATE KEY-----</code></pre>\n<p>我们复制这一私钥，再粘贴进入刚刚新建的 <code class=\"language-text\">PRIVATE_KEY</code> 的值。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-213128-6.png\" alt=\"在 Vercel 项目的设置中添加环境变量 PRIVATE_KEY，并存入我们的私钥凭证\"><figcaption>在 Vercel 项目的设置中添加环境变量 PRIVATE_KEY，并存入我们的私钥凭证</figcaption></figure>\n<p>之后，我们需要重新触发一次部署（比如随便向 GitHub 仓库中 commit 并 push 一些东西），完成后我们即可通过 Vercel 给我们提供的域名 <code class=\"language-text\">https://{VERCEL_DOMAIN_NAME}.vercel.app</code> 访问我们的 API。</p>\n<h3 id=\"使用-vercel-serverless-版-api\"><a href=\"#%E4%BD%BF%E7%94%A8-vercel-serverless-%E7%89%88-api\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>使用 Vercel Serverless 版 API</h3>\n<p>默认情况下，当我们直接访问 <code class=\"language-text\">https://{VERCEL_DOMAIN_NAME}.vercel.app</code> 时，因为没有设定 <code class=\"language-text\">index.html</code>，所以 Vercel 会将当前列表下的文件列出。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-213128-7.png\" alt=\"默认情况下直接访问 Vercel 上部署的 Serverless API 域名\"><figcaption>默认情况下直接访问 Vercel 上部署的 Serverless API 域名</figcaption></figure>\n<p>我们 API 的根域名实际上就是 <code class=\"language-text\">https://{VERCEL_DOMAIN_NAME}.vercel.app</code>。我们可以通过下面的默认请求（添加在 API 根域名后面）来访问 API：</p>\n<pre class=\"language-text\"><code class=\"language-text\">/api/ga</code></pre>\n<p>没有添加任何参数的情况下，默认这一 API 会将你的 Google Analytics 里面全部路径与访问量拉取并给出。以我自己博客为例，访问这一 API 会得到类似下面的 JSON response：</p>\n<pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">[</span>\n  <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"page\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"/2019/11/tiny-tiny-rss/\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"hit\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"698\"</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"page\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"/2019/11/weibo-to-twitter/\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"hit\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"531\"</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"page\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"/2020/03/ttrss-noteworthy/\"</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"hit\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"357\"</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">]</span></code></pre>\n<p>其中，我们可以看到返回的 response 中包含有我们网站中所有路径的 <code class=\"language-text\">hit</code> 阅读量数据，并且数据是按照阅读量递减来排列的。</p>\n<p>当我们需要直接请求网站中某一页面或某个特定路径的数据时，我们可以用这样的语法构造我们的请求：</p>\n<pre class=\"language-text\"><code class=\"language-text\">/api/ga?page={WEBSITE_PAGE_PATH}</code></pre>\n<p>其中请求的 field 为 <code class=\"language-text\">page</code>，参数为目标路径。比如这样的请求：</p>\n<pre class=\"language-text\"><code class=\"language-text\">/api/ga?page=/2020/03/substats/</code></pre>\n<p>将直接返回路径 <code class=\"language-text\">/2020/03/substats/</code> 的阅读量：</p>\n<pre class=\"language-text\"><code class=\"language-text\">[\n  {\n    &quot;page&quot;: &quot;/2020/03/substats/&quot;,\n    &quot;hit&quot;: &quot;311&quot;\n  }\n]</code></pre>\n<p>那么在此基础上，我们即可借助自己在 Vercel 上面部署的 API，来请求 Google Analytics 给我们当前路径的浏览量记录了。利用 <code class=\"language-text\">axios</code> 或者类似的前端 HTTP 请求库，我们可以非常轻松的请求我们部署的 Serverless API，并将结果进行处理，显示在我们的网站里面。你正在浏览的我的博客，就是利用这样的原理实现访问数据的显示。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-213128-8.png\" alt=\"用这样的方法在我自己博客上面显示文章的浏览量\"><figcaption>用这样的方法在我自己博客上面显示文章的浏览量</figcaption></figure>\n<p>到此，我们借助 Google Analytics 和 Vercel Serverless 为文章添加浏览量统计的功能就大功告成了。希望大家能用上本文的办法，为自己的静态博客网站快速添加上文章阅读量统计。感谢阅读 🍒</p>\n"}},{"node":{"title":"Substats：快速统计你在各个平台的关注者！","path":"/2020/03/substats/","date":"March 16. 2020","timeToRead":8,"cjkWordCount":1795,"cjkReadTime":8,"description":"Subscriber statistics：专注提供各个网站和社区里用户的订阅者、关注者、粉丝数量的 Serverless API","content":"<div class=\"admonition admonition-important\"><div class=\"admonition-heading\"><h5><div class=\"admonition-icon\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"14\" height=\"16\" viewBox=\"0 0 14 16\"><path fill-rule=\"evenodd\" d=\"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z\"></path></svg></div>SUBSTATS</h5></div><div class=\"admonition-content\"><p>Serverless Function to Count How Many People are Subscribed to You in Your Favorite Services.\n<strong>你只管调用，我们来帮你找订阅者！</strong></p></div></div>\n<p>在 <a href=\"https://blog.spencerwoo.com/2020/03/ttrss-noteworthy/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">上一篇文章</a> 里面，我在开头用 Feedly 的 API 和 Shields.io 制作了显示我 RSS 订阅数量的 Badge。这个 Badge 不仅是实时更新、动态加载的，还能轻松嵌入各个网页里面。</p>\n<p><a href=\"https://feedly.com/i/subscription/feed%2Fhttps%3A%2F%2Fblog.spencerwoo.com%2Fposts%2Findex.xml\"><img src=\"https://img.shields.io/badge/dynamic/json?color=2bb24c&amp;label=subscribers&amp;query=%24.source.subscribers&amp;url=https%3A%2F%2Ffeedly.com%2Fv3%2Frecommendations%2Ffeeds%2Ffeed%252Fhttps%253A%252F%252Fblog.spencerwoo.com%252Fposts%252Findex.xml&amp;logo=feedly&style=for-the-badge\" alt=\"\" style=\"display: inline; margin: 0 0.1rem 0 0; width: auto;\"></a></p>\n<p>但是，RSS 订阅服务不仅仅有 Feedly 一家，还有 Inoreader 和 NewsBlur 等等。单一个 Feedly 提供的数据并不能真正显示我们 RSS 链接的订阅人数，于是，我就准备用 Serverless 技术搭建一个「API 中转站」，<strong>提供多个服务商的订阅人数整合的工作。</strong></p>\n<p>其实，最初的 Substats 实际上叫做 RSS-stats，也就是集合多个 RSS 服务商提供的订阅人数数据得到的一个 API 服务。但是后来经过我一番思考，既然都是调用 API，那么为什么不把其他的平台和服务，比如微博粉丝、知乎、少数派、以及 GitHub 和 Twitter 的关注者等等，一起支持一下呢？💡 可行！于是 Substats 就这样诞生啦。(≧∇≦)ﾉ</p>\n<div class=\"admonition admonition-tip\"><div class=\"admonition-heading\"><h5><div class=\"admonition-icon\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"12\" height=\"16\" viewBox=\"0 0 12 16\"><path fill-rule=\"evenodd\" d=\"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z\"></path></svg></div>相关链接</h5></div><div class=\"admonition-content\"><ul>\n<li><strong>Substats API 地址</strong>：<a href=\"https://api.spencerwoo.com/substats/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">API - Substats</a></li>\n<li><strong>Substats GitHub 项目地址</strong>：<a href=\"https://github.com/spencerwooo/Substats\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">spencerwooo/Substats</a></li>\n</ul></div></div>\n<h2 id=\"功能特性\"><a href=\"#%E5%8A%9F%E8%83%BD%E7%89%B9%E6%80%A7\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>功能特性</h2>\n<p>Substats 是一个非常方便易用的<strong>请求订阅者、粉丝、关注用户数量 API 服务</strong>。目前，Substats 平台支持了包括 Feedly、GitHub、Twitter、知乎和少数派在内的五个平台和网站，并使用 Serverless 技术部署到了 Cloudflare 的 CDN 上，全球部署，飞速响应。Substats 将复杂的原平台 API 请求进行了隐藏、简化和集成，让用 Substats 的你只需要关注<strong>两个参数：平台名称、用户名称</strong>，一波访问，即可得到对应的关注数量。</p>\n<p>得益于强大的 Cloudflare 全球 CDN 网络，Substats 不仅部署方便、维护轻松，<strong>还有着极强的可拓展性、极快的访问速度和极小的请求时延</strong>。甚至在你懂得的地方，你都可以轻松访问到 Twitter 的粉丝数量！🥂</p>\n<h3 id=\"api-endpoint\"><a href=\"#api-endpoint\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>API Endpoint</h3>\n<p>Substats 的请求非常简单，基础 API Endpoint 位于：</p>\n<pre class=\"language-text\"><code class=\"language-text\">https://api.spencerwoo.com/substats/</code></pre>\n<p>接下来，我们只需要关注前文提到的平台名 <code class=\"language-text\">source</code> 和用户名称（或 RSS 链接、用户 slug 等标识）<code class=\"language-text\">queryKey</code> 即可构造一个基本的请求。为了更好的和 Shields.io 整合，Substats 仅支持 <code class=\"language-text\">GET</code> 请求，并使用查询字符串（Query String）来添加请求参数。</p>\n<h3 id=\"基础请求\"><a href=\"#%E5%9F%BA%E7%A1%80%E8%AF%B7%E6%B1%82\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>基础请求</h3>\n<p>一个最基础的请求参数类似：</p>\n<pre class=\"language-http\"><code class=\"language-http\">GET /?source={SOURCE}&amp;queryKey={QUERY}</code></pre>\n<p>其中，我们只需要填入平台名称 <code class=\"language-text\">{SOURCE}</code> 和请求参数 <code class=\"language-text\">{QUERY}</code> 即可。</p>\n<h3 id=\"平台串联请求\"><a href=\"#%E5%B9%B3%E5%8F%B0%E4%B8%B2%E8%81%94%E8%AF%B7%E6%B1%82\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>平台串联请求</h3>\n<p>我们可以用下面的语法构建单个请求 query 并列请求多个平台的 API，只需要将平台之间用 <code class=\"language-text\">|</code> 分隔即可：</p>\n<pre class=\"language-http\"><code class=\"language-http\">GET /?source={SOURCE_1}|{SOURCE_2}|{SOURCE_3}&amp;queryKey={QUERY}</code></pre>\n<p>其中，这一请求格式特别适合 RSS 订阅的请求，比如当我们想统计同一个 RSS 链接在 Feedly、Inoreader 以及 NewsBlur 三个平台的订阅者数量，即可使用这一语法进行 API 请求。（详见下文例子）</p>\n<h3 id=\"多个平台和用户名的串联请求\"><a href=\"#%E5%A4%9A%E4%B8%AA%E5%B9%B3%E5%8F%B0%E5%92%8C%E7%94%A8%E6%88%B7%E5%90%8D%E7%9A%84%E4%B8%B2%E8%81%94%E8%AF%B7%E6%B1%82\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>多个平台和用户名的串联请求</h3>\n<pre class=\"language-http\"><code class=\"language-http\">GET /?source={SOURCE}&amp;queryKey={QUERY}&amp;source={SOURCE}&amp;queryKey={QUERY} ....</code></pre>\n<p>如果我们每个平台的请求参数（也就是用户名）不一样，没关系，我们也可以用上面的语法组织各个 <code class=\"language-text\">[平台, 参数]</code> 二元组，依次请求，得到最终数据。在这一过程中，平台、参数的顺序在请求和内部 API 处理的过程中是完全一致的。（你也就不必担心请求的错位。）</p>\n<h2 id=\"一些例子\"><a href=\"#%E4%B8%80%E4%BA%9B%E4%BE%8B%E5%AD%90\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>一些例子</h2>\n<p>将 Substats 和 <a href=\"https://shields.io/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Shields.io</a> 配合起来，我们可以构造稳定可用的关注者数量实时显示 Badge，嵌入包括 GitHub README、博客文章等等网站的各个位置。我来举个栗子。🌰</p>\n<h3 id=\"单个请求\"><a href=\"#%E5%8D%95%E4%B8%AA%E8%AF%B7%E6%B1%82\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>单个请求</h3>\n<p>Substats 最初就是为了请求 RSS 订阅者数量，我们先来请求一波 Feedly 的订阅数量。我自己博客（也就是本博客）的 RSS 订阅链接是 <code class=\"language-text\">https://blog.spencerwoo.com/feed.xml</code>，那么，我们就可以用下面的 URL 构造请求：</p>\n<pre class=\"language-http\"><code class=\"language-http\">GET /?source=feedly&amp;queryKey=https://blog.spencerwoo.com/feed.xml</code></pre>\n<p>这一请求会返回如下的数据：</p>\n<pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"status\"</span><span class=\"token operator\">:</span> <span class=\"token number\">200</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"data\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"totalSubs\"</span><span class=\"token operator\">:</span> <span class=\"token number\">14</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"subsInEachSource\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token property\">\"feedly\"</span><span class=\"token operator\">:</span> <span class=\"token number\">14</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"failedSources\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>我们所需要的数据即位于：<code class=\"language-text\">data.totalSubs</code>。在 <a href=\"https://shields.io/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Shields.io</a> 官网，我们即可借助 Dynamic Badge 构建一个自定义的 Badge：</p>\n<ul>\n<li><code class=\"language-text\">data type</code> 选择：<code class=\"language-text\">json</code></li>\n<li><code class=\"language-text\">label</code> 填入：Feedly RSS Subscribes</li>\n<li><code class=\"language-text\">data url</code> 填入：<code class=\"language-text\">https://api.spencerwoo.com/substats/?source=feedly&amp;queryKey=https://blog.spencerwoo.com/feed.xml</code></li>\n<li><code class=\"language-text\">query</code> 填入：<code class=\"language-text\">$.data.totalSubs</code></li>\n<li><code class=\"language-text\">color</code> 填入：<code class=\"language-text\">2bb24c</code>（Feedly 的强调色）</li>\n</ul>\n<p>点击 Make badge，即可生成如下的 Feedly RSS 订阅 Badge：</p>\n<p><a href=\"https://feedly.com/i/subscription/feed%2Fhttps%3A%2F%2Fblog.spencerwoo.com%2Fposts%2Findex.xml\"><img src=\"https://img.shields.io/badge/dynamic/json?color=2bb24c&label=Feedly%20RSS%20Subscribes&query=%24.data.totalSubs&url=https%3A%2F%2Fapi.spencerwoo.com%2Fsubstats%2F%3Fsource%3Dfeedly%26queryKey%3Dhttps%3A%2F%2Fblog.spencerwoo.com%2Fposts%2Findex.xml\" alt=\"\" style=\"display: inline; margin: 0 0.1rem 0 0; width: auto;\"></a></p>\n<pre class=\"language-text\"><code class=\"language-text\">https://img.shields.io/badge/dynamic/json?color=2bb24c&amp;label=Feedly%20RSS%20Subscribes&amp;query=%24.data.totalSubs&amp;url=https%3A%2F%2Fapi.spencerwoo.com%2Fsubstats%2F%3Fsource%3Dfeedly%26queryKey%3Dhttps%3A%2F%2Fblog.spencerwoo.com%2Fposts%2Findex.xml</code></pre>\n<p>在这一请求链接的结尾，再手动添加上 Feedly 的 logo 请求参数 <code class=\"language-text\">&amp;logo=feedly</code>，即可将 Badge 添加上图标：</p>\n<p><a href=\"https://feedly.com/i/subscription/feed%2Fhttps%3A%2F%2Fblog.spencerwoo.com%2Fposts%2Findex.xml\"><img src=\"https://img.shields.io/badge/dynamic/json?color=2bb24c&label=Feedly%20RSS%20Subscribes&query=%24.data.totalSubs&url=https%3A%2F%2Fapi.spencerwoo.com%2Fsubstats%2F%3Fsource%3Dfeedly%26queryKey%3Dhttps%3A%2F%2Fblog.spencerwoo.com%2Fposts%2Findex.xml&logo=feedly\" alt=\"\" style=\"display: inline; margin: 0 0.1rem 0 0; width: auto;\"></a></p>\n<pre class=\"language-text\"><code class=\"language-text\">https://img.shields.io/badge/dynamic/json?color=2bb24c&amp;label=Feedly%20RSS%20Subscribes&amp;query=%24.data.totalSubs&amp;url=https%3A%2F%2Fapi.spencerwoo.com%2Fsubstats%2F%3Fsource%3Dfeedly%26queryKey%3Dhttps%3A%2F%2Fblog.spencerwoo.com%2Fposts%2Findex.xml&amp;logo=feedly</code></pre>\n<p>另外，我们还可以指定生成超大 For The Badge 风格的 Badge，在上面请求末尾再手动添加参数 <code class=\"language-text\">&amp;style=for-the-badge</code> 即可：</p>\n<p><a href=\"https://feedly.com/i/subscription/feed%2Fhttps%3A%2F%2Fblog.spencerwoo.com%2Fposts%2Findex.xml\"><img src=\"https://img.shields.io/badge/dynamic/json?color=2bb24c&label=Feedly%20RSS%20Subscribes&query=%24.data.totalSubs&url=https%3A%2F%2Fapi.spencerwoo.com%2Fsubstats%2F%3Fsource%3Dfeedly%26queryKey%3Dhttps%3A%2F%2Fblog.spencerwoo.com%2Fposts%2Findex.xml&logo=feedly&style=for-the-badge\" alt=\"\" style=\"display: inline; margin: 0 0.1rem 0 0; width: auto;\"></a></p>\n<pre class=\"language-text\"><code class=\"language-text\">https://img.shields.io/badge/dynamic/json?color=2bb24c&amp;label=Feedly%20RSS%20Subscribes&amp;query=%24.data.totalSubs&amp;url=https%3A%2F%2Fapi.spencerwoo.com%2Fsubstats%2F%3Fsource%3Dfeedly%26queryKey%3Dhttps%3A%2F%2Fblog.spencerwoo.com%2Fposts%2Findex.xml&amp;logo=feedly&amp;style=for-the-badge</code></pre>\n<h3 id=\"多个平台串联请求\"><a href=\"#%E5%A4%9A%E4%B8%AA%E5%B9%B3%E5%8F%B0%E4%B8%B2%E8%81%94%E8%AF%B7%E6%B1%82\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>多个平台串联请求</h3>\n<p>当然，我们可以用 <code class=\"language-text\">|</code> 串联多个请求，比如我同时请求 Feedly、Inoreader 中订阅我 RSS 链接的用户数量：</p>\n<pre class=\"language-http\"><code class=\"language-http\">GET /?source=feedly|inoreader&amp;queryKey=https://blog.spencerwoo.com/feed.xml</code></pre>\n<p>我们会得到如下数据（截至发文 Inoreader 的 API 尚未实现，我正在咨询 Inoreader 平台方是否提供 API 接口）：</p>\n<pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"status\"</span><span class=\"token operator\">:</span> <span class=\"token number\">200</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"data\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"totalSubs\"</span><span class=\"token operator\">:</span> <span class=\"token number\">14</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"subsInEachSource\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token property\">\"feedly\"</span><span class=\"token operator\">:</span> <span class=\"token number\">14</span><span class=\"token punctuation\">,</span> <span class=\"token property\">\"inoreader\"</span><span class=\"token operator\">:</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"failedSources\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token property\">\"inoreader\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"Not implemented\"</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p><a href=\"https://feedly.com/i/subscription/feed%2Fhttps%3A%2F%2Fblog.spencerwoo.com%2Fposts%2Findex.xml\"><img src=\"https://img.shields.io/badge/dynamic/json?label=RSS%20subs&query=%24.data.totalSubs&url=https%3A%2F%2Fapi.spencerwoo.com%2Fsubstats%2F%3Fsource%3Dfeedly%257Cinoreader%26queryKey%3Dhttps%3A%2F%2Fblog.spencerwoo.com%2Fposts%2Findex.xml&color=ffa500&logo=rss&style=for-the-badge\" alt=\"\" style=\"display: inline; margin: 0 0.1rem 0 0; width: auto;\"></a></p>\n<h3 id=\"多平台多请求参数串联请求\"><a href=\"#%E5%A4%9A%E5%B9%B3%E5%8F%B0%E5%A4%9A%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E4%B8%B2%E8%81%94%E8%AF%B7%E6%B1%82\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>多平台多请求参数串联请求</h3>\n<p>当每个平台的请求参数（用户名）不一样时，我们可以串联多个请求参数并行请求，比如我希望统计「少数派」平台和「Twitter」平台的粉丝，但是我在这两个平台上面的用户名分别是 <code class=\"language-text\">spencerwoo</code> 和 <code class=\"language-text\">realSpencerWoo</code>，我们即可用下面的方法构造请求：</p>\n<pre class=\"language-http\"><code class=\"language-http\">GET /?source=sspai&amp;queryKey=spencerwoo&amp;source=twitter&amp;queryKey=realSpencerWoo</code></pre>\n<p>我们会得到如下数据：</p>\n<pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"status\"</span><span class=\"token operator\">:</span> <span class=\"token number\">200</span><span class=\"token punctuation\">,</span>\n  <span class=\"token property\">\"data\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"totalSubs\"</span><span class=\"token operator\">:</span> <span class=\"token number\">756</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"subsInEachSource\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span> <span class=\"token property\">\"sspai\"</span><span class=\"token operator\">:</span> <span class=\"token number\">636</span><span class=\"token punctuation\">,</span> <span class=\"token property\">\"twitter\"</span><span class=\"token operator\">:</span> <span class=\"token number\">120</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token property\">\"failedSources\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>这样，我们即可非常轻松的构造这样的三个 Badge：</p>\n<p><a href=\"https://api.spencerwoo.com/substats/?source=sspai&queryKey=spencerwoo&source=twitter&queryKey=realSpencerWoo\"><img src=\"https://img.shields.io/badge/dynamic/json?label=Social%20media&query=%24.data.totalSubs&url=https%3A%2F%2Fapi.spencerwoo.com%2Fsubstats%2F%3Fsource%3Dsspai%26queryKey%3Dspencerwoo%26source%3Dtwitter%26queryKey%3DrealSpencerWoo&color=brightgreen&style=for-the-badge\" alt=\"\" style=\"display: inline; margin: 0 0.1rem 0 0; width: auto;\"></a>\n<a href=\"https://api.spencerwoo.com/substats/?source=sspai&queryKey=spencerwoo&source=twitter&queryKey=realSpencerWoo\"><img src=\"https://img.shields.io/badge/dynamic/json?label=%E5%B0%91%E6%95%B0%E6%B4%BE&query=%24.data.subsInEachSource.sspai&url=https%3A%2F%2Fapi.spencerwoo.com%2Fsubstats%2F%3Fsource%3Dsspai%26queryKey%3Dspencerwoo%26source%3Dtwitter%26queryKey%3DrealSpencerWoo&color=d71a1b&style=for-the-badge\" alt=\"\" style=\"display: inline; margin: 0 0.1rem 0 0; width: auto;\"></a>\n<a href=\"https://api.spencerwoo.com/substats/?source=sspai&queryKey=spencerwoo&source=twitter&queryKey=realSpencerWoo\"><img src=\"https://img.shields.io/badge/dynamic/json?label=Twitter&query=%24.data.subsInEachSource.twitter&url=https%3A%2F%2Fapi.spencerwoo.com%2Fsubstats%2F%3Fsource%3Dsspai%26queryKey%3Dspencerwoo%26source%3Dtwitter%26queryKey%3DrealSpencerWoo&color=1da1f2&logo=twitter&style=for-the-badge\" alt=\"\" style=\"display: inline; margin: 0 0.1rem 0 0; width: auto;\"></a></p>\n<h2 id=\"小结\"><a href=\"#%E5%B0%8F%E7%BB%93\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>小结</h2>\n<p>这些就是 Substats 的特别之处，Substats 不仅整合了原服务复杂的 API，还拥有方便的请求构建方法。与 <a href=\"https://shields.io/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Shields.io</a> 配合，我们可以及其方便的构造自定义 Badge。虽然当前 Substats 支持的服务平台还比较少，但是整合其他服务 API 的方法还是相当方便的，欢迎同学们帮我来共同整合其他平台，一起将 Substats 发扬壮大 ( •̀ ω •́ )✧</p>\n<p><strong>最后，如果你觉得 Substats 非常棒，请不要吝啬你的 Star！你们的支持是我输出的最大动力 φ(*￣0￣)</strong></p>\n<p><a href=\"https://github.com/spencerwooo/Substats\"><img src=\"https://img.shields.io/github/stars/spencerwooo/Substats?logo=github&style=social\" alt=\"\" style=\"display: inline; margin: 0 0.1rem 0 0; width: auto;\"></a></p>\n"}},{"node":{"title":"Tiny Tiny RSS：部署中的普遍问题与注意事项总结","path":"/2020/03/ttrss-noteworthy/","date":"March 13. 2020","timeToRead":7,"cjkWordCount":1844,"cjkReadTime":9,"description":"Tiny Tiny RSS 部署踩坑","content":"<p>最近一直在折腾 Tiny Tiny RSS，包括升级、添加样式和持久化。由于我是直接使用了 Awesome TTRSS 项目提供的 <code class=\"language-text\">docker-compose.yml</code> 部署的 Docker 版本 Tiny Tiny RSS，所以一些经验还是具有普遍性、值得分享的。这里我总结一下我在部署 Tiny Tiny RSS 过程中遇到的一些「普遍问题」和「注意事项」。</p>\n<p>关于如何在自己的服务器上面部署 Tiny Tiny RSS：</p>\n<ul>\n<li><a href=\"https://blog.spencerwoo.com/2019/11/tiny-tiny-rss/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Tiny Tiny RSS | 最速部署私有 RSS 服务器</a>：我的博客</li>\n<li><a href=\"https://sspai.com/post/57498\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">找不到满意的 RSS 服务？你可以自己搭建一个</a>：我的少数派文章</li>\n</ul>\n<div class=\"admonition admonition-warning\"><div class=\"admonition-heading\"><h5><div class=\"admonition-icon\"><svg xmlns=\"http://www.w3.org/2000/svg\" width=\"12\" height=\"16\" viewBox=\"0 0 12 16\"><path fill-rule=\"evenodd\" d=\"M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z\"></path></svg></div>RSS 订阅</h5></div><div class=\"admonition-content\"><p>另外，订阅我博客 RSS 的同学（来自 Feedly 的数据）已经达到了惊人的 10 个！谢谢各位的关注，没有用 RSS 订阅的同学可以点击下方徽章直接在 Feedly 中订阅。🙇‍♂️</p><p><a href=\"https://blog.spencerwoo.com/feed.xml\"><img src=\"https://img.shields.io/badge/subscribe%20via-RSS-ffa500?logo=rss&style=for-the-badge\" alt=\"\" style=\"display: inline; margin: 0 0.1rem 0 0; width: auto;\"></a>\n<a href=\"https://feedly.com/i/subscription/feed%2Fhttps%3A%2F%2Fblog.spencerwoo.com%2Fposts%2Findex.xml\"><img src=\"https://img.shields.io/badge/dynamic/json?color=2bb24c&amp;label=subscribers&amp;query=%24.source.subscribers&amp;url=https%3A%2F%2Ffeedly.com%2Fv3%2Frecommendations%2Ffeeds%2Ffeed%252Fhttps%253A%252F%252Fblog.spencerwoo.com%252Fposts%252Findex.xml&amp;logo=feedly&style=for-the-badge\" alt=\"\" style=\"display: inline; margin: 0 0.1rem 0 0; width: auto;\"></a></p></div></div>\n<h2 id=\"如何直接更新最新版本的-tiny-tiny-rss\"><a href=\"#%E5%A6%82%E4%BD%95%E7%9B%B4%E6%8E%A5%E6%9B%B4%E6%96%B0%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84-tiny-tiny-rss\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>如何直接更新最新版本的 Tiny Tiny RSS</h2>\n<p>首先明确一下，更新 Awesome TTRSS 至最新版时，实际上更新了全部组件，包括 Tiny Tiny RSS 本体、主题、插件等等。比如这次更新（2020 年 2 月更新）就将 <a href=\"https://github.com/levito/tt-rss-feedly-theme\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Feedly 主题</a> 最新的更新中加入的 <code class=\"language-text\">feedly-cozy.css</code>、<code class=\"language-text\">feedly-sepia.css</code> 等等主题全部加入了。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220455.png\" alt=\"更新之后加入的最新的 Feedly 主题\"><figcaption>更新之后加入的最新的 Feedly 主题</figcaption></figure>\n<p>我推荐大家手动执行更新。更新 Tiny Tiny RSS 本体：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> pull wangqiru/ttrss:latest</code></pre>\n<p>更新 Mercury 和 OpenCC 服务：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker</span> pull wangqiru/mercury-parser-api:latest\n<span class=\"token function\">docker</span> pull wangqiru/opencc-api-server:latest</code></pre>\n<p>之后，重启 Tiny Tiny RSS 服务即可：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker-compose</span> up <span class=\"token parameter variable\">-d</span></code></pre>\n<p>Awesome TTRSS 项目中提供了 Watch Tower 项目，但是我并不推荐大家通过这一工具进行自动更新，因为 Watch Tower 会将你的全部 Docker 容器更新，可能会导致其他环境的不兼容。</p>\n<h2 id=\"如何在编辑-docker-compose-文件之后重启-tiny-tiny-rss\"><a href=\"#%E5%A6%82%E4%BD%95%E5%9C%A8%E7%BC%96%E8%BE%91-docker-compose-%E6%96%87%E4%BB%B6%E4%B9%8B%E5%90%8E%E9%87%8D%E5%90%AF-tiny-tiny-rss\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>如何在编辑 docker-compose 文件之后重启 Tiny Tiny RSS</h2>\n<p>无论是重新配置了何种环境，是重新映射的 Volume 还是添加了 <code class=\"language-text\">docker-compose.yml</code> 设置，我都推荐直接用这一命令重启 Tiny Tiny RSS 服务：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker-compose</span> up <span class=\"token parameter variable\">-d</span></code></pre>\n<p>如果你先运行停止 Docker 容器（<code class=\"language-text\">docker-compose down</code>、<code class=\"language-text\">docker-compose rm</code>）的命令，我都遇到过数据库丢失的情况，因此只要没有特殊需要，<strong>我们都可以只使用上面的命令重启 Tiny Tiny RSS 服务。</strong></p>\n<h2 id=\"如何正确的配置-fever-emulation-api\"><a href=\"#%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E9%85%8D%E7%BD%AE-fever-emulation-api\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>如何正确的配置 Fever Emulation API</h2>\n<p>通常，为了适配第三方 RSS 阅读器比如 Reeder，我们需要使用 Fever Emulation API 进行「登录」。首先我们必须开启 Tiny Tiny RSS 外部 API 访问的权限。在 Preference » General » Enable API 处开启：</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220455-1.png\" alt=\"设置允许通过外部 API 访问 Tiny Tiny RSS\"><figcaption>设置允许通过外部 API 访问 Tiny Tiny RSS</figcaption></figure>\n<p>Fever Emulation 的 API 包含有三个部分：</p>\n<ul>\n<li>你的 Fever API 地址（通常是你的服务器域名 + <code class=\"language-text\">/plugins/fever/</code>）</li>\n<li>你的登录用户名</li>\n<li>你的 Fever API 密码</li>\n</ul>\n<p>在 Preferences » Personal data / Authentication » Personal data » Full name 处设置的用户名就是你 <strong>Fever API 的用户名</strong>：</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220455-2.png\" alt=\"找到你的用户名\"><figcaption>找到你的用户名</figcaption></figure>\n<p>在 Preferences » Fever Emulation 处你可以找到：</p>\n<ol>\n<li>Fever API 地址</li>\n<li>设置 Fever API 密码的地方</li>\n</ol>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220455-3.png\" alt=\"获取 Fever API 地址并设置 Fever Emulation 密码\"><figcaption>获取 Fever API 地址并设置 Fever Emulation 密码</figcaption></figure>\n<p>要知道，设置 Fever API 的密码时点击 Set Password 并不会提示「成功」，不过你可以从 XHR 请求中看到 Password saved 的 response，<strong>所以其实你的密码已经保存啦</strong>。用这里设置的 API 地址、用户名和密码，我们就能成功登录 Reeder 等 RSS 阅读器了。</p>\n<h2 id=\"如何设置分栏视图\"><a href=\"#%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E5%88%86%E6%A0%8F%E8%A7%86%E5%9B%BE\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>如何设置分栏视图</h2>\n<p>「分栏视图」就是类似笔记应用的一个侧边栏显示订阅文章列表，另一侧显示文章内容的视图。你可以：</p>\n<ol>\n<li>\n<p>在 Preferences » Preferences » Articles 中关闭 Combined mode 的设置：</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220455-4.png\" alt=\"关闭 Combined mode\"><figcaption>关闭 Combined mode</figcaption></figure>\n</li>\n<li>\n<p>回到主界面，在右上角的汉堡键 » Toggle widescreen mode 处点击打开宽屏模式：</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220455-5.png\" alt=\"打开宽屏模式\"><figcaption>打开宽屏模式</figcaption></figure>\n</li>\n</ol>\n<p>这样 Tiny Tiny RSS 就会以分栏视图显示文章列表和文章内容了。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220455-6.png\" alt=\"Tiny Tiny RSS 分栏视图\"><figcaption>Tiny Tiny RSS 分栏视图</figcaption></figure>\n<p>另外，我的基于 Feedly 修改的主题配置文件：<a href=\"https://gist.github.com/spencerwooo/7a373a3c921a50953ec12f329452ee27\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">GitHub - Gist</a></p>\n<h2 id=\"如何正确设置-mercury-全文抓取和-opencc-繁简转换-api\"><a href=\"#%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E8%AE%BE%E7%BD%AE-mercury-%E5%85%A8%E6%96%87%E6%8A%93%E5%8F%96%E5%92%8C-opencc-%E7%B9%81%E7%AE%80%E8%BD%AC%E6%8D%A2-api\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>如何正确设置 Mercury 全文抓取和 OpenCC 繁简转换 API</h2>\n<p>如果你使用了 Awesome TTRSS 中包含的 Mercury 全文抓取和 OpenCC 繁简转换 API，那么你应该在 <code class=\"language-text\">docker ps</code> 的输出中看到这两个服务的身影：</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220455-7.png\" alt=\"docker ps 的输出\"><figcaption>docker ps 的输出</figcaption></figure>\n<p>如果你这两个服务的配置和原配置一致：</p>\n<pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">service.mercury</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> wangqiru/mercury<span class=\"token punctuation\">-</span>parser<span class=\"token punctuation\">-</span>api<span class=\"token punctuation\">:</span>latest\n  <span class=\"token key atrule\">container_name</span><span class=\"token punctuation\">:</span> mercury\n  <span class=\"token key atrule\">expose</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> <span class=\"token number\">3000</span>\n  <span class=\"token key atrule\">restart</span><span class=\"token punctuation\">:</span> always\n\n<span class=\"token key atrule\">service.opencc</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> wangqiru/opencc<span class=\"token punctuation\">-</span>api<span class=\"token punctuation\">-</span>server<span class=\"token punctuation\">:</span>latest\n  <span class=\"token key atrule\">container_name</span><span class=\"token punctuation\">:</span> opencc\n  <span class=\"token key atrule\">environment</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">NODE_ENV</span><span class=\"token punctuation\">:</span> production\n  <span class=\"token key atrule\">expose</span><span class=\"token punctuation\">:</span>\n    <span class=\"token punctuation\">-</span> <span class=\"token number\">3000</span>\n  <span class=\"token key atrule\">restart</span><span class=\"token punctuation\">:</span> always</code></pre>\n<p>那么，你只需要在 Tiny Tiny RSS 的 Preferences 中开启这两个插件，并将 API 地址依次设置为如下即可。（Docker 会自动探索相应的服务 API 地址。）</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">Mercury</th>\n<th align=\"center\">OpenCC</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\"><code class=\"language-text\">service.mercury:3000</code></td>\n<td align=\"center\"><code class=\"language-text\">service.opencc:3000</code></td>\n</tr>\n<tr>\n<td align=\"center\"><figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/Snipaste_2020-07-22_22-13-39.png\" alt=\"Mercury 全文抓取\"><figcaption>Mercury 全文抓取</figcaption></figure></td>\n<td align=\"center\"><figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/Snipaste_2020-07-22_22-14-10.png\" alt=\"OpenCC 繁简转换\"><figcaption>OpenCC 繁简转换</figcaption></figure></td>\n</tr>\n</tbody>\n</table>\n<p>注意，你需要在每一个订阅源中明确指定使用 Mercury 或 OpenCC 服务（右键编辑），才可以真正保证服务的准确运行。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220455-9.png\" alt=\"编辑订阅源，开启 Mercury 或 OpenCC 服务\"><figcaption>编辑订阅源，开启 Mercury 或 OpenCC 服务</figcaption></figure>\n<h2 id=\"如何调试查看-tiny-tiny-rss-与其他容器服务的-log\"><a href=\"#%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E6%9F%A5%E7%9C%8B-tiny-tiny-rss-%E4%B8%8E%E5%85%B6%E4%BB%96%E5%AE%B9%E5%99%A8%E6%9C%8D%E5%8A%A1%E7%9A%84-log\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>如何调试、查看 Tiny Tiny RSS 与其他容器服务的 log</h2>\n<p>Docker 容器的 log 查看非常简单。如果我们想用 <code class=\"language-text\">docker-compose</code> 查看整个 Awesome TTRSS 的 log：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># 查看 docker-compose 的 log 后 5 条</span>\n<span class=\"token function\">docker-compose</span> logs <span class=\"token parameter variable\">--tail</span> <span class=\"token number\">5</span></code></pre>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220455-10.png\" alt=\"查看 docker-compose 启动的全部服务的 log\"><figcaption>查看 docker-compose 启动的全部服务的 log</figcaption></figure>\n<p>我们可以用下面的命令查看单个服务的 log：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># 查看 Mercury 服务后 5 条</span>\n<span class=\"token function\">docker</span> logs mercury <span class=\"token parameter variable\">--tail</span> <span class=\"token number\">5</span></code></pre>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220455-11.png\" alt=\"查看 Mercury 全文抓取的 log\"><figcaption>查看 Mercury 全文抓取的 log</figcaption></figure>\n<p>另外，我们也可以用下面的命令查看实时更新的 log：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># 查看实时更新的 Mercury 服务（显示 10 条）</span>\n<span class=\"token function\">docker</span> logs mercury <span class=\"token parameter variable\">--tail</span> <span class=\"token number\">10</span> <span class=\"token parameter variable\">-f</span></code></pre>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220455-12.png\" alt=\"查看实时更新的 Mercury 服务\"><figcaption>查看实时更新的 Mercury 服务</figcaption></figure>\n<h2 id=\"如何持久化-tiny-tiny-rss-图标\"><a href=\"#%E5%A6%82%E4%BD%95%E6%8C%81%E4%B9%85%E5%8C%96-tiny-tiny-rss-%E5%9B%BE%E6%A0%87\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>如何持久化 Tiny Tiny RSS 图标</h2>\n<p>升级更新了 Tiny Tiny RSS 服务之后，每次订阅源的图标都会丢失。我们可以通过将 Tiny Tiny RSS 的图标文件夹挂载到 Docker 容器之外来「持久化」图标存储。</p>\n<p>在 <code class=\"language-text\">docker-compose.yml</code> 中，将 Tiny Tiny RSS 的 Docker 容器配置 <code class=\"language-text\">service.rss</code> 中添加如下的配置：</p>\n<pre class=\"language-yaml\"><code class=\"language-yaml\"><span class=\"token key atrule\">volumes</span><span class=\"token punctuation\">:</span>\n  <span class=\"token punctuation\">-</span> ~/awesome<span class=\"token punctuation\">-</span>ttrss/feed<span class=\"token punctuation\">-</span>icons/<span class=\"token punctuation\">:</span>/var/www/feed<span class=\"token punctuation\">-</span>icons/ <span class=\"token comment\"># mount feed icons to local machine</span></code></pre>\n<p>这样即可将 Docker 容器里面 <code class=\"language-text\">/var/www/feed-icons/</code> 文件夹里面的内容挂载到外面服务器上的 <code class=\"language-text\">~/awesome-ttrss/feed-icons/</code> 文件夹。</p>\n<p>另外，我们还需要给 <code class=\"language-text\">~/awesome-ttrss/feed-icons/</code> 文件赋予合适的权限：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">chmod</span> <span class=\"token parameter variable\">-R</span> <span class=\"token number\">777</span> feed-icons</code></pre>\n<p>这样，Tiny Tiny RSS 下载的 favicon 就全部挂载到本机，更新 Docker 容器也不会对这些内容造成任何影响了。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220455-13.png\" alt=\"将订阅源的 icon 挂载到容器外部\"><figcaption>将订阅源的 icon 挂载到容器外部</figcaption></figure>\n<p>感谢阅读。🙇‍♂️</p>\n"}},{"node":{"title":"Remote Jupyter Lab：如何用 Jupyter Lab 将远程服务器资源最大化利用","path":"/2020/03/remote-jupyter-lab/","date":"March 12. 2020","timeToRead":1,"cjkWordCount":78,"cjkReadTime":1,"description":"Remote Jupyter Lab: how to utilize Jupyter Lab to its fullest on a remote server?","content":"<blockquote>\n<p>🎃 <strong>编者按：</strong></p>\n<p>本文原文以英文发表于 Medium - SpencerWeekly，本处仅为援引。本文将不会被翻译，也不会被转载至此中文博客。</p>\n</blockquote>\n<p><strong>Spencer Weekly</strong>: <a href=\"https://medium.com/spencerweekly/remote-jupyter-lab-how-to-utilize-jupyter-lab-to-its-fullest-on-a-remote-server-2a359159d2f6\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Remote Jupyter Lab: how to utilize Jupyter Lab to its fullest on a remote server?</a></p>\n"}},{"node":{"title":"Reverse Proxy | 反向代理是什么？","path":"/2019/11/reverse-proxy/","date":"November 22. 2019","timeToRead":11,"cjkWordCount":2619,"cjkReadTime":12,"description":"Nginx 反向代理的工作原理","content":"<p><a href=\"https://blog.spencerwoo.com/2019/11/tiny-tiny-rss/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Tiny Tiny RSS | 最速部署私有 RSS 服务器</a> 这篇文章里面，我们提到了「利用 Nginx 作为反向代理」来为 Tiny Tiny RSS 服务加上 SSL 支持。事实上，我经常都能在各个和 Nginx、Apache Server 等相关文档里面看到「反向代理」这个术语。今天我们就来看看，到底什么是反向代理？「反向代理」的工作原理，以及我们都可以用「反向代理」来干什么？</p>\n<h2 id=\"proxy什么是代理\"><a href=\"#proxy%E4%BB%80%E4%B9%88%E6%98%AF%E4%BB%A3%E7%90%86\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Proxy：什么是代理？</h2>\n<p>首先，反向代理（Reverse Proxy）是一种代理（Proxy）服务。为了搞清楚「反向代理」，我们首先来说一说「代理 - Proxy」。</p>\n<p>相信阅读这篇文章的同学一定对 Proxy 这个名词不陌生，<del>Mainland China 互联网现状让大部分同学的计算机网络知识突飞猛进</del>😂。简单来说，Proxy 服务器的主要功能就是在客户端 Client 和服务端 Server 之间搭建一个桥梁，从客户端访问服务端的网络流量、以及从服务端返回客户端的网络流量都会经由这一 Proxy 服务器的转发。<sup id=\"fnref-1\"><a href=\"#fn-1\" class=\"footnote-ref\">1</a></sup></p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-214045.png\" alt=\"功能示意\"><figcaption>功能示意</figcaption></figure>\n<p>为了方便表述，我们就叫我们的 Proxy 服务器：咕咕，一只鸽子。🐦</p>\n<h2 id=\"正向代理和反向代理\"><a href=\"#%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>正向代理和反向代理</h2>\n<h3 id=\"forward-proxy正向代理\"><a href=\"#forward-proxy%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Forward Proxy：正向代理</h3>\n<p>飞鸽传书嘛，信鸽主要功能就是通风报信，我们这里的咕咕也不例外。咕咕在正常情况下是我们自己（客户端）的，也就意味着：咕咕会在 Client 前面等待送信。当 Client 准备发送一个请求的时候，咕咕会拿着这个请求，在公共互联网上面，将请求准确送达至对应的 Server。同理，Server 返回 response 给 Client，response 也会先被咕咕拿到，之后再转交给 Client。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-214045-1.png\" alt=\"Forward Proxy 的工作原理\"><figcaption>Forward Proxy 的工作原理</figcaption></figure>\n<p>上面就是「正向代理」的基本工作流程，咕咕就是我们这个例子里面的正向代理服务器，负责转发和接受从 Client 发出或收到的网络请求。我们用正向代理（Forward Proxy），<del>除了大家人尽皆知的目的以外</del>😂，还可以：</p>\n<ul>\n<li>有效屏蔽广告、追踪脚本等有害请求。咕咕可以选择性的将 Server 发来的内容进行屏蔽，也就是：咕咕知道这次发来的是个广告，不给我们看也无妨大碍，那为了让我们浏览体验更加纯净，咕咕就非常体贴的丢掉了这一广告。爱了 ❤️ <sup id=\"fnref-2\"><a href=\"#fn-2\" class=\"footnote-ref\">2</a></sup></li>\n<li>有效的隐藏我们的身份。因为咕咕在你没有用到它的时候，可以并行的为其他同学传递请求。这时候，Server 是无从知道请求的真正来源的，只知道是由咕咕转手的，从而保证我们身份匿名性。</li>\n</ul>\n<h3 id=\"reverse-proxy反向代理\"><a href=\"#reverse-proxy%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Reverse Proxy：反向代理</h3>\n<p>那么反向代理是怎样工作的呢？在反向代理中，我们的咕咕现在由服务器 Server 养活（部署），也就是说，咕咕在服务器端通风报信。每个从 Client 经由互联网发过来的请求会先到达咕咕这里，咕咕再将每个请求分发给相应的服务器。反之亦然。这就是「反向代理」的基本工作原理，我们在这个例子里面的「咕咕」，就是我们的反向代理服务器。（Reverse Proxy Server）</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-214045-2.png\" alt=\"Reverse Proxy 的工作原理\"><figcaption>Reverse Proxy 的工作原理</figcaption></figure>\n<p>为什么我们服务端也需要一个这样的咕咕呢？因为我们的咕咕不仅勤劳，还很坚强。要知道，不是所有的目标服务器都像我们咕咕那么坚强，目标服务器很多时候会因为直接收到的信件过多（收到过多的请求）而被淹没，甚至宕机。如果有咕咕的帮助，目标服务器就不会因为请求过多而无法处理，同时如果咕咕发现一个服务的请求太多，我们可以将这一服务增加多个服务器共同处理，咕咕这时候就可以将服务的请求进行分流，从而减轻单个服务器的处理负担。<strong>这也就是「反向代理」在「负载均衡」方面的应用。</strong></p>\n<p>事实上，反向代理服务器有更多的应用，我们接下来就具体说一说我在服务器上面都利用 Nginx 反向代理服务器做了哪些有用的事情。</p>\n<h2 id=\"nginx-反向代理的实际应用\"><a href=\"#nginx-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Nginx 反向代理的实际应用</h2>\n<p>在我的（<a href=\"https://blog.tenkeyseven.com\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">@TenkeySeven</a> 的）服务器上面，有这样的几个服务：</p>\n<ul>\n<li><a href=\"https://tt-rss.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Tiny Tiny RSS 服务</a></li>\n<li><a href=\"https://github.com/netdata/netdata\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Netdata 服务器监控服务</a></li>\n<li>Nginx 直接 serve 的一个默认静态页面</li>\n</ul>\n<p>事实上，这三个服务都运行在这样的一个服务器上面，但是绑定了不同的域名。比如：</p>\n<ul>\n<li>Tiny Tiny RSS 服务对应域名：<a href=\"https://ttrss.tenkeyseven.com\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://ttrss.tenkeyseven.com</a>（需要登录）</li>\n<li>Netdata 服务对应域名：<a href=\"https://stats.tenkeyseven.com\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://stats.tenkeyseven.com</a>（可以公开访问）</li>\n<li>Nginx 测试静态页面对应域名：<a href=\"https://tenkeyseven.com\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://tenkeyseven.com</a>（可以公开访问）</li>\n</ul>\n<p>我们连接到服务器上面，执行下面的命令来查看端口占用情况：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">netstat</span> <span class=\"token parameter variable\">-tulpn</span> <span class=\"token operator\">|</span> <span class=\"token function\">grep</span> LISTEN</code></pre>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-214045-3.png\" alt=\"端口占用情况\"><figcaption>端口占用情况</figcaption></figure>\n<p>通过查看端口占用情况，我们可以非常清晰的看到：</p>\n<ul>\n<li>Tiny Tiny RSS 运行于 Docker 容器中，对外的 exposed 端口是 181</li>\n<li>Netdata 前端服务直接监听的端口是 19999</li>\n<li>Nginx 默认 serve 的静态页面直接监听 80 端口（HTTP）</li>\n</ul>\n<p><a href=\"https://blog.tenkeyseven.com\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">@TenkeySeven</a> 将主域名和上面提到的两个子域名的 DNS 解析均设置为我们的服务器，因此，当我们访问上面任意一个域名的时候，请求均直接发给服务器上面运行的 Nginx 反向代理服务。</p>\n<p>对 Nginx 来说，只需要识别这些域名对应的请求应该转发给具体哪个服务，就可以让请求被正确处理，这样也就实现了我们多个域名对应一个服务器上的多个服务的需求。</p>\n<p>Nginx 全部功能均由配置文件 <code class=\"language-text\">nginx.conf</code> 来设置，这一配置文件通常位于 <code class=\"language-text\">/etc/nginx/nginx.conf</code>，我们仔细看一下 Nginx 的配置文件。</p>\n<h3 id=\"对-upstream-服务器的定义\"><a href=\"#%E5%AF%B9-upstream-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%AE%9A%E4%B9%89\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>对 upstream 服务器的定义</h3>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-214045-4.png\" alt=\"对 upstream 服务器的声明\"><figcaption>对 upstream 服务器的声明</figcaption></figure>\n<p>首先，我们在 Nginx 的 <code class=\"language-text\">http</code> 项目下，定义了我们可能需要用到的 upstream 服务器。比如，对 Tiny Tiny RSS 来说，就是 181 端口的服务，用下面的语法进行声明：</p>\n<pre class=\"language-nginx\"><code class=\"language-nginx\"><span class=\"token directive\"><span class=\"token keyword\">upstream</span> ttrssdev</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token directive\"><span class=\"token keyword\">server</span> 127.0.0.1:181</span><span class=\"token punctuation\">;</span>\n    <span class=\"token directive\"><span class=\"token keyword\">keepalive</span> <span class=\"token number\">64</span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>这样，下面 <code class=\"language-text\">ttrss.tenkeyseven.com</code> 域名的 Proxy 转发规则就可以直接用 <code class=\"language-text\">http://ttrssdev</code> 的格式进行声明了。</p>\n<h3 id=\"默认-web-root-的定义\"><a href=\"#%E9%BB%98%E8%AE%A4-web-root-%E7%9A%84%E5%AE%9A%E4%B9%89\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>默认 Web Root 的定义</h3>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-214045-5.png\" alt=\"默认访问 Web Root 的配置\"><figcaption>默认访问 Web Root 的配置</figcaption></figure>\n<p>可以发现，当我们服务并不绑定任何上游服务器，而是直接由 Nginx 来提供服务的时候，Nginx 可以直接 serve 一个目标路径里面的 HTML 文件，比如这里的 <code class=\"language-text\">/usr/share/nginx/html</code>。此时，直接访问默认主域名 <code class=\"language-text\">tenkeyseven.com</code>，我们就能直接看到一个默认的静态网页。具体来说，Nginx 就是下面这部分内容的配置，知道当请求匹配到 <code class=\"language-text\">server_name</code> 定义的域名时，serve <code class=\"language-text\">root</code> 处定义的 HTML 静态网站。</p>\n<pre class=\"language-nginx\"><code class=\"language-nginx\"><span class=\"token directive\"><span class=\"token keyword\">server</span></span> <span class=\"token punctuation\">{</span>\n   <span class=\"token directive\"><span class=\"token keyword\">server_name</span> tenkeyseven.com</span><span class=\"token punctuation\">;</span> <span class=\"token comment\"># managed by Certbot</span>\n       <span class=\"token directive\"><span class=\"token keyword\">root</span>         /usr/share/nginx/html</span><span class=\"token punctuation\">;</span>\n       <span class=\"token comment\"># ...</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<h3 id=\"proxy-转发规则的定义\"><a href=\"#proxy-%E8%BD%AC%E5%8F%91%E8%A7%84%E5%88%99%E7%9A%84%E5%AE%9A%E4%B9%89\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Proxy 转发规则的定义</h3>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-214045-6.png\" alt=\"反向代理 Tiny Tiny RSS 转发规则的定义\"><figcaption>反向代理 Tiny Tiny RSS 转发规则的定义</figcaption></figure>\n<p>当我们需要让 Nginx 反向代理转发我们的请求至 upstream 服务的时候，就是类似这样的配置。此时，当请求匹配到 <code class=\"language-text\">server_name</code> 定义的 <code class=\"language-text\">ttrss.tenkeyseven.com</code> 时，Nginx 不 serve <code class=\"language-text\">root</code> 处定义的页面，而是在 <code class=\"language-text\">location / { ... }</code> 处找到 <code class=\"language-text\">proxy_pass</code> 的定义，将请求对应的转发到目标服务那里。可以看到，这里我们直接声明了 <code class=\"language-text\">proxy_pass http://ttrssdev;</code>，于是，当我们访问 <code class=\"language-text\">https://ttrss.tenkeyseven.com</code> 的时候，Nginx 反向代理服务会直接将请求转发至我们部署的 Tiny Tiny RSS 服务，在服务器上就是 <code class=\"language-text\">localhost:181</code> 的服务。</p>\n<p>Nginx 反向代理具体的配置如下 <code class=\"language-text\">location / { ... }</code> 里面的配置：</p>\n<pre class=\"language-nginx\"><code class=\"language-nginx\"><span class=\"token directive\"><span class=\"token keyword\">server</span></span> <span class=\"token punctuation\">{</span>\n   <span class=\"token directive\"><span class=\"token keyword\">server_name</span> ttrss.tenkeyseven.com</span><span class=\"token punctuation\">;</span> <span class=\"token comment\"># managed by Certbot</span>\n       <span class=\"token comment\"># root         /usr/share/nginx/html;</span>\n\n       <span class=\"token comment\"># Load configuration files for the default server block.</span>\n       <span class=\"token directive\"><span class=\"token keyword\">include</span> /etc/nginx/default.d/*.conf</span><span class=\"token punctuation\">;</span>\n\n       <span class=\"token directive\"><span class=\"token keyword\">location</span> /</span> <span class=\"token punctuation\">{</span>\n           <span class=\"token directive\"><span class=\"token keyword\">proxy_redirect</span> <span class=\"token boolean\">off</span></span><span class=\"token punctuation\">;</span>\n           <span class=\"token directive\"><span class=\"token keyword\">proxy_pass</span> http://ttrssdev</span><span class=\"token punctuation\">;</span>\n\n           <span class=\"token directive\"><span class=\"token keyword\">proxy_set_header</span>  Host                <span class=\"token variable\">$http_host</span></span><span class=\"token punctuation\">;</span>\n           <span class=\"token directive\"><span class=\"token keyword\">proxy_set_header</span>  X-Real-IP           <span class=\"token variable\">$remote_addr</span></span><span class=\"token punctuation\">;</span>\n           <span class=\"token directive\"><span class=\"token keyword\">proxy_set_header</span>  X-Forwarded-Ssl     <span class=\"token boolean\">on</span></span><span class=\"token punctuation\">;</span>\n           <span class=\"token directive\"><span class=\"token keyword\">proxy_set_header</span>  X-Forwarded-For     <span class=\"token variable\">$proxy_add_x_forwarded_for</span></span><span class=\"token punctuation\">;</span>\n           <span class=\"token directive\"><span class=\"token keyword\">proxy_set_header</span>  X-Forwarded-Proto   <span class=\"token variable\">$scheme</span></span><span class=\"token punctuation\">;</span>\n           <span class=\"token directive\"><span class=\"token keyword\">proxy_set_header</span>  X-Frame-Options     SAMEORIGIN</span><span class=\"token punctuation\">;</span>\n\n           <span class=\"token directive\"><span class=\"token keyword\">client_max_body_size</span>        <span class=\"token number\">100m</span></span><span class=\"token punctuation\">;</span>\n           <span class=\"token directive\"><span class=\"token keyword\">client_body_buffer_size</span>     <span class=\"token number\">128k</span></span><span class=\"token punctuation\">;</span>\n\n           <span class=\"token directive\"><span class=\"token keyword\">proxy_buffer_size</span>           <span class=\"token number\">4k</span></span><span class=\"token punctuation\">;</span>\n           <span class=\"token directive\"><span class=\"token keyword\">proxy_buffers</span>               <span class=\"token number\">4</span> <span class=\"token number\">32k</span></span><span class=\"token punctuation\">;</span>\n           <span class=\"token directive\"><span class=\"token keyword\">proxy_busy_buffers_size</span>     <span class=\"token number\">64k</span></span><span class=\"token punctuation\">;</span>\n           <span class=\"token directive\"><span class=\"token keyword\">proxy_temp_file_write_size</span>  <span class=\"token number\">64k</span></span><span class=\"token punctuation\">;</span>\n       <span class=\"token punctuation\">}</span>\n\n    <span class=\"token comment\"># ...</span>\n<span class=\"token punctuation\">}</span></code></pre>\n<p>事实上，这部分的配置非常简单。得益于 Let's Encrypt 的存在，我们可以利用 Certbot 在签署每个域名的 SSL 证书时，自动生成对应服务的转发配置。因此，事实上我们只需要声明前面介绍的 upstream 服务，并在 Certbot 生成的对应域名下的 location 子项处将服务器对应到反向代理的配置项处即可。</p>\n<h2 id=\"小结\"><a href=\"#%E5%B0%8F%E7%BB%93\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>小结</h2>\n<p>最后，我们可以看到，经过这样的配置，我们从外界互联网访问我们服务器的请求，就被 Nginx 反向代理分别导向了对应的服务器，从而实现了多个域名对应多个服务，并部署在同一个服务器上面的功能。同时，Nginx 反向代理服务统一帮我们管理了 SSL 证书的签署，因此无论是从外界来访问我们服务器的请求，还是我们服务器里面某个服务返回给外界的请求，都是经过加密的 HTTPS 请求。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-214045-7.png\" alt=\"Nginx 反向代理在上文中的功能\"><figcaption>Nginx 反向代理在上文中的功能</figcaption></figure>\n<p>Nginx 反向代理服务器还有更多的功能，比如：</p>\n<ul>\n<li>前文提到的负载均衡（Load balance）</li>\n<li>用反向代理来作为 CDN，cache 一部分资源，加快访问速度</li>\n<li>在请求到达目标服务器之前，反向代理服务器事先过滤掉一部分恶意请求，保证提供服务的目标服务器的稳定工作</li>\n<li>……</li>\n</ul>\n<p>抛砖引玉，感谢阅读。</p>\n<div class=\"footnotes\">\n<hr>\n<ol>\n<li id=\"fn-1\">\n<p><a href=\"https://www.cloudflare.com/learning/cdn/glossary/reverse-proxy/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">What Is A Reverse Proxy? | Proxy Servers Explained - Cloudflare</a></p>\n<a href=\"#fnref-1\" class=\"footnote-backref\">↩</a>\n</li>\n<li id=\"fn-2\">\n<p><a href=\"https://www.youtube.com/watch?v=KBXTnrD_Zs4\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Block EVERY Online Ad with THIS / Linus Tech Tips</a></p>\n<a href=\"#fnref-2\" class=\"footnote-backref\">↩</a>\n</li>\n</ol>\n</div>\n"}},{"node":{"title":"Tiny Tiny RSS | 最速部署私有 RSS 服务器","path":"/2019/11/tiny-tiny-rss/","date":"November 18. 2019","timeToRead":12,"cjkWordCount":3039,"cjkReadTime":14,"description":"使用 Awesome TTRSS 部署 Tiny Tiny RSS 的 Docker 镜像","content":"<p>9012 年了，别的小朋友们服务器上面跑着各式各样的东西：博客、云盘、监控脚本……再看看我们那台闲（bai）置（piao）很久的阿里云 Server，里面的 Git 竟然还是 1.8 的上古版本。🤦‍♂️ 不如把那台服务器拿出来，部署一个属于自己的 RSS 服务器，甚至可以跟同学们一起用呢～</p>\n<h2 id=\"rss\"><a href=\"#rss\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>RSS</h2>\n<p>首先我们来说一说 RSS。RSS 的全称是 Really Simple Syndication（简易信息聚合），它是一种消息来源的格式规范，网站可以按照这种格式规范提供文章的标题、摘要、全文等信息给订阅用户，用户可以通过订阅不同网站 RSS 链接的方式将不同的信息源进行聚合，在一个工具里阅读这些内容。</p>\n<p>对于第一次接触 RSS 的同学，推荐大家阅读：<a href=\"https://sspai.com/post/56391\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">高效获取信息，你需要这份 RSS 入门指南</a>，进行扫盲。</p>\n<p>市面上有非常多的 RSS 聚合服务，来帮助我们统一管理、订阅、更新、筛选 RSS 源推送给我们的更新信息，避免我们被海量的文章淹没，也能保证我们多个设备上 RSS 的阅读进度一致。Feedly、Inoreader 等等都是非常不错的 RSS 服务，但是它们的免费版本都有着一定的限制，有时候无法满足我们的全部功能需求，而动辄一个月数十刀的订阅费用又让人望而却步。不慌，开源的 RSS 服务：Tiny Tiny RSS 可以满足我们 RSS 订阅的全部需求！</p>\n<h2 id=\"tiny-tiny-rss-的搭建\"><a href=\"#tiny-tiny-rss-%E7%9A%84%E6%90%AD%E5%BB%BA\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>Tiny Tiny RSS 的搭建</h2>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220309.jpg\" alt=\"使用 Feedly 主题的 Tiny Tiny RSS 服务端\"><figcaption>使用 Feedly 主题的 Tiny Tiny RSS 服务端</figcaption></figure>\n<p>Tiny Tiny RSS 是一个非常优秀的开源免费 RSS 服务引擎，可以直接部署在我们自己的服务器上面，借助于 Docker 优秀方便的容器技术和 Let’s Encrypt 异常简单的 SSL 证书签署机器人 <code class=\"language-text\">certbot</code>，我们几分钟之内就可以部署上线属于我们自己的 RSS 服务，运行在我们可控的服务器上，环境稳定，刷新及时，并且完全免费。👍（当然，除了服务器需要一定的费用。）</p>\n<p>在容器、HTTPS 证书自动签署和虚拟化技术极度发达的今天，整个部署过程非常方便简单。我接下来只利用 iPad 进行讲解演示我们的部署过程。请大家坐和放宽，我们立刻开始。</p>\n<h2 id=\"准备工作\"><a href=\"#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>准备工作</h2>\n<p>在开始之前，首先我们需要准备一个位于公网的服务器，以及一个可以通过 SSH 连接到服务器上的本地设备。这里我使用我同（bai）学（piao）的已经备案的阿里云服务器作为运行 Tiny Tiny RSS 的服务器，并使用 iPad 和 Blink Shell（一个支持 SSH 协议的 iOS 终端 App）作为我的操作设备。Blink Shell 是 iPad 上面最好用的 SSH/Mosh 工具，推荐大家使用。我们在 Blink Shell 中配置好服务器私钥，通过 SSH 登录服务器。</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220309-1.jpg\" alt=\"利用 Blink Shell 登录至服务器\"><figcaption>利用 Blink Shell 登录至服务器</figcaption></figure>\n<h2 id=\"利用-docker-部署-tiny-tiny-rss\"><a href=\"#%E5%88%A9%E7%94%A8-docker-%E9%83%A8%E7%BD%B2-tiny-tiny-rss\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>利用 Docker 部署 Tiny Tiny RSS</h2>\n<h3 id=\"安装-docker\"><a href=\"#%E5%AE%89%E8%A3%85-docker\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>安装 Docker</h3>\n<p>Docker 是非常优秀的虚拟化容器，借助于 Docker 我们可以方便的部署 Tiny Tiny RSS，首先我们在服务器上安装 Docker 本体。在服务器上面执行下面命令来安装 Docker：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">curl</span> <span class=\"token parameter variable\">-fsSL</span> https://get.docker.com/ <span class=\"token operator\">|</span> <span class=\"token function\">sh</span></code></pre>\n<p>然后启动 Docker 服务：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> systemctl start <span class=\"token function\">docker</span></code></pre>\n<p>然后，我们检查一下 Docker 是否启动成功。我们执行命令：<code class=\"language-text\">sudo systemctl status docker</code>：</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220309-2.jpg\" alt=\"检查 Docker 服务状态\"><figcaption>检查 Docker 服务状态</figcaption></figure>\n<p>看到如上的输出，说明我们 Docker 服务启动成功。</p>\n<p><em>参考资料：<a href=\"https://docs.docker.com/install/linux/docker-ce/centos/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Get Docker Engine - Community for CentOS | Docker Documentation</a></em></p>\n<h3 id=\"安装-docker-compose\"><a href=\"#%E5%AE%89%E8%A3%85-docker-compose\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>安装 docker-compose</h3>\n<p>接下来我们安装 <code class=\"language-text\">docker-compose</code>：一个管理和启动多个 Docker 容器的工具。由于 Tiny Tiny RSS 依赖有 PostgreSQL 的数据库服务以及 <a href=\"https://github.com/HenryQW/mercury_fulltext\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">mercury_fulltext</a> 的全文抓取服务等等，这些服务我们都借助于 Docker 部署，因此利用 <code class=\"language-text\">docker-compose</code> 就会大大降低我们的部署难度。</p>\n<p>我们继续，在服务器上面执行下面的命令来安装 <code class=\"language-text\">docker-compose</code>：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">curl</span> <span class=\"token parameter variable\">-L</span> https://github.com/docker/compose/releases/download/1.25.0/docker-compose-<span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">uname</span> <span class=\"token parameter variable\">-s</span><span class=\"token variable\">`</span></span>-<span class=\"token variable\"><span class=\"token variable\">`</span><span class=\"token function\">uname</span> <span class=\"token parameter variable\">-m</span><span class=\"token variable\">`</span></span> <span class=\"token parameter variable\">-o</span> /usr/local/bin/docker-compose</code></pre>\n<p>之后给予安装好的 <code class=\"language-text\">docker-compose</code> 可执行权限：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">chmod</span> +x /usr/local/bin/docker-compose</code></pre>\n<p><em>参考资料：<a href=\"https://docs.docker.com/compose/install/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Install Docker Compose | Docker Documentation</a></em></p>\n<p>最后我们运行 <code class=\"language-text\">docker-compose --version</code> 来检查安装是否成功。如果有如下输出，说明我们的 <code class=\"language-text\">docker-compose</code> 安装成功：</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220309-3.jpg\" alt=\"检查 docker-compose 安装情况\"><figcaption>检查 docker-compose 安装情况</figcaption></figure>\n<h3 id=\"安装-tiny-tiny-rss-及其周边服务\"><a href=\"#%E5%AE%89%E8%A3%85-tiny-tiny-rss-%E5%8F%8A%E5%85%B6%E5%91%A8%E8%BE%B9%E6%9C%8D%E5%8A%A1\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>安装 Tiny Tiny RSS 及其周边服务</h3>\n<p>准备工作已经全部完成，接下来我们下载由 Awesome-TTRSS 配置的 Tiny Tiny RSS 服务的 docker-compose 配置文件：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># 创建 ttrss 目录并进入</span>\n<span class=\"token function\">mkdir</span> ttrss <span class=\"token operator\">&amp;&amp;</span> <span class=\"token builtin class-name\">cd</span> ttrss\n\n<span class=\"token comment\"># 利用 curl 下载 ttrss 的 docker-compose 配置文件至服务器</span>\n<span class=\"token function\">curl</span> <span class=\"token parameter variable\">-fLo</span> docker-compose.yml https://github.com/HenryQW/Awesome-TTRSS/raw/master/docker-compose.yml</code></pre>\n<p>修改 docker-compose.yml 里面的内容：</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220309-4.png\" alt=\"修改 docker-compose 配置文件\"><figcaption>修改 docker-compose 配置文件</figcaption></figure>\n<ul>\n<li>在配置文件的第 7 行和第 23 行，将 PostgreSQL 数据库的默认密码进行修改。暴露在公网的数据库使用默认密码非常危险。</li>\n<li>在配置文件的第 18 行，将 Tiny Tiny RSS 服务的部署网址修改。比如我的部署网址是 <code class=\"language-text\">https://ttrss.tenkeyseven.com/</code>\n- 注意，如果你的部署 URL 包含端口（比如默认部署端口为 181 端口），那么这里的 URL 也需要加上端口号，格式为 <code class=\"language-text\">{网址}:{端口}</code>\n- 不过不必担心，如果你这里的 URL 配置不正确，那么访问 Tiny Tiny RSS 的时候，Tiny Tiny RSS 会提醒你修改这里的值为正确的 URL，按照提醒进行配置即可</li>\n</ul>\n<p>之后，我们保存配置文件，启动 Tiny Tiny RSS 服务。在刚刚的 <code class=\"language-text\">ttrss</code> 目录下执行：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">docker-compose</span> up <span class=\"token parameter variable\">-d</span></code></pre>\n<p>等待脚本执行完成，如果一切没有问题，那么接下来输入 <code class=\"language-text\">docker ps</code>，我们应该看到类似下面的结果：</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220309-5.jpg\" alt=\"查看正在运行的 Docker 容器\"><figcaption>查看正在运行的 Docker 容器</figcaption></figure>\n<p>上面内容表示我们开启了四个 Docker 容器，分别是：</p>\n<ul>\n<li>Tiny Tiny RSS 本身，监听端口为 <code class=\"language-text\">0.0.0.0:181 -&gt; 80</code>，同时暴露给外网</li>\n<li>PostgreSQL 数据库，仅供内部使用</li>\n<li>Mercury 全文抓取服务，仅供内部使用</li>\n<li>OpenCC 简体、繁体中文转换服务，仅供内部使用</li>\n</ul>\n<p>如果发现问题，修改 docker-compose 配置文件后，需要执行下面的命令重启 Docker 容器们：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># 关闭 Docker 容器们</span>\n<span class=\"token function\">docker-compose</span> down\n\n<span class=\"token comment\"># 删除已停止的 Docker 容器</span>\n<span class=\"token function\">docker-compose</span> <span class=\"token function\">rm</span>\n\n<span class=\"token comment\"># ……</span>\n<span class=\"token comment\"># 修改 docker-compose 配置文件</span>\n<span class=\"token comment\"># ……</span>\n\n<span class=\"token comment\"># 再次开启 Docker 服务</span>\n<span class=\"token function\">docker-compose</span> up <span class=\"token parameter variable\">-d</span></code></pre>\n<h2 id=\"安装-nginx-作为-docker-容器的反向代理\"><a href=\"#%E5%AE%89%E8%A3%85-nginx-%E4%BD%9C%E4%B8%BA-docker-%E5%AE%B9%E5%99%A8%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>安装 Nginx 作为 Docker 容器的反向代理</h2>\n<p>事实上，到上一步，如果我们访问 <code class=\"language-text\">{服务器 IP}:181</code>，应该可以直接看到 Tiny Tiny RSS 的 Web 前端，但是 Tiny Tiny RSS 并不能直接配置 SSL 证书，也就没法添加 HTTPS 支持。我们利用 Nginx 作为反向代理服务器，即可方便的给 Tiny Tiny RSS 单独绑定一个我们希望的域名，并利用 Let’s Encrypt 来部署 HTTPS。</p>\n<h3 id=\"安装-nginx\"><a href=\"#%E5%AE%89%E8%A3%85-nginx\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>安装 Nginx</h3>\n<p>首先我们来安装 Nginx，以 CentOS 为例，我们直接执行下面命令即可：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> yum <span class=\"token function\">install</span> nginx</code></pre>\n<p>之后开启 Nginx 服务：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> systemctl start nginx</code></pre>\n<p>检查 Nginx 是否启动成功：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> systemctl status nginx</code></pre>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220309-6.jpg\" alt=\"检查 Nginx 运行状态\"><figcaption>检查 Nginx 运行状态</figcaption></figure>\n<h3 id=\"签署-ssl-证书部署-https\"><a href=\"#%E7%AD%BE%E7%BD%B2-ssl-%E8%AF%81%E4%B9%A6%E9%83%A8%E7%BD%B2-https\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>签署 SSL 证书，部署 HTTPS</h3>\n<p>之后，我们利用 Let’s Encrypt 提供的 <code class=\"language-text\">certbot</code> 直接为 Nginx 配置 SSL 证书。首先，我们执行下面的命令安装 <code class=\"language-text\">certbot</code>：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> yum <span class=\"token function\">install</span> certbot python2-certbot-nginx</code></pre>\n<p>然后运行 <code class=\"language-text\">certbot</code> 来签署 SSL 证书并自动配置 Nginx 服务：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> certbot <span class=\"token parameter variable\">--nginx</span></code></pre>\n<p><em>参考资料：<a href=\"https://certbot.eff.org/lets-encrypt/centosrhel7-nginx\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Certbot | Nginx on CentOS/RHEL 7</a></em></p>\n<p>在这里，certbot 会要求我们输入我们希望签署 SSL 证书的域名，我们选择为 Tiny Tiny RSS 分配的域名（比如我的就是 <code class=\"language-text\">ttrss.tenkeyseven.com</code>）即可。另外，如果 certbot 询问是否需要将访问该网址的全部流量重定向至 HTTPS，那么选择「是」即可。我们等待脚本执行签署任务完毕，然后重启 Nginx 服务：</p>\n<pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> systemctl restart nginx</code></pre>\n<p>此时我们如果直接访问这一域名，应该就可以看到带有 HTTPS 的 Nginx 默认网站：</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220309-7.jpg\" alt=\"HTTPS 配置成功的 Nginx 默认网站\"><figcaption>HTTPS 配置成功的 Nginx 默认网站</figcaption></figure>\n<p>接下来，我们修改 Nginx 的配置文件，配置 Nginx 反向代理，将访问 <code class=\"language-text\">https://ttrss.tenkeyseven.com</code> 的请求指向我们刚刚部署好的 Tiny Tiny RSS 服务，对服务器来说，也就是 <code class=\"language-text\">127.0.0.1:181</code> 这一地址。（如果你没有更改 Tiny Tiny RSS 的端口号的话。）</p>\n<p>Nginx 的配置文件位于 <code class=\"language-text\">/etc/nginx/nginx.conf</code>，我们打开这一文件：</p>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220309-8.png\" alt=\"Nginx 配置文件\"><figcaption>Nginx 配置文件</figcaption></figure>\n<ul>\n<li>\n<p>在 <code class=\"language-text\">http</code> 项下，<code class=\"language-text\">server</code> 项前定义 <code class=\"language-text\">upstream</code> 服务：</p>\n<pre class=\"language-text\"><code class=\"language-text\">\t```\n\tupstream ttrssdev {\n\t\tserver 127.0.0.1:181;\n\t\tkeepalive 64;\n\t}\n\t```\n\n\t![Nginx upstream 服务声明](https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220309-9.jpg)</code></pre>\n</li>\n<li>\n<p>在刚刚 <code class=\"language-text\">certbot</code> 为我们生成好的响应域名 <code class=\"language-text\">server</code> 项下，注释掉第一行定义 <code class=\"language-text\">root</code> 的内容，并将 <code class=\"language-text\">location /</code> 项修改为：</p>\n<pre class=\"language-text\"><code class=\"language-text\">\t```\n\tlocation / {\n\t\tproxy_redirect off;\n\t\tproxy_pass http://ttrssdev;\n\n\t\tproxy_set_header  Host                $http_host;\n\t\tproxy_set_header  X-Real-IP           $remote_addr;\n\t\tproxy_set_header  X-Forwarded-Ssl     on;\n\t\tproxy_set_header  X-Forwarded-For     $proxy_add_x_forwarded_for;\n\t\tproxy_set_header  X-Forwarded-Proto   $scheme;\n\t\tproxy_set_header  X-Frame-Options     SAMEORIGIN;\n\n\t\tclient_max_body_size        100m;\n\t\tclient_body_buffer_size     128k;\n\n\t\tproxy_buffer_size           4k;\n\t\tproxy_buffers               4 32k;\n\t\tproxy_busy_buffers_size     64k;\n\t\tproxy_temp_file_write_size  64k;\n\t}\n\t```\n\n\t![Nginx 配置文件：反向代理配置](https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220309-10.jpg)</code></pre>\n</li>\n</ul>\n<p>这样，我们再次执行 <code class=\"language-text\">sudo systemctl restart nginx</code> 重启 Nginx 服务，一切顺利的话，我们就可以通过我们刚刚签署 SSL 证书的域名访问我们部署好的 Tiny Tiny RSS 服务了！鼓掌 👏</p>\n<p>Tiny Tiny RSS 的默认管理员账户密码是 admin 和 password，请在第一时间进行修改。</p>\n<h2 id=\"配置-tiny-tiny-rss\"><a href=\"#%E9%85%8D%E7%BD%AE-tiny-tiny-rss\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>配置 Tiny Tiny RSS</h2>\n<figure><img src=\"https://cdn.spencer.felinae98.cn/blog/2020/07/20200722-220309-11.jpg\" alt=\"Tiny Tiny RSS 配置、主题\"><figcaption>Tiny Tiny RSS 配置、主题</figcaption></figure>\n<p>如果上面步骤没有问题的话，我们在服务器上面所部署的 Tiny Tiny RSS 本身就已经包含了：</p>\n<ul>\n<li>Mercury 全文提取服务（默认未开启）</li>\n<li>OpenCC 繁简自动转换服务（默认未开启）</li>\n<li>Fever 格式输出插件（默认已开启，用来和 Reeder 等客户端进行连接）</li>\n<li>包括 Feedly、RSSHub 在内的多款主题</li>\n<li>等等……</li>\n</ul>\n<p>我们不需要多余的配置，开箱即可使用上面的主题和插件，根本不需要操心其他服务的部署和安装。我们登录自己的 Tiny Tiny RSS，在右上角「设置→ 插件」中即可启用上述插件，在「设置 → 主题」处就可以更改我们部署的 Tiny Tiny RSS 所用的主题。这些插件和主题在 <a href=\"https://sspai.com/post/41302\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">如何搭建属于自己的 RSS 服务，高效精准获取信息</a> 中已经介绍了使用方法，这里我就不再赘述了。</p>\n<p>如果有同学对上面的配置还有问题，请直接参考 <a href=\"https://ttrss.henry.wang/zh/#%E6%8F%92%E4%BB%B6\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Awesome TTRSS 的官方文档：🐋 Awesome TTRSS | 插件</a></p>\n<h2 id=\"小结\"><a href=\"#%E5%B0%8F%E7%BB%93\" aria-hidden=\"true\"><span class=\"icon icon-link\"></span></a>小结</h2>\n<p>Tiny Tiny RSS 的配置到这里就基本结束了，我相信你通过上面的配置一定已经在自己的服务器上部署成功了 Tiny Tiny RSS 服务，并为它添加了域名和 HTTPS 的支持。另外，Tiny Tiny RSS 还自带了账号系统，可以邀请其他志同道合的朋友们一起使用我们自己部署的 Tiny Tiny RSS。感谢阅读。</p>\n<p>📖 关联阅读：</p>\n<ul>\n<li><a href=\"https://ttrss.henry.wang/zh/#%E5%85%B3%E4%BA%8E\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">🐋 Awesome TTRSS</a></li>\n<li><a href=\"https://sspai.com/post/56893\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">少数派 sspai - Docker 的入门「指北」</a></li>\n<li><a href=\"https://sspai.com/post/41302\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">少数派 sspai - 如何搭建属于自己的 RSS 服务，高效精准获取信息</a></li>\n</ul>\n"}}]}}},"context":{}}